"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule
        /(^|[^\\]+)\\\*(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError2 = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path7, originalPath, doThrow) => {
      if (!isString(path7)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path7) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path7)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path7) => REGEX_TEST_INVALID_PATH.test(path7);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path7, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path7);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path7 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path7,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError2
        );
        return this._t(path7, cache, checkUnignored, slices);
      }
      _t(path7, cache, checkUnignored, slices) {
        if (path7 in cache) {
          return cache[path7];
        }
        if (!slices) {
          slices = path7.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path7] = this._testOne(path7, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path7] = parent.ignored ? parent : this._testOne(path7, checkUnignored);
      }
      ignores(path7) {
        return this._test(path7, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path7) => !this.ignores(path7);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path7) {
        return this._test(path7, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path7) => checkPath(path7 && checkPath.convert(path7), path7, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path7) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path7) || isNotRelative(path7);
    }
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/stillat-blade-parser/out/utilities/isNumeric.js
var require_isNumeric = __commonJS({
  "node_modules/stillat-blade-parser/out/utilities/isNumeric.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.is_numeric = void 0;
    var whitespace = [
      " ",
      "\n",
      "\r",
      "	",
      "\f",
      "\v",
      "\xA0",
      "\u2000",
      "\u2001",
      "\u2002",
      "\u2003",
      "\u2004",
      "\u2005",
      "\u2006",
      "\u2007",
      "\u2008",
      "\u2009",
      "\u200A",
      "\u200B",
      "\u2028",
      "\u2029",
      "\u3000"
    ].join("");
    function is_numeric(char) {
      return (typeof char === "number" || typeof char === "string" && whitespace.indexOf(char.slice(-1)) === -1) && char !== "" && !isNaN(char);
    }
    exports.is_numeric = is_numeric;
  }
});

// node_modules/stillat-blade-parser/out/utilities/stringUtilities.js
var require_stringUtilities = __commonJS({
  "node_modules/stillat-blade-parser/out/utilities/stringUtilities.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringUtilities = void 0;
    var isNumeric_1 = require_isNumeric();
    var StringUtilities = class {
      static normalizeLineEndings(string, to = "\n") {
        return string.replace(/\r?\n/g, to);
      }
      static split(text) {
        return text.split("");
      }
      static substring(text, start, length) {
        return text.substr(start, length);
      }
      static ctypeSpace(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\f\n\r\t\v ]+$/g)) !== -1;
      }
      static ctypeAlpha(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[A-Za-z]+$/g)) !== -1;
      }
      static ctypeDigit(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\d]+$/g)) !== -1;
      }
      static ctypePunct(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]+$/g)) !== -1;
      }
      static trimLeft(value, charList = "\\s") {
        return value.replace(new RegExp("^[" + charList + "]+"), "");
      }
      static trimRight(value, charList = "\\s") {
        return value.replace(new RegExp("[" + charList + "]+$"), "");
      }
      static isNumeric(string) {
        return (0, isNumeric_1.is_numeric)(string);
      }
      static substringCount(haystack, needle) {
        const subStr = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return (haystack.match(new RegExp(subStr, "gi")) || []).length;
      }
      static lastWord(value) {
        const chars = value.split(""), wordChars = [];
        for (let i = chars.length; i >= 0; i--) {
          if (chars[i] == " ") {
            break;
          }
          wordChars.push(chars[i]);
        }
        return wordChars.reverse().join();
      }
      static breakByNewLine(value) {
        return value.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
      }
      static removeEmptyNewLines(value) {
        const newLines = [], lines = StringUtilities.breakByNewLine(StringUtilities.normalizeLineEndings(value));
        lines.forEach((line) => {
          if (line.trim().length > 0) {
            newLines.push(line);
          }
        });
        return newLines.join("\n");
      }
      static replaceAllInString(value, oldString, newString) {
        return value.replace(new RegExp(oldString, "g"), newString);
      }
      static getTrimmedMatch(expression, value, index) {
        const match = expression.exec(value);
        if (match == null || match.length < index) {
          return null;
        }
        const candidate = match[index].trim();
        if (candidate.length == 0) {
          return null;
        }
        return candidate;
      }
      static assertMatchIs(expression, value, index, testValue) {
        const candidate = StringUtilities.getTrimmedMatch(expression, value, index);
        if (candidate != null && candidate == testValue) {
          return true;
        }
        return false;
      }
      static truncateString(str, num) {
        if (str.length <= num) {
          return str;
        }
        return str.slice(0, num) + "...";
      }
      static unwrapString(value) {
        const returnValue = value.substring(1);
        return returnValue.substring(0, returnValue.length - 1);
      }
      static getLastLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
          return "";
        }
        return lines[lines.length - 1];
      }
      static getFirstLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
          return "";
        }
        return lines[0];
      }
    };
    exports.StringUtilities = StringUtilities;
  }
});

// node_modules/stillat-blade-parser/out/nodes/nodes.js
var require_nodes = __commonJS({
  "node_modules/stillat-blade-parser/out/nodes/nodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayNode = exports.ArrayElementNode = exports.ArrayKeyValueNode = exports.ArrayElementSeparatorNode = exports.ArrayEndNode = exports.ArrayStartNode = exports.BladeVerbatimNode = exports.BladeStaticNode = exports.BladePhpNode = exports.BladeEntitiesEchoNode = exports.BladeEscapedEchoNode = exports.BladeEchoNode = exports.ForElseNode = exports.SwitchCaseNode = exports.SwitchStatementNode = exports.ConditionNode = exports.ExecutionBranchNode = exports.DirectiveNode = exports.ShorthandInlinePhpNode = exports.InlinePhpNode = exports.BladeCommentNode = exports.LiteralNode = exports.BladeComponentNode = exports.ComponentNameNode = exports.ParameterNode = exports.ParameterType = exports.AbstractNode = exports.FragmentParameterNode = exports.FragmentNode = exports.FragmentPosition = void 0;
    var uuid_1 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var stringUtilities_1 = require_stringUtilities();
    function newRefId() {
      return stringUtilities_1.StringUtilities.replaceAllInString((0, uuid_1.v4)(), "-", "_");
    }
    var FragmentPosition;
    (function(FragmentPosition2) {
      FragmentPosition2[FragmentPosition2["IsDynamicFragmentName"] = 0] = "IsDynamicFragmentName";
      FragmentPosition2[FragmentPosition2["InsideFragmentParameter"] = 1] = "InsideFragmentParameter";
      FragmentPosition2[FragmentPosition2["InsideFragment"] = 2] = "InsideFragment";
      FragmentPosition2[FragmentPosition2["Unresolved"] = 3] = "Unresolved";
    })(FragmentPosition = exports.FragmentPosition || (exports.FragmentPosition = {}));
    var FragmentNode = class {
      constructor() {
        this.startPosition = null;
        this.endPosition = null;
        this.index = 0;
        this.embeddedIndex = 0;
        this.refId = null;
        this.parameters = [];
        this.isSelfClosing = false;
        this.isClosingFragment = false;
        this.name = "";
        this.containsStructures = false;
        this.refId = newRefId();
      }
    };
    exports.FragmentNode = FragmentNode;
    var FragmentParameterNode = class {
      constructor() {
        this.startPosition = null;
        this.endPosition = null;
      }
    };
    exports.FragmentParameterNode = FragmentParameterNode;
    var AbstractNode = class {
      constructor() {
        this.parser = null;
        this.refId = null;
        this.startPosition = null;
        this.endPosition = null;
        this.sourceContent = "";
        this.index = 0;
        this.parentIndex = -1;
        this.parentTypeIndex = -1;
        this.parent = null;
        this.originalAbstractNode = null;
        this.fragment = null;
        this.fragmentPosition = FragmentPosition.Unresolved;
        this.containsAnyFragments = false;
        this.containsChildStructures = false;
        this.offset = null;
        this.errors = [];
        this.isInScriptTag = false;
        this.isInStyleTag = false;
        this.prevNode = null;
        this.nextNode = null;
        this.refId = newRefId();
      }
      isEmbedded() {
        return this.isInScriptTag || this.isInStyleTag;
      }
      getErrors() {
        return this.errors;
      }
      pushError(error) {
        if (this.parent != null) {
          this.parent.pushError(error);
        } else {
          if (this.parser != null) {
            this.parser.pushError(error);
          }
        }
        this.errors.push(error);
      }
      relativeOffset(offset) {
        var _a2, _b;
        return offset + ((_b = (_a2 = this.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0);
      }
      withParser(parser) {
        this.parser = parser;
        return this;
      }
      getParser() {
        return this.parser;
      }
    };
    exports.AbstractNode = AbstractNode;
    var ParameterType;
    (function(ParameterType2) {
      ParameterType2[ParameterType2["Parameter"] = 0] = "Parameter";
      ParameterType2[ParameterType2["Directive"] = 1] = "Directive";
      ParameterType2[ParameterType2["Attribute"] = 2] = "Attribute";
      ParameterType2[ParameterType2["InlineEcho"] = 3] = "InlineEcho";
    })(ParameterType = exports.ParameterType || (exports.ParameterType = {}));
    var ParameterNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.name = "";
        this.realName = "";
        this.value = "";
        this.terminatorStyle = '"';
        this.wrappedValue = "";
        this.content = "";
        this.type = ParameterType.Parameter;
        this.directive = null;
        this.inlineEcho = null;
        this.namePosition = null;
        this.valuePosition = null;
        this.isEscapedExpression = false;
        this.isExpression = false;
      }
    };
    exports.ParameterNode = ParameterNode;
    var ComponentNameNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.name = "";
        this.inlineName = "";
      }
    };
    exports.ComponentNameNode = ComponentNameNode;
    var BladeComponentNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.name = null;
        this.isClosingTag = false;
        this.isSelfClosing = false;
        this.innerContent = "";
        this.parameterContent = "";
        this.receivesAttributeBag = false;
        this.hasParameters = false;
        this.parameters = [];
      }
      getComponentName() {
        if (this.name == null) {
          return "";
        }
        let name = this.name.name.trim();
        if (this.name.inlineName.trim().length > 0) {
          name += ":" + this.name.inlineName.trim();
        }
        return name;
      }
      hasParameter(name) {
        for (let i = 0; i < this.parameters.length; i++) {
          if (this.parameters[i].realName == name) {
            return true;
          }
        }
        return false;
      }
      getParameter(name) {
        for (let i = 0; i < this.parameters.length; i++) {
          if (this.parameters[i].realName == name) {
            return this.parameters[i];
          }
        }
        return null;
      }
      getParametersExcept(parameters) {
        return this.parameters.filter((param) => {
          return !parameters.includes(param.realName);
        });
      }
    };
    exports.BladeComponentNode = BladeComponentNode;
    var LiteralNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.content = "";
      }
      getOutputContent() {
        let content = stringUtilities_1.StringUtilities.replaceAllInString(this.content, "@{", "{");
        content = stringUtilities_1.StringUtilities.replaceAllInString(content, "@@", "@");
        return content;
      }
    };
    exports.LiteralNode = LiteralNode;
    var BladeCommentNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.innerContentPosition = null;
        this.innerContent = "";
      }
      isMultiline() {
        return this.sourceContent.includes("\n");
      }
    };
    exports.BladeCommentNode = BladeCommentNode;
    var InlinePhpNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.cachedHasValidPhp = null;
        this.cachedPhpLastError = null;
        this.isInline = false;
      }
      hasValidPhp() {
        var _a2;
        if (this.cachedHasValidPhp == null) {
          const validator = (_a2 = this.getParser()) === null || _a2 === void 0 ? void 0 : _a2.getPhpValidator();
          if (validator != null) {
            this.cachedHasValidPhp = validator.isValid(this.sourceContent, false);
            this.cachedPhpLastError = validator.getLastError();
          } else {
            this.cachedHasValidPhp = false;
          }
        }
        return this.cachedHasValidPhp;
      }
      getPhpError() {
        return this.cachedPhpLastError;
      }
    };
    exports.InlinePhpNode = InlinePhpNode;
    var ShorthandInlinePhpNode = class extends InlinePhpNode {
    };
    exports.ShorthandInlinePhpNode = ShorthandInlinePhpNode;
    var DirectiveNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.name = "";
        this.directiveName = "";
        this.namePosition = null;
        this.hasDirectiveParameters = false;
        this.directiveParameters = "";
        this.directiveParametersPosition = null;
        this.children = [];
        this.childrenDocument = null;
        this.childTypeCounts = /* @__PURE__ */ new Map();
        this._conditionParserAbandonPairing = false;
        this.hasJsonParameters = false;
        this.ref = 0;
        this.isClosedBy = null;
        this.isOpenedBy = null;
        this.isClosingDirective = false;
        this.innerContent = "";
        this.documentContent = "";
        this.nodeContent = "";
        this.cachedHasValidJson = null;
        this.cachedHasValidPhp = null;
        this.cachedPhpLastError = null;
      }
      hasValidJson() {
        if (this.hasJsonParameters == false) {
          this.cachedHasValidJson = false;
        }
        if (this.cachedHasValidJson == null) {
          try {
            let params = this.getPhpContent().trim();
            if (params.startsWith("(") && params.endsWith(")")) {
              params = params.substring(1);
              params = params.substring(0, params.length - 1);
            }
            JSON.parse(params);
            this.cachedHasValidJson = true;
          } catch (err) {
            this.cachedHasValidJson = false;
          }
        }
        return this.cachedHasValidJson;
      }
      hasValidPhp() {
        var _a2;
        if (this.hasJsonParameters) {
          this.cachedHasValidPhp = false;
        }
        if (this.cachedHasValidPhp == null) {
          const validator = (_a2 = this.getParser()) === null || _a2 === void 0 ? void 0 : _a2.getPhpValidator();
          if (validator != null) {
            this.cachedHasValidPhp = validator.isValid(this.getPhpContent(), true);
            this.cachedPhpLastError = validator.getLastError();
          } else {
            this.cachedHasValidPhp = false;
          }
        }
        return this.cachedHasValidPhp;
      }
      getPhpError() {
        return this.cachedPhpLastError;
      }
      isFirstOfType() {
        return this.parentTypeIndex == 1;
      }
      hasInnerExpression() {
        if (!this.hasDirectiveParameters) {
          return false;
        }
        return this.getInnerContent().length > 0;
      }
      getInnerContent() {
        let params = this.directiveParameters.trim().substring(1);
        params = params.substring(0, params.length - 1);
        return params;
      }
      getImmediateChildren() {
        const immediateChildren = [];
        for (let i = 0; i < this.children.length; i++) {
          const node = this.children[i];
          if (node.parent == this) {
            if (node == this.isClosedBy) {
              break;
            }
            immediateChildren.push(node);
          }
        }
        return immediateChildren;
      }
      getPhpContent() {
        if (this.directiveName.toLowerCase() == "forelse") {
          return "foreach (" + this.getInnerContent() + "):endforeach;";
        }
        return this.directiveParameters;
      }
      getChildren() {
        if (this.isClosedBy == null) {
          return [];
        }
        const newChildren = [];
        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i];
          if (child instanceof DirectiveNode && child.refId == this.isClosedBy.refId) {
            break;
          }
          newChildren.push(child);
        }
        return newChildren;
      }
      hasChildDirectiveOfType(name) {
        const ofType = this.findFirstChildDirectiveOfType(name);
        return ofType != null;
      }
      findFirstChildDirectiveOfType(name) {
        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i];
          if (child instanceof DirectiveNode && child.directiveName == name) {
            return child;
          }
        }
        return null;
      }
      findFirstDirectChildDirectiveOfType(name) {
        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i];
          if (child instanceof DirectiveNode && child.directiveName == name) {
            if (child.parent != null && child.parent.refId == this.refId) {
              return child;
            }
          }
        }
        return null;
      }
      findDirectivesOfType(name) {
        const directives = [];
        this.children.forEach((node) => {
          if (node instanceof DirectiveNode && node.directiveName == name) {
            directives.push(node);
          }
        });
        return directives;
      }
      findDirectChildDirectivesOfType(name) {
        const directives = [];
        this.children.forEach((node) => {
          if (node instanceof DirectiveNode && node.directiveName == name) {
            if (node.parent != null && node.parent.refId == this.refId) {
              directives.push(node);
            }
          }
        });
        return directives;
      }
      clone() {
        const clone = new DirectiveNode();
        clone.children = [...this.children];
        clone.directiveName = this.directiveName;
        clone.directiveParameters = this.directiveParameters;
        clone.directiveParametersPosition = this.directiveParametersPosition;
        clone.documentContent = this.documentContent;
        clone.endPosition = this.endPosition;
        clone.hasDirectiveParameters = this.hasDirectiveParameters;
        clone.index = this.index;
        clone.innerContent = this.innerContent;
        clone.isClosedBy = this.isClosedBy;
        clone.isClosingDirective = this.isClosingDirective;
        clone.isOpenedBy = this.isOpenedBy;
        clone.name = this.name;
        clone.namePosition = this.namePosition;
        clone.parent = this.parent;
        clone.refId = this.refId;
        clone.sourceContent = this.sourceContent;
        clone.startPosition = this.startPosition;
        const parser = this.getParser();
        if (parser != null) {
          clone.withParser(parser);
        }
        clone.originalAbstractNode = this;
        clone.containsAnyFragments = this.containsAnyFragments;
        clone.containsChildStructures = this.containsChildStructures;
        clone.isInScriptTag = this.isInScriptTag;
        clone.isInStyleTag = this.isInStyleTag;
        return clone;
      }
      getFinalClosingDirective() {
        if (this.isClosedBy == null) {
          return this;
        }
        return this.isClosedBy.getFinalClosingDirective();
      }
    };
    exports.DirectiveNode = DirectiveNode;
    var ExecutionBranchNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.head = null;
        this.tail = null;
        this.nodes = [];
        this.childDocument = null;
        this.documentContent = "";
        this.innerContent = "";
        this.innerOffset = null;
      }
    };
    exports.ExecutionBranchNode = ExecutionBranchNode;
    var ConditionNode = class extends DirectiveNode {
      constructor() {
        super(...arguments);
        this.constructedFrom = null;
        this.nodeContent = "";
        this.logicBranches = [];
        this.chain = [];
      }
      getParent() {
        if (this.logicBranches.length > 0) {
          if (this.logicBranches[0].head != null) {
            if (this.logicBranches[0].head.parent != null && this.logicBranches[0].head.parent instanceof DirectiveNode) {
              return this.logicBranches[0].head.parent;
            }
          }
        }
        return null;
      }
    };
    exports.ConditionNode = ConditionNode;
    var SwitchStatementNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.constructedFrom = null;
        this.nodeContent = "";
        this.originalNode = null;
        this.tail = null;
        this.cases = [];
      }
    };
    exports.SwitchStatementNode = SwitchStatementNode;
    var SwitchCaseNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.order = 0;
        this.leadingNodes = [];
        this.leadingDocument = null;
        this.head = null;
        this.children = [];
        this.isDefault = false;
        this.isClosedBy = null;
        this.childDocument = null;
        this.documentContent = "";
        this.innerContent = "";
        this.innerOffset = null;
      }
    };
    exports.SwitchCaseNode = SwitchCaseNode;
    var ForElseNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.constructedFrom = null;
        this.nodeContent = "";
        this.originalNode = null;
        this.truthNodes = [];
        this.elseNode = null;
        this.falseNodes = [];
        this.tailNode = null;
        this.truthDocument = null;
        this.falseDocument = null;
        this.documentContent = "";
        this.truthDocumentContent = "";
        this.truthInnerContent = "";
        this.truthDocumentOffset = null;
        this.truthInnerOffset = null;
        this.falseDocumentContent = "";
        this.falseInnerContent = "";
        this.falseDocumentOffset = null;
        this.falseInnerOffset = null;
      }
    };
    exports.ForElseNode = ForElseNode;
    var BladeEchoNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.content = "";
        this.cachedHasValidPhp = null;
        this.cachedPhpLastError = null;
        this.isInlineEcho = false;
      }
      hasValidPhp() {
        var _a2;
        if (this.cachedHasValidPhp == null) {
          const validator = (_a2 = this.getParser()) === null || _a2 === void 0 ? void 0 : _a2.getPhpValidator();
          if (validator != null) {
            this.cachedHasValidPhp = validator.isValid(this.content, true);
            this.cachedPhpLastError = validator.getLastError();
          } else {
            this.cachedHasValidPhp = false;
          }
        }
        return this.cachedHasValidPhp;
      }
      getPhpError() {
        return this.cachedPhpLastError;
      }
    };
    exports.BladeEchoNode = BladeEchoNode;
    var BladeEscapedEchoNode = class extends BladeEchoNode {
    };
    exports.BladeEscapedEchoNode = BladeEscapedEchoNode;
    var BladeEntitiesEchoNode = class extends BladeEchoNode {
    };
    exports.BladeEntitiesEchoNode = BladeEntitiesEchoNode;
    var BladePhpNode = class extends AbstractNode {
    };
    exports.BladePhpNode = BladePhpNode;
    var BladeStaticNode = class extends AbstractNode {
    };
    exports.BladeStaticNode = BladeStaticNode;
    var BladeVerbatimNode = class extends AbstractNode {
    };
    exports.BladeVerbatimNode = BladeVerbatimNode;
    var ArrayStartNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.tokenLength = 0;
      }
    };
    exports.ArrayStartNode = ArrayStartNode;
    var ArrayEndNode = class extends AbstractNode {
    };
    exports.ArrayEndNode = ArrayEndNode;
    var ArrayElementSeparatorNode = class extends AbstractNode {
    };
    exports.ArrayElementSeparatorNode = ArrayElementSeparatorNode;
    var ArrayKeyValueNode = class extends AbstractNode {
    };
    exports.ArrayKeyValueNode = ArrayKeyValueNode;
    var ArrayElementNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.key = null;
        this.value = null;
        this.isLast = false;
      }
    };
    exports.ArrayElementNode = ArrayElementNode;
    var ArrayNode = class extends AbstractNode {
      constructor() {
        super(...arguments);
        this.elements = [];
        this.containsKeys = false;
        this.maxKeyLength = 0;
      }
    };
    exports.ArrayNode = ArrayNode;
  }
});

// node_modules/stillat-blade-parser/out/parser/bladeKeywords.js
var require_bladeKeywords = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/bladeKeywords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BladeKeywords = void 0;
    var BladeKeywords = class {
    };
    exports.BladeKeywords = BladeKeywords;
    BladeKeywords.Verbatim = "verbatim";
    BladeKeywords.EndVerbatim = "endverbatim";
    BladeKeywords.Php = "php";
    BladeKeywords.EndPhp = "endphp";
    BladeKeywords.If = "if";
    BladeKeywords.ElseIf = "elseif";
    BladeKeywords.Else = "else";
    BladeKeywords.Unless = "unless";
    BladeKeywords.ForElse = "forelse";
    BladeKeywords.EndForElse = "endforelse";
    BladeKeywords.Switch = "switch";
    BladeKeywords.EndSwitch = "endswitch";
    BladeKeywords.Default = "default";
    BladeKeywords.Case = "case";
  }
});

// node_modules/stillat-blade-parser/out/analyzers/pairManager.js
var require_pairManager = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/pairManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PairManager = void 0;
    var nodes_1 = require_nodes();
    var PairManager = class {
      static clearSpeculativeConditions() {
        this.speculativeConditions.clear();
      }
      static clearSpeculativeEndIfs() {
        this.speculativeEndIfs.clear();
      }
      static getSpeculativeConditions() {
        return this.speculativeConditions;
      }
      static getSpeculativeEndIfs() {
        return this.speculativeEndIfs;
      }
      static isSpeculativeCondition(name) {
        return this.speculativeConditions.has(name);
      }
      static isSpeculativeEndIf(name) {
        return this.speculativeEndIfs.has(name);
      }
      static registerSpeculativeCondition(name) {
        this.speculativeConditions.set(name, 1);
      }
      static registerSpeculativeEndIf(name) {
        this.speculativeEndIfs.set(name, 1);
      }
      static canClose(directive) {
        const checkName = "end" + directive.directiveName.toLowerCase();
        return this.possibleClosingNode.has(checkName);
      }
      static shouldRewrite(node) {
        if (this.customIfs.has(node.name)) {
          return true;
        }
        if (this.alwaysRewrite.includes(node.name)) {
          return true;
        }
        if (this.speculativeEndIfs.has(node.directiveName)) {
          return true;
        }
        if (this.speculativeConditions.has(node.name)) {
          return true;
        }
        return false;
      }
      static determineCandidates(nodes) {
        const allNonClosingCandidates = /* @__PURE__ */ new Map();
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode == false) {
            return;
          }
          const directive = node;
          if (!directive.directiveName.toLowerCase().startsWith("end")) {
            allNonClosingCandidates.set(directive.directiveName.toLowerCase(), 1);
          }
        });
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode == false) {
            return;
          }
          const directive = node;
          if (directive.directiveName.toLowerCase().startsWith("unless")) {
            const checkName = directive.directiveName.substring(6);
            if (checkName.length > 0) {
              this.speculativeConditions.set(directive.directiveName, 1);
              this.speculativeEndIfs.set("end" + checkName, 1);
            }
          }
          if (this.speculativeEndIfs.has(directive.directiveName)) {
            directive.isClosingDirective = true;
          }
          if (directive.directiveName.toLowerCase().startsWith("else")) {
            const checkName = directive.directiveName.substring(4);
            if (checkName != "if" && checkName.length > 0) {
              this.speculativeConditions.set(checkName, 1);
            }
          }
          if (directive.directiveName.toLowerCase().startsWith("end")) {
            const checkName = directive.directiveName.substring(3).toLowerCase();
            if (allNonClosingCandidates.has(checkName)) {
              this.possibleClosingNode.set(directive.directiveName.toLowerCase(), 1);
              directive.isClosingDirective = true;
            }
          }
        });
      }
    };
    exports.PairManager = PairManager;
    PairManager.possibleClosingNode = /* @__PURE__ */ new Map();
    PairManager.alwaysRewrite = [
      "unless",
      "sectionMissing",
      "hasSection",
      "can",
      "auth",
      "env",
      "isset",
      "guest",
      "cannot",
      "canany",
      "hasSection",
      "production"
    ];
    PairManager.customIfs = /* @__PURE__ */ new Map();
    PairManager.speculativeConditions = /* @__PURE__ */ new Map();
    PairManager.speculativeEndIfs = /* @__PURE__ */ new Map();
  }
});

// node_modules/stillat-blade-parser/out/analyzers/conditionalRewriteAnalyzer.js
var require_conditionalRewriteAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/conditionalRewriteAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConditionalRewriteAnalyzer = void 0;
    var nodes_1 = require_nodes();
    var bladeKeywords_1 = require_bladeKeywords();
    var pairManager_1 = require_pairManager();
    var ConditionalRewriteAnalyzer = class {
      static getNewName(node) {
        if (node.name == bladeKeywords_1.BladeKeywords.Unless) {
          return bladeKeywords_1.BladeKeywords.If;
        }
        if (pairManager_1.PairManager.isSpeculativeEndIf(node.directiveName)) {
          return bladeKeywords_1.BladeKeywords.If;
        }
        if (node.name == "can") {
          return bladeKeywords_1.BladeKeywords.If;
        }
        if (pairManager_1.PairManager.isSpeculativeCondition(node.name)) {
          return bladeKeywords_1.BladeKeywords.If;
        }
        if (pairManager_1.PairManager.customIfs.has(node.name)) {
          const lowerDirectiveName = node.directiveName.toLowerCase();
          if (lowerDirectiveName.startsWith("else")) {
            node.isClosingDirective = true;
            return bladeKeywords_1.BladeKeywords.ElseIf;
          } else if (lowerDirectiveName.startsWith("end")) {
            node.isClosingDirective = true;
            return bladeKeywords_1.BladeKeywords.If;
          }
          return bladeKeywords_1.BladeKeywords.If;
        }
        if (node.directiveName == "auth") {
          return bladeKeywords_1.BladeKeywords.If;
        }
        return node.name;
      }
      static rewrite(nodes) {
        const returnNodes = [];
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode) {
            if (pairManager_1.PairManager.shouldRewrite(node)) {
              const clone = node.clone();
              clone.name = this.getNewName(node);
              returnNodes.push(clone);
            } else {
              returnNodes.push(node);
            }
          } else {
            returnNodes.push(node);
          }
        });
        return returnNodes;
      }
    };
    exports.ConditionalRewriteAnalyzer = ConditionalRewriteAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/nodes/helpers.js
var require_helpers = __commonJS({
  "node_modules/stillat-blade-parser/out/nodes/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStartPosition = void 0;
    function getStartPosition(nodes) {
      if (nodes.length == 0) {
        return null;
      }
      return nodes[0].startPosition;
    }
    exports.getStartPosition = getStartPosition;
  }
});

// node_modules/stillat-blade-parser/out/utilities/arrayHelpers.js
var require_arrayHelpers = __commonJS({
  "node_modules/stillat-blade-parser/out/utilities/arrayHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intersect = void 0;
    function intersect(a, b) {
      const setA = new Set(a), setB = new Set(b), intersection = new Set([...setA].filter((x) => setB.has(x)));
      return Array.from(intersection);
    }
    exports.intersect = intersect;
  }
});

// node_modules/stillat-blade-parser/out/errors/bladeError.js
var require_bladeError = __commonJS({
  "node_modules/stillat-blade-parser/out/errors/bladeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BladeError = exports.ErrrorLevel = void 0;
    var ErrrorLevel;
    (function(ErrrorLevel2) {
      ErrrorLevel2[ErrrorLevel2["Error"] = 0] = "Error";
      ErrrorLevel2[ErrrorLevel2["Warning"] = 1] = "Warning";
    })(ErrrorLevel = exports.ErrrorLevel || (exports.ErrrorLevel = {}));
    var BladeError = class {
      constructor() {
        this.node = null;
        this.errorCode = "";
        this.message = "";
        this.level = ErrrorLevel.Error;
        this.range = null;
      }
      hash() {
        var _a2, _b, _c, _d;
        let positionSlug = "";
        if (this.node != null) {
          positionSlug = ((_b = (_a2 = this.node.endPosition) === null || _a2 === void 0 ? void 0 : _a2.offset) !== null && _b !== void 0 ? _b : 0).toString() + "|" + ((_d = (_c = this.node.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0).toString() + "|";
        }
        return positionSlug + "|" + this.errorCode;
      }
      static makeSyntaxError(errorCode, node, message, level) {
        if (level == null) {
          level = ErrrorLevel.Error;
        }
        const error = new BladeError();
        error.errorCode = errorCode;
        error.node = node;
        error.message = message;
        error.level = level;
        return error;
      }
    };
    exports.BladeError = BladeError;
  }
});

// node_modules/stillat-blade-parser/out/errors/bladeErrorCodes.js
var require_bladeErrorCodes = __commonJS({
  "node_modules/stillat-blade-parser/out/errors/bladeErrorCodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BladeErrorCodes = void 0;
    var BladeErrorCodes = class {
    };
    exports.BladeErrorCodes = BladeErrorCodes;
    BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT = "BLADE_001";
    BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION = "BLADE_002";
    BladeErrorCodes.TYPE_PARSE_UNCLOSED_SWITCH = "BLADE_003";
    BladeErrorCodes.TYPE_UNPAIRED_CLOSING_DIRECTIVE = "BLADE_004";
    BladeErrorCodes.TYPE_UNCLOSED_COMMENT = "BLADE_005";
    BladeErrorCodes.TYPE_UNCLOSED_PHP_DIRECTIVE = "BLADE_006";
    BladeErrorCodes.TYPE_UNPAIRED_PHP_CLOSING_DIRECTIVE = "BLADE_007";
    BladeErrorCodes.TYPE_UNCLOSED_VERBATIM = "BLADE_008";
    BladeErrorCodes.TYPE_UNPAIRED_VERBATIM_CLOSING_DIRECTIVE = "BLADE_009";
    BladeErrorCodes.TYPE_UNCLOSED_FOR_DIRECTIVE = "BLADE_010";
    BladeErrorCodes.TYPE_UNPAIRED_FOR_CLOSING_DIRECTIVE = "BLADE_011";
    BladeErrorCodes.TYPE_UNCLOSED_FOR_ELSE_DIRECTIVE = "BLADE_012";
    BladeErrorCodes.TYPE_UNPAIRED_FOR_ELSE_CLOSING_DIRECTIVE = "BLADE_013";
    BladeErrorCodes.TYPE_FOR_ELSE_MISSING_EMPTY_DIRECTIVE = "BLADE_014";
  }
});

// node_modules/stillat-blade-parser/out/analyzers/conditionPairAnalyzer.js
var require_conditionPairAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/conditionPairAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConditionPairAnalyzer = void 0;
    var bladeError_1 = require_bladeError();
    var bladeErrorCodes_1 = require_bladeErrorCodes();
    var nodes_1 = require_nodes();
    var bladeKeywords_1 = require_bladeKeywords();
    var ConditionPairAnalyzer = class {
      static isConditionalStructure(node) {
        if (node instanceof nodes_1.DirectiveNode == false) {
          return false;
        }
        const directive = node, name = directive.name;
        if (name == bladeKeywords_1.BladeKeywords.If || name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
          return true;
        }
        return false;
      }
      static requiresClose(node) {
        const name = node.name;
        if (name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
          if (node.isClosedBy != null) {
            return false;
          }
          return true;
        }
        if (node.isClosingDirective) {
          return false;
        }
        if (node.isClosedBy != null) {
          return false;
        }
        return true;
      }
      /**
       * Returns a list of valid closing node names for the provided node.
       *
       * @param current The current node's name.
       * @returns
       */
      static getValidClosingPairs(current) {
        if (current == bladeKeywords_1.BladeKeywords.If || current == bladeKeywords_1.BladeKeywords.ElseIf) {
          return ConditionPairAnalyzer.conditionClosingPairs;
        }
        return [];
      }
      /**
      * Descends through the nodes to find the closest logical
      * closing node for each opening conditional node type.
      *
      * @param nodes  The nodes to analyze.
      * @param node The primary node.
      * @param index  The primary node starting index.
      */
      static findClosestStructurePair(nodes, node, index) {
        const stack = [], nodeLen = nodes.length, conditionCloseIndex = /* @__PURE__ */ new Map();
        stack.push({
          node,
          index
        });
        for (let i = 0; i < nodeLen; i += 1) {
          const node2 = nodes[i];
          if (node2 instanceof nodes_1.DirectiveNode) {
            const name = node2.name;
            if (node2.isClosingDirective && name == bladeKeywords_1.BladeKeywords.If) {
              conditionCloseIndex.set(i, i);
              continue;
            } else {
              if (name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
                conditionCloseIndex.set(i, i);
                continue;
              }
            }
          }
        }
        while (stack.length > 0) {
          const curItem = stack.pop();
          if (curItem == null) {
            continue;
          }
          if (curItem.node._conditionParserAbandonPairing) {
            break;
          }
          const curNode = curItem.node, thisValidPairs = ConditionPairAnalyzer.getValidClosingPairs(curNode.name);
          let curIndex = curItem.index, doSkipValidation = false;
          for (let i = curIndex; i < nodeLen; i++) {
            const subNode = nodes[i];
            if (subNode instanceof nodes_1.DirectiveNode) {
              if (ConditionPairAnalyzer.isConditionalStructure(subNode)) {
                if (ConditionPairAnalyzer.requiresClose(subNode)) {
                  if (i == nodeLen - 1) {
                    doSkipValidation = false;
                    break;
                  }
                  stack.push(curItem);
                  stack.push({
                    node: subNode,
                    index: i + 1
                  });
                  doSkipValidation = true;
                  break;
                }
                if (curNode.isClosedBy != null) {
                  continue;
                }
                const subNodeName = subNode.name;
                let canClose = false;
                if (subNode.ref == 0 && (subNode.isClosingDirective && subNodeName == bladeKeywords_1.BladeKeywords.If || thisValidPairs.includes(subNodeName))) {
                  canClose = true;
                }
                if (subNode.refId == curNode.refId) {
                  canClose = false;
                }
                if (canClose) {
                  conditionCloseIndex.delete(i);
                  curNode.isClosedBy = subNode;
                  subNode.isOpenedBy = curNode;
                  subNode.ref += 1;
                  doSkipValidation = true;
                  break;
                }
              }
            }
          }
          if (!doSkipValidation) {
            if (curNode instanceof nodes_1.DirectiveNode) {
              const nodeName = curNode.name;
              if ((nodeName == bladeKeywords_1.BladeKeywords.ElseIf || nodeName == bladeKeywords_1.BladeKeywords.Else) && curNode.isOpenedBy == null) {
                curNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, curNode, "Unpaired condition control structure"));
                curNode._conditionParserAbandonPairing = true;
              }
              if (curNode.isClosedBy == null && ConditionPairAnalyzer.requiresClose(curNode)) {
                curNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, curNode, "Unpaired condition control structure"));
                curNode._conditionParserAbandonPairing = true;
              }
            }
          }
        }
      }
      static pairConditionals(nodes) {
        for (let i = 0; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node instanceof nodes_1.DirectiveNode && ConditionPairAnalyzer.isConditionalStructure(node)) {
            if (ConditionPairAnalyzer.requiresClose(node)) {
              ConditionPairAnalyzer.findClosestStructurePair(nodes, node, i + 1);
            }
          }
        }
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode && ConditionPairAnalyzer.isConditionalStructure(node)) {
            const name = node.name;
            if ((name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) && node.isOpenedBy == null) {
              node.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, node, "Unpaired condition control structure"));
              node._conditionParserAbandonPairing = true;
              return;
            }
            if (node.isClosedBy == null && ConditionPairAnalyzer.requiresClose(node)) {
              node.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, node, "Unpaired condition control structure"));
              node._conditionParserAbandonPairing = true;
              return;
            }
          }
        });
        return nodes;
      }
    };
    exports.ConditionPairAnalyzer = ConditionPairAnalyzer;
    ConditionPairAnalyzer.conditionClosingPairs = ["elseif", "else"];
  }
});

// node_modules/stillat-blade-parser/out/analyzers/forElsePairAnalyzer.js
var require_forElsePairAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/forElsePairAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForElsePairAnalyzer = void 0;
    var bladeDocument_1 = require_bladeDocument();
    var helpers_1 = require_helpers();
    var nodes_1 = require_nodes();
    var bladeKeywords_1 = require_bladeKeywords();
    var ForElsePairAnalyzer = class {
      static associate(nodes, document) {
        const reduced = [];
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode && node.name.toLowerCase() == bladeKeywords_1.BladeKeywords.ForElse && node.directiveName.toLowerCase() != bladeKeywords_1.BladeKeywords.EndForElse) {
            reduced.push(this.createForElseNode(node, document));
          } else {
            reduced.push(node);
          }
        });
        return reduced;
      }
      static createForElseNode(node, parser) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
        const forElseNode = new nodes_1.ForElseNode();
        forElseNode.withParser(parser);
        forElseNode.originalNode = node;
        forElseNode.startPosition = node.startPosition;
        forElseNode.endPosition = node.getFinalClosingDirective().endPosition;
        forElseNode.constructedFrom = node;
        const elseNode = node.findFirstDirectChildDirectiveOfType("empty");
        if (elseNode == null) {
          forElseNode.tailNode = node.children.pop();
          forElseNode.truthNodes = node.children;
          const truthStart = ((_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0) - 1, truthEnd = ((_e = (_d = (_c = node.isClosedBy) === null || _c === void 0 ? void 0 : _c.startPosition) === null || _d === void 0 ? void 0 : _d.index) !== null && _e !== void 0 ? _e : 0) - 1, truthLength = truthEnd - truthStart, truthInnerStart = ((_g = (_f = node.endPosition) === null || _f === void 0 ? void 0 : _f.index) !== null && _g !== void 0 ? _g : 0) + 1, truthInnerEnd = ((_k = (_j = (_h = node.isClosedBy) === null || _h === void 0 ? void 0 : _h.startPosition) === null || _j === void 0 ? void 0 : _j.index) !== null && _k !== void 0 ? _k : 0) - 1, truthInnerLength = truthInnerEnd - truthInnerStart;
          forElseNode.truthDocumentContent = parser.getText(truthStart, truthEnd);
          forElseNode.truthDocumentOffset = {
            start: truthStart,
            end: truthEnd,
            length: truthLength
          };
          forElseNode.truthInnerContent = parser.getText(truthInnerStart, truthInnerEnd);
          forElseNode.truthInnerOffset = {
            start: truthInnerStart,
            end: truthInnerEnd,
            length: truthInnerLength
          };
        } else {
          const children = node.children, truthNodes = [];
          let falseNodes = [];
          forElseNode.elseNode = elseNode;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.refId == elseNode.refId) {
              falseNodes = children.slice(i + 1);
              break;
            } else {
              truthNodes.push(child);
            }
          }
          forElseNode.truthNodes = truthNodes;
          if (falseNodes.length > 0) {
            forElseNode.tailNode = falseNodes.pop();
          }
          forElseNode.falseNodes = falseNodes;
          const truthStart = ((_m = (_l = node.startPosition) === null || _l === void 0 ? void 0 : _l.index) !== null && _m !== void 0 ? _m : 0) - 1, truthEnd = ((_p = (_o = elseNode.startPosition) === null || _o === void 0 ? void 0 : _o.index) !== null && _p !== void 0 ? _p : 0) - 1, truthLength = truthEnd - truthStart, truthInnerStart = ((_r = (_q = node.endPosition) === null || _q === void 0 ? void 0 : _q.index) !== null && _r !== void 0 ? _r : 0) + 1, truthInnerEnd = ((_t = (_s = elseNode.startPosition) === null || _s === void 0 ? void 0 : _s.index) !== null && _t !== void 0 ? _t : 0) - 1, truthInnerLength = truthInnerEnd - truthInnerStart;
          forElseNode.truthDocumentContent = parser.getText(truthStart, truthEnd);
          forElseNode.truthDocumentOffset = {
            start: truthStart,
            end: truthEnd,
            length: truthLength
          };
          forElseNode.truthInnerContent = parser.getText(truthInnerStart, truthInnerEnd);
          forElseNode.truthInnerOffset = {
            start: truthInnerStart,
            end: truthInnerEnd,
            length: truthInnerLength
          };
          const falseStart = ((_v = (_u = elseNode.startPosition) === null || _u === void 0 ? void 0 : _u.index) !== null && _v !== void 0 ? _v : 0) - 1, falseEnd = ((_y = (_x = (_w = node.isClosedBy) === null || _w === void 0 ? void 0 : _w.startPosition) === null || _x === void 0 ? void 0 : _x.index) !== null && _y !== void 0 ? _y : 0) - 1, falseLength = falseEnd - falseStart, falseInnerStart = ((_0 = (_z = elseNode.endPosition) === null || _z === void 0 ? void 0 : _z.index) !== null && _0 !== void 0 ? _0 : 0) + 1, falseInnerEnd = ((_3 = (_2 = (_1 = node.isClosedBy) === null || _1 === void 0 ? void 0 : _1.startPosition) === null || _2 === void 0 ? void 0 : _2.index) !== null && _3 !== void 0 ? _3 : 0) - 1, falseInnerLength = falseInnerEnd - falseInnerStart;
          forElseNode.falseDocumentContent = parser.getText(falseStart, falseEnd);
          forElseNode.falseDocumentOffset = {
            start: falseStart,
            end: falseEnd,
            length: falseLength
          };
          forElseNode.falseInnerContent = parser.getText(falseInnerStart, falseInnerEnd);
          forElseNode.falseInnerOffset = {
            start: falseInnerStart,
            end: falseInnerEnd,
            length: falseInnerLength
          };
        }
        forElseNode.truthDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(forElseNode.truthNodes), parser, (0, helpers_1.getStartPosition)(forElseNode.truthNodes));
        forElseNode.falseDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(forElseNode.falseNodes), parser, (0, helpers_1.getStartPosition)(forElseNode.falseNodes));
        const forElseStart = ((_5 = (_4 = node.startPosition) === null || _4 === void 0 ? void 0 : _4.index) !== null && _5 !== void 0 ? _5 : 0) - 1, forElseEnd = (_8 = (_7 = (_6 = node.isClosedBy) === null || _6 === void 0 ? void 0 : _6.endPosition) === null || _7 === void 0 ? void 0 : _7.index) !== null && _8 !== void 0 ? _8 : 0 - ((_10 = (_9 = node.startPosition) === null || _9 === void 0 ? void 0 : _9.index) !== null && _10 !== void 0 ? _10 : 0), forElseLength = forElseEnd - forElseStart;
        forElseNode.nodeContent = parser.getText(forElseStart, forElseEnd);
        forElseNode.documentContent = parser.getText(forElseStart, forElseEnd);
        forElseNode.offset = {
          start: forElseStart,
          end: forElseEnd,
          length: forElseLength
        };
        return forElseNode;
      }
    };
    exports.ForElsePairAnalyzer = ForElsePairAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/speculativeConditionAnalyzer.js
var require_speculativeConditionAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/speculativeConditionAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpeculativeConditionAnalyzer = void 0;
    var bladeDocument_1 = require_bladeDocument();
    var helpers_1 = require_helpers();
    var nodes_1 = require_nodes();
    var pairManager_1 = require_pairManager();
    var SpeculativeConditionAnalyzer = class {
      static analyze(nodes, document) {
        const reduced = [];
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
            const elseNode = node.findFirstChildDirectiveOfType("else");
            if (elseNode != null && elseNode.isClosedBy == null) {
              reduced.push(this.convertToConditionalNode(node, elseNode, document));
            } else {
              reduced.push(node);
            }
          } else {
            reduced.push(node);
          }
        });
        return reduced;
      }
      static convertToConditionalNode(node, elseNode, document) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const condition = new nodes_1.ConditionNode(), finalClosing = node.getFinalClosingDirective(), children = node.children, branchOneNodes = [];
        let branchTwoNodes = [];
        const tail = children.pop();
        condition.withParser(document);
        condition.parent = node.parent;
        condition.startPosition = node.startPosition;
        condition.endPosition = finalClosing.endPosition;
        condition.constructedFrom = node;
        const startOffset = ((_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0) - 1, length = (_d = (_c = finalClosing === null || finalClosing === void 0 ? void 0 : finalClosing.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0 - ((_f = (_e = node.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0), endOffset = startOffset + length;
        condition.nodeContent = document.getText(startOffset, length);
        condition.offset = {
          start: startOffset,
          end: endOffset,
          length
        };
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child instanceof nodes_1.DirectiveNode && child.refId == elseNode.refId) {
            branchTwoNodes = children.slice(i + 1);
            break;
          } else {
            branchOneNodes.push(child);
          }
        }
        const branchOne = new nodes_1.ExecutionBranchNode(), branchTwo = new nodes_1.ExecutionBranchNode();
        branchOne.withParser(document);
        branchTwo.withParser(document);
        node.isClosedBy = elseNode;
        elseNode.isOpenedBy = node;
        tail.isOpenedBy = elseNode;
        elseNode.isClosedBy = tail;
        const branchOneChildDocNodes = [...branchOneNodes], branchTwoChildDocNodes = [...branchTwoNodes];
        branchOneNodes.push(elseNode);
        branchOne.head = node;
        branchOne.nodes = branchOneNodes;
        branchOne.index = node.index;
        const branchOneStart = (_h = (_g = node.endPosition) === null || _g === void 0 ? void 0 : _g.index) !== null && _h !== void 0 ? _h : 0, branchOneEnd = ((_l = (_k = (_j = node.isClosedBy) === null || _j === void 0 ? void 0 : _j.startPosition) === null || _k === void 0 ? void 0 : _k.index) !== null && _l !== void 0 ? _l : 0) - 1, branchOneLength = branchOneEnd - branchOneStart, branchOneDocStart = ((_o = (_m = node.startPosition) === null || _m === void 0 ? void 0 : _m.index) !== null && _o !== void 0 ? _o : 0) - 1, branchOneDocEnd = ((_r = (_q = (_p = node.isClosedBy) === null || _p === void 0 ? void 0 : _p.startPosition) === null || _q === void 0 ? void 0 : _q.index) !== null && _r !== void 0 ? _r : 0) - 1, branchOneDocLength = branchOneDocEnd - branchOneDocStart;
        branchOne.innerContent = document.getText(branchOneStart, branchOneEnd);
        branchOne.documentContent = document.getText(branchOneDocStart, branchOneDocEnd);
        branchOne.innerOffset = {
          start: branchOneStart,
          end: branchOneEnd,
          length: branchOneLength
        };
        branchOne.offset = {
          start: branchOneDocStart,
          end: branchOneDocEnd,
          length: branchOneDocLength
        };
        branchTwoNodes.push(tail);
        branchTwo.head = elseNode;
        branchTwo.nodes = branchTwoNodes;
        branchTwo.index = elseNode.index;
        const branchTwoStart = (_t = (_s = elseNode.endPosition) === null || _s === void 0 ? void 0 : _s.index) !== null && _t !== void 0 ? _t : 0, branchTwoEnd = ((_w = (_v = (_u = elseNode.isClosedBy) === null || _u === void 0 ? void 0 : _u.startPosition) === null || _v === void 0 ? void 0 : _v.index) !== null && _w !== void 0 ? _w : 0) - 1, branchTwoLength = branchTwoEnd - branchTwoStart, branchTwoDocStart = ((_y = (_x = elseNode.startPosition) === null || _x === void 0 ? void 0 : _x.index) !== null && _y !== void 0 ? _y : 0) - 1, branchTwoDocEnd = ((_1 = (_0 = (_z = elseNode.isClosedBy) === null || _z === void 0 ? void 0 : _z.startPosition) === null || _0 === void 0 ? void 0 : _0.index) !== null && _1 !== void 0 ? _1 : 0) - 1, branchTwoDocLength = branchTwoDocEnd - branchTwoDocStart;
        branchTwo.innerContent = document.getText(branchTwoStart, branchTwoEnd);
        branchTwo.documentContent = document.getText(branchTwoDocStart, branchTwoDocEnd);
        branchTwo.innerOffset = {
          start: branchTwoStart,
          end: branchTwoEnd,
          length: branchTwoLength
        };
        branchTwo.offset = {
          start: branchTwoDocStart,
          end: branchTwoDocEnd,
          length: branchTwoDocLength
        };
        condition.chain = [node.index, elseNode.index];
        condition.logicBranches.push(branchOne);
        condition.logicBranches.push(branchTwo);
        branchOne.startPosition = branchOne.nodes[0].startPosition;
        branchOne.endPosition = branchOne.nodes[branchOne.nodes.length - 1].startPosition;
        branchOne.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(branchOneChildDocNodes), document, (0, helpers_1.getStartPosition)(branchOneChildDocNodes));
        branchTwo.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(branchTwoChildDocNodes), document, (0, helpers_1.getStartPosition)(branchTwoChildDocNodes));
        branchTwo.startPosition = branchTwo.nodes[0].startPosition;
        branchTwo.endPosition = branchTwo.nodes[branchTwo.nodes.length - 1].startPosition;
        pairManager_1.PairManager.registerSpeculativeCondition(node.directiveName);
        return condition;
      }
    };
    exports.SpeculativeConditionAnalyzer = SpeculativeConditionAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/switchPairAnalyzer.js
var require_switchPairAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/switchPairAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwitchPairAnalyzer = void 0;
    var bladeDocument_1 = require_bladeDocument();
    var helpers_1 = require_helpers();
    var nodes_1 = require_nodes();
    var bladeKeywords_1 = require_bladeKeywords();
    var SwitchPairAnalyzer = class {
      static associate(nodes, document) {
        const reduced = [];
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode && node.directiveName.toLowerCase() == bladeKeywords_1.BladeKeywords.Switch) {
            reduced.push(this.createSwitchNode(node, document));
          } else {
            reduced.push(node);
          }
        });
        return reduced;
      }
      static createSwitchNode(node, parser) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
        const switchNode = new nodes_1.SwitchStatementNode(), children = node.children;
        switchNode.originalNode = node;
        switchNode.startPosition = node.startPosition;
        switchNode.endPosition = node.getFinalClosingDirective().endPosition;
        switchNode.parent = node.parent;
        switchNode.withParser(parser);
        switchNode.constructedFrom = node;
        let currentNodes = [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Switch) {
            i += child.children.length;
          }
          if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Case) {
            const caseChildren = this.collectUntil(node, children.slice(i + 1), [bladeKeywords_1.BladeKeywords.Case, bladeKeywords_1.BladeKeywords.Default, bladeKeywords_1.BladeKeywords.EndSwitch]), switchCase = new nodes_1.SwitchCaseNode();
            switchCase.parent = child.parent;
            if (switchNode.cases.length == 0 && currentNodes.length > 0) {
              switchCase.leadingNodes = currentNodes;
              if (currentNodes.length > 0) {
                const firstNode = currentNodes[0], lastNode = currentNodes[currentNodes.length - 1], start = (_b = (_a2 = firstNode.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0, end = ((_d = (_c = lastNode.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) + 1, childText = parser.getText(start, end);
                switchCase.leadingDocument = bladeDocument_1.BladeDocument.childFromText(childText, parser, firstNode.startPosition);
              }
              currentNodes = [];
            }
            switchCase.refId = child.refId;
            switchCase.index = child.index;
            switchCase.startPosition = child.startPosition;
            switchCase.endPosition = child.endPosition;
            switchCase.order = switchNode.cases.length;
            switchCase.head = child;
            switchCase.isDefault = false;
            switchCase.children = caseChildren.children;
            switchCase.withParser(parser);
            switchCase.isClosedBy = caseChildren.brokeOn;
            child.isClosedBy = caseChildren.brokeOn;
            if (switchCase.children.length > 0) {
              const lastChild = switchCase.children[switchCase.children.length - 1];
              if (lastChild instanceof nodes_1.DirectiveNode && lastChild == node.isClosedBy) {
                switchCase.children.pop();
              }
            }
            switchCase.childDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(switchCase.children), parser, (0, helpers_1.getStartPosition)(switchCase.children));
            if (caseChildren.brokeOn != null) {
              switchCase.endPosition = caseChildren.brokeOn.startPosition;
            }
            const caseStart = ((_f = (_e = switchCase.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0) - 1, caseEnd = ((_j = (_h = (_g = switchCase.isClosedBy) === null || _g === void 0 ? void 0 : _g.startPosition) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0) - 1, length = caseEnd - caseStart, caseInnerStart = ((_l = (_k = child.endPosition) === null || _k === void 0 ? void 0 : _k.index) !== null && _l !== void 0 ? _l : 0) + 1, caseInnerEnd = ((_p = (_o = (_m = switchCase.isClosedBy) === null || _m === void 0 ? void 0 : _m.startPosition) === null || _o === void 0 ? void 0 : _o.index) !== null && _p !== void 0 ? _p : 0) - 1, innerLength = caseInnerEnd - caseInnerStart;
            switchCase.documentContent = parser.getText(caseStart, caseEnd);
            switchCase.innerContent = parser.getText(caseInnerStart, caseInnerEnd);
            switchCase.offset = {
              start: caseStart,
              end: caseEnd,
              length
            };
            switchCase.innerOffset = {
              start: caseInnerStart,
              end: caseInnerEnd,
              length: innerLength
            };
            switchNode.cases.push(switchCase);
          } else if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Default) {
            const caseChildren = children.slice(i + 1), defaultCase = new nodes_1.SwitchCaseNode();
            defaultCase.parent = child.parent;
            defaultCase.refId = child.refId;
            defaultCase.index = child.index;
            defaultCase.startPosition = child.startPosition;
            defaultCase.endPosition = node.startPosition;
            defaultCase.order = switchNode.cases.length;
            defaultCase.head = child;
            defaultCase.isDefault = true;
            defaultCase.children = caseChildren;
            defaultCase.withParser(parser);
            defaultCase.isClosedBy = node.isClosedBy;
            child.isClosedBy = node.isClosedBy;
            const childDocNodes = [...defaultCase.children], lastChild = childDocNodes[childDocNodes.length - 1];
            if (lastChild instanceof nodes_1.DirectiveNode && lastChild.refId == ((_q = node.isClosedBy) === null || _q === void 0 ? void 0 : _q.refId)) {
              childDocNodes.pop();
            }
            const caseStart = ((_s = (_r = defaultCase.startPosition) === null || _r === void 0 ? void 0 : _r.index) !== null && _s !== void 0 ? _s : 0) - 1, caseEnd = ((_v = (_u = (_t = defaultCase.isClosedBy) === null || _t === void 0 ? void 0 : _t.startPosition) === null || _u === void 0 ? void 0 : _u.index) !== null && _v !== void 0 ? _v : 0) - 1, length = caseEnd - caseStart, caseInnerStart = ((_x = (_w = child.endPosition) === null || _w === void 0 ? void 0 : _w.index) !== null && _x !== void 0 ? _x : 0) + 1, caseInnerEnd = ((_0 = (_z = (_y = defaultCase.isClosedBy) === null || _y === void 0 ? void 0 : _y.startPosition) === null || _z === void 0 ? void 0 : _z.index) !== null && _0 !== void 0 ? _0 : 0) - 1, innerLength = caseInnerEnd - caseInnerStart;
            defaultCase.documentContent = parser.getText(caseStart, caseEnd);
            defaultCase.innerContent = parser.getText(caseInnerStart, caseInnerEnd);
            defaultCase.offset = {
              start: caseStart,
              end: caseEnd,
              length
            };
            defaultCase.innerOffset = {
              start: caseInnerStart,
              end: caseInnerEnd,
              length: innerLength
            };
            defaultCase.childDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(childDocNodes), parser, (0, helpers_1.getStartPosition)(childDocNodes));
            switchNode.cases.push(defaultCase);
            break;
          } else {
            currentNodes.push(child);
          }
        }
        if (switchNode.cases.length > 0) {
          const lastChild = switchNode.cases[switchNode.cases.length - 1];
          if (lastChild.children.length > 0) {
            switchNode.tail = lastChild.children.pop();
          }
        }
        if (switchNode.cases.length == 0) {
          const childDocNodes = [...node.children];
          if (childDocNodes.length > 0) {
            if (childDocNodes[childDocNodes.length - 1] == node.isClosedBy) {
              childDocNodes.pop();
            }
          }
          node.childrenDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(childDocNodes), parser, (0, helpers_1.getStartPosition)(childDocNodes));
        }
        const switchStartOffset = ((_2 = (_1 = node.startPosition) === null || _1 === void 0 ? void 0 : _1.index) !== null && _2 !== void 0 ? _2 : 0) - 1, switchLength = (_5 = (_4 = (_3 = node.isClosedBy) === null || _3 === void 0 ? void 0 : _3.endPosition) === null || _4 === void 0 ? void 0 : _4.index) !== null && _5 !== void 0 ? _5 : 0 - ((_7 = (_6 = node.startPosition) === null || _6 === void 0 ? void 0 : _6.index) !== null && _7 !== void 0 ? _7 : 0), switchEndOffset = switchStartOffset + switchLength;
        switchNode.nodeContent = parser.getText(switchStartOffset, switchLength);
        switchNode.offset = {
          start: switchStartOffset,
          end: switchEndOffset,
          length: switchLength
        };
        if (switchNode.cases.length > 0) {
          const lastCase = switchNode.cases[switchNode.cases.length - 1];
          if (lastCase.isClosedBy == null) {
            lastCase.isClosedBy = node.isClosedBy;
          }
        }
        return switchNode;
      }
      static collectUntil(reference, children, breakFor) {
        var _a2;
        const childrenToReturn = [];
        let brokeOn = null;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child instanceof nodes_1.DirectiveNode && breakFor.includes(child.name) && ((_a2 = child.parent) === null || _a2 === void 0 ? void 0 : _a2.refId) == reference.refId) {
            brokeOn = child;
            break;
          }
          childrenToReturn.push(child);
        }
        return {
          children: childrenToReturn,
          brokeOn
        };
      }
    };
    exports.SwitchPairAnalyzer = SwitchPairAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/directivePairAnalyzer.js
var require_directivePairAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/directivePairAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectivePairAnalyzer = void 0;
    var bladeDocument_1 = require_bladeDocument();
    var helpers_1 = require_helpers();
    var nodes_1 = require_nodes();
    var bladeKeywords_1 = require_bladeKeywords();
    var arrayHelpers_1 = require_arrayHelpers();
    var conditionPairAnalyzer_1 = require_conditionPairAnalyzer();
    var forElsePairAnalyzer_1 = require_forElsePairAnalyzer();
    var pairManager_1 = require_pairManager();
    var speculativeConditionAnalyzer_1 = require_speculativeConditionAnalyzer();
    var switchPairAnalyzer_1 = require_switchPairAnalyzer();
    var DirectivePairAnalyzer = class {
      constructor() {
        this.document = null;
        this.parentNode = null;
        this.openDirectiveIndexCount = /* @__PURE__ */ new Map();
        this.closingDirectiveIndex = /* @__PURE__ */ new Map();
        this.closingDirectiveIndexCount = /* @__PURE__ */ new Map();
        this.closingDirectiveNames = /* @__PURE__ */ new Map();
        this.createdExecutionBranches = [];
        this.stackCount = 0;
      }
      buildCloseIndex(nodes) {
        var _a2, _b, _c;
        nodes.forEach((node) => {
          var _a3, _b2, _c2, _d, _e, _f, _g, _h;
          if (node instanceof nodes_1.DirectiveNode == false) {
            return;
          }
          const directive = node;
          if (directive.isClosingDirective == false) {
            return;
          }
          if (this.closingDirectiveIndex.has(this.stackCount) == false) {
            this.closingDirectiveIndex.set(this.stackCount, /* @__PURE__ */ new Map());
          }
          if (this.closingDirectiveIndexCount.has(this.stackCount) == false) {
            this.closingDirectiveIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
          }
          const directiveName = directive.name;
          if (((_a3 = this.closingDirectiveIndex.get(this.stackCount)) === null || _a3 === void 0 ? void 0 : _a3.has(directiveName)) == false) {
            (_b2 = this.closingDirectiveIndex.get(this.stackCount)) === null || _b2 === void 0 ? void 0 : _b2.set(directiveName, []);
            (_c2 = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _c2 === void 0 ? void 0 : _c2.set(directiveName, 0);
          }
          (_e = (_d = this.closingDirectiveIndex.get(this.stackCount)) === null || _d === void 0 ? void 0 : _d.get(directiveName)) === null || _e === void 0 ? void 0 : _e.push(node);
          const curCount = (_g = (_f = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _f === void 0 ? void 0 : _f.get(directiveName)) !== null && _g !== void 0 ? _g : 0;
          (_h = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _h === void 0 ? void 0 : _h.set(directiveName, curCount + 1);
        });
        if (this.closingDirectiveNames.has(this.stackCount) == false) {
          this.closingDirectiveNames.set(this.stackCount, []);
        }
        if (this.closingDirectiveIndex.has(this.stackCount)) {
          this.closingDirectiveNames.set(this.stackCount, Array.from((_b = (_a2 = this.closingDirectiveIndex.get(this.stackCount)) === null || _a2 === void 0 ? void 0 : _a2.keys()) !== null && _b !== void 0 ? _b : []));
          (_c = this.closingDirectiveIndex.get(this.stackCount)) === null || _c === void 0 ? void 0 : _c.forEach((indexedNodes, directiveName) => {
            var _a3, _b2, _c2, _d, _e;
            const indexedNodeCount = indexedNodes.length;
            if (indexedNodeCount == 0) {
              return;
            }
            const lastIndexedNode = indexedNodes[indexedNodeCount - 1];
            for (let i = 0; i < indexedNodeCount; i++) {
              const node = nodes[i];
              if (node instanceof nodes_1.DirectiveNode) {
                if (node.index >= lastIndexedNode.index) {
                  break;
                }
                const nodeDirectiveName = node.name;
                if (node.isClosingDirective == false && nodeDirectiveName == directiveName) {
                  if (this.openDirectiveIndexCount.has(this.stackCount) == false) {
                    this.openDirectiveIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
                  }
                  if (((_a3 = this.openDirectiveIndexCount.get(this.stackCount)) === null || _a3 === void 0 ? void 0 : _a3.has(directiveName)) == false) {
                    (_b2 = this.openDirectiveIndexCount.get(this.stackCount)) === null || _b2 === void 0 ? void 0 : _b2.set(directiveName, 0);
                  }
                  const curCount = (_d = (_c2 = this.openDirectiveIndexCount.get(this.stackCount)) === null || _c2 === void 0 ? void 0 : _c2.get(directiveName)) !== null && _d !== void 0 ? _d : 0;
                  (_e = this.openDirectiveIndexCount.get(this.stackCount)) === null || _e === void 0 ? void 0 : _e.set(directiveName, curCount + 1);
                }
              }
            }
          });
        }
      }
      getClosingCandidates(node) {
        const candidates = [];
        candidates.push(node.name);
        return candidates;
      }
      getScanForList(node) {
        if (node.isClosingDirective == false) {
          const candidates = this.getClosingCandidates(node), indexValues = this.closingDirectiveNames.get(this.stackCount);
          return (0, arrayHelpers_1.intersect)(candidates, indexValues);
        }
        return [];
      }
      associate(documentNodes, document, refParent = null) {
        var _a2;
        this.document = document;
        let nodesToReturn = [];
        const nodeStack = [{
          documentNodes,
          parent: refParent
        }];
        while (nodeStack.length > 0) {
          const details = nodeStack.pop();
          if (details == null) {
            continue;
          }
          let nodes = details.documentNodes;
          this.parentNode = details.parent;
          this.stackCount += 1;
          this.buildCloseIndex(nodes);
          nodes = conditionPairAnalyzer_1.ConditionPairAnalyzer.pairConditionals(nodes);
          nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode && pairManager_1.PairManager.canClose(node)) {
              if (conditionPairAnalyzer_1.ConditionPairAnalyzer.isConditionalStructure(node)) {
                return;
              }
              const scanFor = this.getScanForList(node);
              this.findClosingPair(nodes, node, scanFor);
            }
          });
          const nodeCount = nodes.length;
          for (let i = 0; i < nodeCount; i++) {
            const node = nodes[i];
            if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
              for (let j = i + 1; j < nodeCount; j++) {
                const childNode = nodes[j];
                if (childNode.index > node.isClosedBy.index) {
                  break;
                }
                childNode.parent = node;
                node.children.push(childNode);
                if (childNode instanceof nodes_1.DirectiveNode && childNode.index == node.index) {
                  childNode.parent = node;
                  break;
                }
              }
            }
          }
          nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode && node.children.length > 0) {
              const newChildren = [], refIds = [];
              node.children.forEach((childNode) => {
                if (childNode.parent != null) {
                  if (childNode.parent.index == node.index) {
                    const refId = childNode.refId;
                    if (!refIds.includes(refId)) {
                      childNode.parent = node;
                      newChildren.push(childNode);
                      refIds.push(refId);
                    } else {
                      return;
                    }
                  }
                }
              });
              nodeStack.push({
                documentNodes: newChildren,
                parent: node
              });
            }
          });
          let nestedNodes = [];
          nodes.forEach((node) => {
            var _a3;
            if (this.parentNode == null) {
              if (node.parent == null) {
                nestedNodes.push(node);
              }
            } else {
              if (((_a3 = node.parent) === null || _a3 === void 0 ? void 0 : _a3.refId) == this.parentNode.refId) {
                nestedNodes.push(node);
              }
            }
          });
          nestedNodes = this.reduceConditions(nestedNodes, document);
          nestedNodes = switchPairAnalyzer_1.SwitchPairAnalyzer.associate(nestedNodes, document);
          nestedNodes = forElsePairAnalyzer_1.ForElsePairAnalyzer.associate(nestedNodes, document);
          nestedNodes = speculativeConditionAnalyzer_1.SpeculativeConditionAnalyzer.analyze(nestedNodes, document);
          nestedNodes = this.cleanNodes(nestedNodes);
          const nestedNodeKeyMap = /* @__PURE__ */ new Map();
          nodes.forEach((node) => {
            var _a3, _b, _c, _d;
            if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
              if (this.document != null) {
                const content = this.document.getText((_b = (_a3 = node.endPosition) === null || _a3 === void 0 ? void 0 : _a3.index) !== null && _b !== void 0 ? _b : 0, ((_d = (_c = node.isClosedBy.startPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) - 1);
                node.documentContent = content;
                if (node.name == "php" || node.name == "verbatim") {
                  if (node.innerContent.trim().length == 0) {
                    node.innerContent = node.documentContent;
                  }
                }
              }
            }
          });
          for (let i = 0; i < nestedNodes.length; i++) {
            const node = nestedNodes[i], refId = (_a2 = node.refId) !== null && _a2 !== void 0 ? _a2 : "";
            nestedNodeKeyMap.set(refId, 1);
          }
          if (this.parentNode != null && this.parentNode instanceof nodes_1.DirectiveNode) {
            this.parentNode.children = this.cleanNodes(nestedNodes);
            if (this.parentNode.parent != null && this.parentNode.parent instanceof nodes_1.DirectiveNode) {
              const ancestorNodes = this.parentNode.parent.children, newAncestorNodes = [];
              ancestorNodes.forEach((aNode) => {
                var _a3;
                if (nestedNodeKeyMap.has((_a3 = aNode.refId) !== null && _a3 !== void 0 ? _a3 : "") == false) {
                  newAncestorNodes.push(aNode);
                }
              });
              this.parentNode.parent.children = this.cleanNodes(newAncestorNodes);
            }
          }
          if (this.stackCount <= 1) {
            nodesToReturn = this.cleanNodes(nestedNodes);
          }
        }
        return nodesToReturn;
      }
      cleanNodes(nodes) {
        const cleaned = [], ids = [];
        for (let i = 0; i < nodes.length; i++) {
          const child = nodes[i], refId = child.refId;
          if (ids.includes(refId)) {
            break;
          }
          cleaned.push(child);
          ids.push(refId);
        }
        return cleaned;
      }
      reduceConditions(nodes, document) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        const reduced = [];
        for (let i = 0; i < nodes.length; i++) {
          let node = nodes[i];
          if (node instanceof nodes_1.DirectiveNode && node.isClosingDirective == false && node.isClosedBy != null) {
            const compound = node.name;
            if (compound == bladeKeywords_1.BladeKeywords.If) {
              const conditionNode = new nodes_1.ConditionNode(), finalClosing = node.getFinalClosingDirective();
              conditionNode.withParser(document);
              conditionNode.index = node.index;
              conditionNode.chain.push(node.index);
              conditionNode.startPosition = node.startPosition;
              conditionNode.endPosition = finalClosing.endPosition;
              conditionNode.constructedFrom = node;
              const startOffset = ((_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0) - 1, length = (_d = (_c = finalClosing === null || finalClosing === void 0 ? void 0 : finalClosing.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0 - ((_f = (_e = node.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0), endOffset = startOffset + length;
              conditionNode.nodeContent = document.getText(startOffset, length);
              conditionNode.offset = {
                start: startOffset,
                end: endOffset,
                length
              };
              if (this.parentNode != null) {
                conditionNode.parent = this.parentNode;
              }
              let exitedOn = null, doContinue = true, currentDepth = 0;
              while (doContinue) {
                currentDepth += 1;
                if (currentDepth > DirectivePairAnalyzer.ForceBreakLimit) {
                  doContinue = false;
                  break;
                }
                if (node instanceof nodes_1.DirectiveNode) {
                  const result = this.findEndOfBranch(nodes.slice(i + 1), node, i), executionBranch = new nodes_1.ExecutionBranchNode();
                  executionBranch.withParser(document);
                  let tail = result.tail;
                  executionBranch.head = node;
                  executionBranch.tail = tail;
                  executionBranch.nodes = this.cleanNodes(node.children);
                  const childDocNodes = [...executionBranch.nodes], lastNode = childDocNodes[childDocNodes.length - 1];
                  if (lastNode instanceof nodes_1.DirectiveNode && lastNode.refId == ((_g = node.isClosedBy) === null || _g === void 0 ? void 0 : _g.refId)) {
                    childDocNodes.pop();
                  }
                  const branchStart = (_j = (_h = node.endPosition) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0, branchEnd = ((_m = (_l = (_k = node.isClosedBy) === null || _k === void 0 ? void 0 : _k.startPosition) === null || _l === void 0 ? void 0 : _l.index) !== null && _m !== void 0 ? _m : 0) - 1, length2 = branchEnd - branchStart, branchDocStart = ((_p = (_o = node.startPosition) === null || _o === void 0 ? void 0 : _o.index) !== null && _p !== void 0 ? _p : 0) - 1, branchDocEnd = ((_s = (_r = (_q = node.isClosedBy) === null || _q === void 0 ? void 0 : _q.startPosition) === null || _r === void 0 ? void 0 : _r.index) !== null && _s !== void 0 ? _s : 0) - 1, branchDocLength = branchDocEnd - branchDocStart;
                  executionBranch.innerContent = document.getText(branchStart, branchEnd);
                  executionBranch.documentContent = document.getText(branchDocStart, branchDocEnd);
                  executionBranch.innerOffset = {
                    start: branchStart,
                    end: branchEnd,
                    length: length2
                  };
                  executionBranch.offset = {
                    start: branchDocStart,
                    end: branchDocEnd,
                    length: branchDocLength
                  };
                  executionBranch.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(childDocNodes), document, (0, helpers_1.getStartPosition)(childDocNodes));
                  if (tail == null) {
                    tail = executionBranch.head.isClosedBy;
                  }
                  if (tail != null && tail.startPosition != null) {
                    executionBranch.startPosition = tail.startPosition;
                  }
                  if (tail != null) {
                    executionBranch.index = tail.index;
                  }
                  if (executionBranch.nodes.length > 0) {
                    const lastNode2 = executionBranch.nodes[executionBranch.nodes.length - 1];
                    if (lastNode2.endPosition != null) {
                      executionBranch.endPosition = lastNode2.endPosition;
                    }
                  } else {
                    if (tail != null && tail.endPosition != null) {
                      executionBranch.endPosition = tail.endPosition;
                    }
                  }
                  this.createdExecutionBranches.push(executionBranch);
                  conditionNode.logicBranches.push(executionBranch);
                  if ((tail === null || tail === void 0 ? void 0 : tail.isClosingDirective) && tail.name == bladeKeywords_1.BladeKeywords.If) {
                    exitedOn = result.offset;
                    doContinue = false;
                    break;
                  } else {
                    if (tail != null) {
                      conditionNode.chain.push(tail.index);
                    }
                    i = result.offset;
                    if (tail instanceof nodes_1.DirectiveNode) {
                      node = tail;
                    }
                  }
                } else {
                  doContinue = false;
                }
              }
              reduced.push(conditionNode);
              if (exitedOn != null) {
                if (exitedOn == nodes.length) {
                  break;
                }
              }
            } else {
              reduced.push(node);
            }
          } else {
            reduced.push(node);
          }
        }
        return reduced;
      }
      findEndOfBranch(nodes, start, startedAt) {
        const children = [], offset = startedAt;
        let tail = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node instanceof nodes_1.DirectiveNode && node.isOpenedBy != null && node.isOpenedBy == start) {
            tail = node;
            break;
          } else {
            children.push(node);
          }
        }
        return {
          children,
          tail,
          offset
        };
      }
      findClosingPair(nodes, node, scanFor) {
        const nodeLength = nodes.length;
        let refStack = 0;
        for (let i = 0; i < nodeLength; i++) {
          const candidateNode = nodes[i];
          if (candidateNode instanceof nodes_1.DirectiveNode == false) {
            continue;
          }
          if (candidateNode.startPosition == null || node.endPosition == null) {
            continue;
          }
          if (!node.endPosition.isBefore(candidateNode.startPosition)) {
            continue;
          }
          const directiveCandidate = candidateNode;
          if (directiveCandidate.isClosingDirective && directiveCandidate.isOpenedBy != null) {
            continue;
          }
          if (!directiveCandidate.isClosingDirective && directiveCandidate.isClosedBy != null) {
            continue;
          }
          const directiveName = directiveCandidate.name;
          if (!directiveCandidate.isClosingDirective) {
            if (scanFor.includes(directiveName)) {
              refStack += 1;
              continue;
            }
          }
          if (scanFor.includes(directiveName)) {
            if (refStack > 0) {
              refStack -= 1;
              continue;
            }
          }
          if (refStack == 0 && scanFor.includes(directiveName)) {
            directiveCandidate.isOpenedBy = node;
            node.isClosedBy = directiveCandidate;
            break;
          }
        }
      }
    };
    exports.DirectivePairAnalyzer = DirectivePairAnalyzer;
    DirectivePairAnalyzer.ForceBreakLimit = 1e5;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/directiveStack.js
var require_directiveStack = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/directiveStack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectiveStack = void 0;
    var nodes_1 = require_nodes();
    var DirectiveStack = class {
      static setChildTypeCounts(nodes) {
        nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode == false) {
            return;
          }
          const directive = node;
          directive.getImmediateChildren().forEach((child) => {
            let childType = "*unknown", parentIndex = 0;
            if (child instanceof nodes_1.LiteralNode) {
              childType = "*literal";
            } else if (child instanceof nodes_1.BladeEntitiesEchoNode) {
              childType = "*entities_echo";
            } else if (child instanceof nodes_1.BladeEscapedEchoNode) {
              childType = "*escaped_echo";
            } else if (child instanceof nodes_1.BladeEchoNode) {
              childType = "*echo";
            } else if (child instanceof nodes_1.BladeVerbatimNode) {
              childType = "*verbatim";
            } else if (child instanceof nodes_1.DirectiveNode) {
              childType = child.directiveName;
            }
            if (directive.childTypeCounts.has(childType) == false) {
              directive.childTypeCounts.set(childType, 0);
            }
            const curCount = directive.childTypeCounts.get(childType), relativeCount = curCount + 1;
            directive.childTypeCounts.set(childType, relativeCount);
            child.parentTypeIndex = relativeCount;
            child.parentIndex = parentIndex;
            parentIndex += 1;
          });
        });
      }
    };
    exports.DirectiveStack = DirectiveStack;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/fragmentPositionAnalyzer.js
var require_fragmentPositionAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/fragmentPositionAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FragmentPositionAnalyzer = void 0;
    var nodes_1 = require_nodes();
    var FragmentPositionAnalyzer = class {
      constructor(document, fragments) {
        this.documentParser = document;
        this.fragmentsParser = fragments;
      }
      doesContainFragments(directive) {
        var _a2, _b, _c, _d, _e;
        const startIndex = (_b = (_a2 = directive.endPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0, endIndex = (_e = (_d = (_c = directive.isClosedBy) === null || _c === void 0 ? void 0 : _c.startPosition) === null || _d === void 0 ? void 0 : _d.index) !== null && _e !== void 0 ? _e : 0;
        return this.fragmentsParser.getFragmentsBetween(startIndex, endIndex).length > 0;
      }
      analyze() {
        const allNodes = this.documentParser.getNodes();
        if (!this.fragmentsParser.hasFragments()) {
          return;
        }
        this.fragmentsParser.getFragments().forEach((fragment) => {
          const lowerName = fragment.name.toLowerCase();
          if (fragment.isClosingFragment == false && fragment.isSelfClosing == false && (lowerName == "script" || lowerName == "style")) {
            const closingFragment = this.fragmentsParser.getClosingFragmentAfter(fragment);
            if (closingFragment == null) {
              return;
            }
            if (fragment.endPosition != null && closingFragment.startPosition != null) {
              const containedNodes = this.documentParser.getNodesBetween(fragment.endPosition, closingFragment.startPosition);
              containedNodes.forEach((node) => {
                if (node instanceof nodes_1.ConditionNode || node instanceof nodes_1.ForElseNode || node instanceof nodes_1.BladeComponentNode || node instanceof nodes_1.SwitchStatementNode) {
                  fragment.containsStructures = true;
                } else if (node instanceof nodes_1.DirectiveNode) {
                  if (node.isClosedBy != null) {
                    fragment.containsStructures = true;
                  }
                }
                if (lowerName == "style") {
                  node.isInStyleTag = true;
                } else {
                  node.isInScriptTag = true;
                }
              });
            }
          }
        });
        allNodes.forEach((node) => {
          var _a2, _b, _c, _d, _e, _f;
          if (node instanceof nodes_1.LiteralNode) {
            return;
          }
          if (node.startPosition == null) {
            return;
          }
          if (node instanceof nodes_1.DirectiveNode && !node.isClosingDirective && node.isClosedBy != null) {
            node.containsAnyFragments = this.doesContainFragments(node);
          }
          const fragment = this.fragmentsParser.getFragmentContaining(node.startPosition);
          if (fragment == null) {
            return;
          }
          node.fragment = fragment;
          const startDelta = node.startPosition.index - ((_b = (_a2 = fragment.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0);
          if (startDelta <= 3) {
            node.fragmentPosition = nodes_1.FragmentPosition.IsDynamicFragmentName;
            return;
          }
          if (fragment.parameters.length == 0) {
            node.fragmentPosition = nodes_1.FragmentPosition.InsideFragment;
            return;
          }
          let resolvedParam = false;
          for (let i = 0; i < fragment.parameters.length; i++) {
            const thisParam = fragment.parameters[i];
            if (((_d = (_c = thisParam.startPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) < node.startPosition.index && ((_f = (_e = thisParam.endPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0) > node.startPosition.index) {
              node.fragmentPosition = nodes_1.FragmentPosition.InsideFragmentParameter;
              resolvedParam = true;
              break;
            }
          }
          if (!resolvedParam) {
            node.fragmentPosition = nodes_1.FragmentPosition.InsideFragment;
          }
        });
      }
    };
    exports.FragmentPositionAnalyzer = FragmentPositionAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/inlineEchoAnalyzer.js
var require_inlineEchoAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/inlineEchoAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineEchoAnalyzer = void 0;
    var nodes_1 = require_nodes();
    var stringUtilities_1 = require_stringUtilities();
    var InlineEchoAnalyzer = class {
      static analyze(nodes) {
        nodes.forEach((node) => {
          if (node instanceof nodes_1.BladeEchoNode) {
            let isRightInline = false, isLeftInline = false;
            if (node.nextNode == null) {
              isRightInline = true;
            } else if (node.nextNode instanceof nodes_1.LiteralNode) {
              const firstLine = stringUtilities_1.StringUtilities.getFirstLine(node.nextNode.content);
              if (stringUtilities_1.StringUtilities.trimLeft(firstLine, " 	").startsWith("\n") == false && firstLine.trim().length > 0) {
                isRightInline = true;
              }
            }
            if (node.prevNode == null) {
              isLeftInline = true;
            } else if (node.prevNode instanceof nodes_1.LiteralNode) {
              const lastLine = stringUtilities_1.StringUtilities.getLastLine(node.prevNode.content);
              if (stringUtilities_1.StringUtilities.trimRight(lastLine, " 	").endsWith("\n") == false && lastLine.trim().length > 0) {
                isLeftInline = true;
              }
            }
            node.isInlineEcho = isRightInline && isLeftInline;
          }
        });
      }
    };
    exports.InlineEchoAnalyzer = InlineEchoAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/analyzers/inlinePhpAnalyzer.js
var require_inlinePhpAnalyzer = __commonJS({
  "node_modules/stillat-blade-parser/out/analyzers/inlinePhpAnalyzer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlinePhpAnalyzer = void 0;
    var nodes_1 = require_nodes();
    var stringUtilities_1 = require_stringUtilities();
    var InlinePhpAnalyzer = class {
      static analyze(nodes) {
        nodes.forEach((node) => {
          var _a2, _b;
          if (node instanceof nodes_1.InlinePhpNode) {
            if (((_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.line) != ((_b = node.endPosition) === null || _b === void 0 ? void 0 : _b.line)) {
              return;
            }
            let isRightInline = false, isLeftInline = false;
            if (node.nextNode == null) {
              isRightInline = true;
            } else if (node.nextNode instanceof nodes_1.LiteralNode) {
              const firstLine = stringUtilities_1.StringUtilities.getFirstLine(node.nextNode.content);
              if (stringUtilities_1.StringUtilities.trimLeft(firstLine, " 	").startsWith("\n") == false && firstLine.trim().length > 0) {
                isRightInline = true;
              }
            }
            if (node.prevNode == null) {
              isLeftInline = true;
            } else if (node.prevNode instanceof nodes_1.LiteralNode) {
              const lastLine = stringUtilities_1.StringUtilities.getLastLine(node.prevNode.content);
              if (stringUtilities_1.StringUtilities.trimRight(lastLine, " 	").endsWith("\n") == false && lastLine.trim().length > 0) {
                isLeftInline = true;
              }
            }
            node.isInline = isRightInline && isLeftInline;
          }
        });
      }
    };
    exports.InlinePhpAnalyzer = InlinePhpAnalyzer;
  }
});

// node_modules/stillat-blade-parser/out/document/scanners/wordScanner.js
var require_wordScanner = __commonJS({
  "node_modules/stillat-blade-parser/out/document/scanners/wordScanner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WordScanner = void 0;
    var documentParser_1 = require_documentParser();
    var stringUtilities_1 = require_stringUtilities();
    var WordScanner = class {
      static findRightBeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
            okayToBreak = true;
          }
          if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
            return null;
          }
          if (stringUtilities_1.StringUtilities.ctypePunct(cur) || cur == documentParser_1.DocumentParser.String_Terminator_SingleQuote || cur == documentParser_1.DocumentParser.String_Terminator_DoubleQuote) {
            return cur;
          }
        }
        return null;
      }
      static findRightNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypeSpace(cur) || stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore) {
            okayToBreak = true;
          }
          if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
            return i + 1;
          }
        }
        return null;
      }
      static findLeftNeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 2; i >= 0; i--) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
            okayToBreak = true;
          }
          if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
            return null;
          }
          if (stringUtilities_1.StringUtilities.ctypePunct(cur)) {
            return cur;
          }
        }
        return null;
      }
      static findLeftNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 1; i >= 0; i--) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypeSpace(cur) || stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore) {
            okayToBreak = true;
          }
          if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
            return i + 1;
          }
        }
        return null;
      }
      static scanWordAt(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        if (index < 0 || index > text.length) {
          return null;
        }
        const leftChars = [], rightChars = [];
        for (let i = index - 1; i >= 0; i--) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore || stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
            break;
          }
          leftChars.push(cur);
        }
        for (let i = index; i < text.length; i++) {
          const cur = text[i];
          if (stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore || stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
            break;
          }
          rightChars.push(cur);
        }
        return leftChars.reverse().join("") + rightChars.join("");
      }
    };
    exports.WordScanner = WordScanner;
  }
});

// node_modules/stillat-blade-parser/out/nodes/position.js
var require_position = __commonJS({
  "node_modules/stillat-blade-parser/out/nodes/position.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Position = void 0;
    var Position13 = class {
      constructor() {
        this.index = -1;
        this.offset = 0;
        this.line = 0;
        this.char = 0;
      }
      shiftRight(shiftOffset) {
        const position = new Position13();
        position.offset = this.offset + shiftOffset;
        position.index = this.index + shiftOffset;
        position.line = this.line;
        position.char = this.char + shiftOffset;
        return position;
      }
      isBefore(position) {
        if (position == null) {
          return false;
        }
        if (position.line > this.line) {
          return true;
        }
        if (position.line == this.line && this.offset < position.offset) {
          return true;
        }
        return false;
      }
      isWithin(start, end, shiftEnd = 0) {
        if (start == null || end == null) {
          return false;
        }
        if (this.index >= start.index && this.index <= end.index + shiftEnd) {
          return true;
        }
        return false;
      }
      isWithinRange(range) {
        if (range == null) {
          return false;
        }
        if (range.start != null && range.end != null) {
          return this.isWithin(range.start, range.end);
        }
        return false;
      }
    };
    exports.Position = Position13;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/isStartOfString.js
var require_isStartOfString = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/isStartOfString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStartOfString = void 0;
    function isStartOfString(char) {
      if (char == null) {
        return false;
      }
      if (char == '"' || char == "'") {
        return true;
      }
      return false;
    }
    exports.isStartOfString = isStartOfString;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/nextNonWhitespace.js
var require_nextNonWhitespace = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/nextNonWhitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextNonWhitespace = void 0;
    var stringUtilities_1 = require_stringUtilities();
    function nextNonWhitespace(iterator) {
      for (let i = iterator.getCurrentIndex() + 1; i < iterator.inputLength(); i++) {
        const cur = iterator.getChar(i);
        if (!stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
          return {
            didFind: true,
            index: i,
            char: cur
          };
        }
      }
      return {
        didFind: false,
        index: null,
        char: ""
      };
    }
    exports.nextNonWhitespace = nextNonWhitespace;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfLine.js
var require_skipToEndOfLine = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfLine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipToEndOfLine = void 0;
    var documentParser_1 = require_documentParser();
    function skipToEndOfLine(iterator, collect) {
      for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if (collect) {
          iterator.pushChar(iterator.getCurrent());
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.NewLine) {
          break;
        }
      }
    }
    exports.skipToEndOfLine = skipToEndOfLine;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfMultilineComment.js
var require_skipToEndOfMultilineComment = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfMultilineComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipToEndOfMultilineComment = void 0;
    var documentParser_1 = require_documentParser();
    function skipToEndOfMultilineComment(iterator, collect) {
      for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if (collect) {
          iterator.pushChar(iterator.getCurrent());
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.Punctuation_Asterisk && iterator.getNext() == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
          if (collect) {
            iterator.pushChar(documentParser_1.DocumentParser.Punctuation_ForwardSlash);
          }
          iterator.incrementIndex();
          iterator.checkCurrentOffsets();
          break;
        }
      }
    }
    exports.skipToEndOfMultilineComment = skipToEndOfMultilineComment;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfString.js
var require_skipToEndOfString = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/skipToEndOfString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipToEndOfStringTraced = exports.skipToEndOfString = void 0;
    var documentParser_1 = require_documentParser();
    function skipToEndOfString(iterator) {
      const stringInitializer = iterator.getCurrent();
      iterator.incrementIndex();
      for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if (iterator.getCurrent() == stringInitializer && iterator.getPrev() != documentParser_1.DocumentParser.String_EscapeCharacter) {
          break;
        }
      }
    }
    exports.skipToEndOfString = skipToEndOfString;
    function skipToEndOfStringTraced(iterator) {
      const stringInitializer = iterator.getCurrent(), stringContent = [];
      iterator.incrementIndex();
      for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if (iterator.getCurrent() == stringInitializer && iterator.getPrev() != documentParser_1.DocumentParser.String_EscapeCharacter) {
          break;
        }
        stringContent.push(iterator.getCurrent());
      }
      return {
        value: stringContent.join(""),
        endedOn: iterator.getCurrentIndex()
      };
    }
    exports.skipToEndOfStringTraced = skipToEndOfStringTraced;
  }
});

// node_modules/stillat-blade-parser/out/parser/scanners/scanToEndOfLogicGroup.js
var require_scanToEndOfLogicGroup = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/scanners/scanToEndOfLogicGroup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanToEndOfLogicGroup = void 0;
    var documentParser_1 = require_documentParser();
    var isStartOfString_1 = require_isStartOfString();
    var skipToEndOfLine_1 = require_skipToEndOfLine();
    var skipToEndOfMultilineComment_1 = require_skipToEndOfMultilineComment();
    var skipToEndOfString_1 = require_skipToEndOfString();
    function scanToEndOfLogicGroup(iterator) {
      const groupStartedOn = iterator.getCurrentIndex() + iterator.getSeedOffset();
      let groupEndsOn = 0, groupOpenCount = 0;
      iterator.incrementIndex();
      for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if ((0, isStartOfString_1.isStartOfString)(iterator.getCurrent())) {
          (0, skipToEndOfString_1.skipToEndOfString)(iterator);
          continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.Punctuation_ForwardSlash && iterator.getNext() == documentParser_1.DocumentParser.Punctuation_Asterisk) {
          (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(iterator, false);
          continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.Punctuation_ForwardSlash && iterator.getNext() == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
          (0, skipToEndOfLine_1.skipToEndOfLine)(iterator, false);
          continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.LeftParen) {
          groupOpenCount += 1;
          continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.RightParen) {
          if (groupOpenCount > 0) {
            groupOpenCount -= 1;
            continue;
          }
          groupEndsOn = iterator.getCurrentIndex() + iterator.getSeedOffset() + 1;
          break;
        }
        if (iterator.getCurrent() == null) {
          break;
        }
      }
      const groupContent = iterator.getContentSubstring(groupStartedOn, groupEndsOn - groupStartedOn);
      return {
        start: groupStartedOn,
        end: groupEndsOn,
        content: groupContent
      };
    }
    exports.scanToEndOfLogicGroup = scanToEndOfLogicGroup;
  }
});

// node_modules/stillat-blade-parser/out/parser/componentParser.js
var require_componentParser = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/componentParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComponentParser = void 0;
    var nodes_1 = require_nodes();
    var stringUtilities_1 = require_stringUtilities();
    var documentParser_1 = require_documentParser();
    var isStartOfString_1 = require_isStartOfString();
    var nextNonWhitespace_1 = require_nextNonWhitespace();
    var scanToEndOfLogicGroup_1 = require_scanToEndOfLogicGroup();
    var skipToEndOfLine_1 = require_skipToEndOfLine();
    var skipToEndOfMultilineComment_1 = require_skipToEndOfMultilineComment();
    var skipToEndOfString_1 = require_skipToEndOfString();
    var ComponentParser = class {
      constructor(document) {
        this.content = "";
        this.inputLen = 0;
        this.chars = [];
        this.currentContent = [];
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.currentIndex = 0;
        this.hasFoundName = false;
        this.nameStartsOn = 0;
        this.nameEndsOn = -1;
        this.name = "";
        this.parameterContent = "";
        this.activeComponent = null;
        this.document = document;
      }
      pushChar(value) {
        this.currentContent.push(value);
      }
      updateIndex(index) {
        this.currentIndex = index;
      }
      inputLength() {
        return this.inputLen;
      }
      incrementIndex() {
        this.currentIndex += 1;
      }
      getCurrentIndex() {
        return this.currentIndex;
      }
      getCurrent() {
        return this.cur;
      }
      getNext() {
        return this.next;
      }
      getPrev() {
        return this.prev;
      }
      getChar(index) {
        return this.chars[index];
      }
      getSeedOffset() {
        return 0;
      }
      getContentSubstring(from, length) {
        return this.content.substr(from, length);
      }
      resetState() {
        this.name = "";
        this.parameterContent = "";
        this.hasFoundName = false;
        this.nameStartsOn = 0;
        this.nameEndsOn = -1;
        this.currentIndex = 0;
        this.content = "";
        this.chars = [];
        this.currentContent = [];
        this.inputLen = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        return this;
      }
      checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          this.next = this.chars[this.currentIndex + 1];
        }
      }
      makeDirective(name, nameStartsOn, nameEndsOn) {
        const directive = new nodes_1.DirectiveNode(), componentOffset = this.getComponentOffset();
        directive.withParser(this.document);
        if (name.startsWith("@")) {
          name = name.substring(1);
        }
        directive.directiveName = name.trim();
        directive.name = name.trim();
        if (name.startsWith("end")) {
          directive.name = name.substring(3);
        } else if (name.startsWith("else") && name != "elseif" && name != "else") {
          directive.name = "elseif";
        }
        const nameStartPosition = this.document.positionFromOffset(componentOffset + nameStartsOn, componentOffset + nameStartsOn), nameEndPosition = this.document.positionFromOffset(componentOffset + nameEndsOn, componentOffset + nameEndsOn);
        directive.startPosition = nameStartPosition;
        directive.endPosition = nameEndPosition;
        directive.namePosition = {
          start: nameStartPosition,
          end: nameEndPosition
        };
        directive.hasDirectiveParameters = false;
        if (directive.startPosition != null && directive.endPosition != null) {
          const startOffset = directive.startPosition.index, length = directive.endPosition.index - directive.startPosition.index, endOffset = startOffset + length;
          directive.sourceContent = this.document.getContentSubstring(startOffset, length);
          directive.offset = {
            start: startOffset,
            end: endOffset,
            length
          };
        }
        return directive;
      }
      getComponentOffset() {
        var _a2, _b, _c;
        return ((_c = (_b = (_a2 = this.activeComponent) === null || _a2 === void 0 ? void 0 : _a2.startPosition) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : 0) + 3;
      }
      makeDirectiveWithParameters(name, nameStartsOn, nameEndsOn, params) {
        var _a2, _b;
        const directive = this.makeDirective(name, nameStartsOn, nameEndsOn), componentOffset = this.getComponentOffset();
        directive.hasDirectiveParameters = true;
        directive.directiveParameters = params.content;
        let checkParams = params.content.trim();
        if (checkParams.startsWith("(") && checkParams.endsWith(")")) {
          checkParams = checkParams.substring(1);
          checkParams = checkParams.substring(0, checkParams.length - 1);
          checkParams = checkParams.trim();
          directive.hasJsonParameters = checkParams.startsWith("{") && checkParams.endsWith("}");
        }
        const directiveParamtersStartPosition = this.document.positionFromOffset(params.start + componentOffset, params.start + componentOffset), directiveParametersEndPosition = this.document.positionFromOffset(params.end + componentOffset, params.end + componentOffset);
        directive.startPosition = (_b = (_a2 = directive.namePosition) === null || _a2 === void 0 ? void 0 : _a2.start) !== null && _b !== void 0 ? _b : null;
        directive.endPosition = directiveParametersEndPosition;
        directive.directiveParametersPosition = {
          start: directiveParamtersStartPosition,
          end: directiveParametersEndPosition
        };
        if (directive.startPosition != null && directive.endPosition != null) {
          const startOffset = directive.startPosition.index, length = directive.endPosition.index - directive.startPosition.index, endOffset = startOffset + length;
          directive.sourceContent = this.document.getContentSubstring(startOffset, length);
          directive.offset = {
            start: startOffset,
            end: endOffset,
            length
          };
        }
        return directive;
      }
      prepare(content) {
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(content);
        this.chars = this.content.split("");
        this.inputLen = this.chars.length;
        return this;
      }
      scanToEndOfDirective() {
        const directiveNameStartsOn = this.currentIndex, directiveBrokeForNewline = false;
        let directiveName = "", directiveNameEndsOn = 0;
        let directive = null;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_Asterisk) {
            (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
            (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.NewLine) {
            directiveNameEndsOn = this.currentIndex;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
            break;
          } else if (this.next == null) {
            this.currentContent.push(this.cur);
            directiveNameEndsOn = this.currentIndex + 1;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
            break;
          }
          const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
          if (this.cur != documentParser_1.DocumentParser.LeftParen && nextNonWs.didFind && stringUtilities_1.StringUtilities.ctypePunct(nextNonWs.char)) {
            if (nextNonWs.char != documentParser_1.DocumentParser.LeftParen && nextNonWs.char != documentParser_1.DocumentParser.Punctuation_Minus) {
              this.currentContent.push(this.cur);
              directiveNameEndsOn = this.currentIndex + 1;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
              break;
            }
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
            const nextNonWs2 = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
            if (nextNonWs2.didFind && nextNonWs2.char == documentParser_1.DocumentParser.LeftParen) {
              directiveNameEndsOn = this.currentIndex - 1;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              this.currentIndex = nextNonWs2.index;
              this.checkCurrentOffsets();
              const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
              directive = this.makeDirectiveWithParameters(directiveName, directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
              break;
            } else {
              directiveNameEndsOn = this.currentIndex;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
              break;
            }
          } else if (this.cur == documentParser_1.DocumentParser.LeftParen) {
            directiveNameEndsOn = this.currentIndex - 1;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
            directive = this.makeDirectiveWithParameters(directiveName, directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
        return directive;
      }
      nextPunctuation() {
        for (let i = this.currentIndex + 1; i < this.inputLen; i++) {
          const char = this.chars[i];
          if (stringUtilities_1.StringUtilities.ctypePunct(char)) {
            return char;
          }
        }
        return null;
      }
      scanToEndOfBladeEcho(startedOn) {
        const componentOffset = this.getComponentOffset(), echoNode = new nodes_1.BladeEchoNode();
        this.currentContent.unshift();
        this.currentContent.unshift();
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == documentParser_1.DocumentParser.RightBrace && this.next == documentParser_1.DocumentParser.RightBrace) {
            const echoEnd = this.currentIndex + 1;
            echoNode.startPosition = this.document.positionFromOffset(startedOn + componentOffset, startedOn + componentOffset);
            echoNode.endPosition = this.document.positionFromOffset(echoEnd + componentOffset, echoEnd + componentOffset);
            echoNode.withParser(this.document);
            const startOffset = echoNode.startPosition.index - 5, length = echoNode.endPosition.index - echoNode.startPosition.index + 3, endOffset = startOffset + length;
            echoNode.sourceContent = this.content.substr(startOffset, length);
            echoNode.offset = {
              start: startOffset,
              end: endOffset,
              length
            };
            echoNode.content = this.currentContent.join("");
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
        return echoNode;
      }
      parse(node) {
        var _a2;
        this.resetState().prepare(node.innerContent);
        this.activeComponent = node;
        const parser = node.getParser();
        let isParsingParameter = false, parameterStartedOn = -1, parameterNameEndedOn = -1, parameterValueStartedOn = -1, terminatorStyle = '"';
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.hasFoundName && this.cur == documentParser_1.DocumentParser.LeftBrace && this.next == documentParser_1.DocumentParser.LeftBrace) {
            this.currentIndex += 2;
            const echoNode = this.scanToEndOfBladeEcho(this.currentIndex);
            if (echoNode != null) {
              const param = new nodes_1.ParameterNode();
              param.type = nodes_1.ParameterType.Directive;
              param.startPosition = echoNode.startPosition;
              param.endPosition = echoNode.endPosition;
              param.inlineEcho = echoNode;
              param.type = nodes_1.ParameterType.InlineEcho;
              node.hasParameters = true;
              node.parameters.push(param);
              this.currentContent = [];
              this.currentIndex += 1;
              continue;
            }
          }
          if (this.hasFoundName && this.cur == documentParser_1.DocumentParser.AtChar && this.currentContent.length == 0 && this.nextPunctuation() != documentParser_1.DocumentParser.Punctuation_Equals) {
            const directive = this.scanToEndOfDirective();
            if (directive != null) {
              const param = new nodes_1.ParameterNode();
              param.type = nodes_1.ParameterType.Directive;
              param.startPosition = directive.startPosition;
              param.endPosition = directive.endPosition;
              param.name = directive.directiveName;
              param.directive = directive;
              node.hasParameters = true;
              node.parameters.push(param);
              continue;
            }
          }
          if (!this.hasFoundName) {
            if ((stringUtilities_1.StringUtilities.ctypeSpace(this.cur) || this.next == null) && this.hasFoundName == false) {
              if (this.next == null && !stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                this.currentContent.push(this.cur);
              }
              this.name = this.currentContent.join("");
              this.nameEndsOn = this.currentIndex - 1;
              this.hasFoundName = true;
              this.currentContent = [];
              this.parameterContent = this.chars.slice(this.currentIndex).join("");
              continue;
            }
          } else {
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) || this.next == null) {
              if (this.currentContent.length > 0) {
                const param = new nodes_1.ParameterNode(), componentOffset = this.getComponentOffset();
                param.type = nodes_1.ParameterType.Attribute;
                if (this.next == null && !stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                  this.currentContent.push(this.cur);
                }
                param.name = this.currentContent.join("");
                const startOffset = this.currentIndex + componentOffset - param.name.length;
                param.startPosition = this.document.positionFromCursor(startOffset, startOffset);
                param.endPosition = this.document.positionFromCursor(this.currentIndex + componentOffset, this.currentIndex + componentOffset);
                param.namePosition = {
                  start: param.startPosition,
                  end: param.endPosition
                };
                node.parameters.push(param);
                node.hasParameters = true;
                this.currentContent = [];
                continue;
              }
              continue;
            } else {
              if (!isParsingParameter) {
                isParsingParameter = true;
                parameterStartedOn = this.currentIndex;
              }
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_Equals && (0, isStartOfString_1.isStartOfString)(this.next)) {
              terminatorStyle = this.next;
              parameterNameEndedOn = this.currentIndex - 1;
              this.currentIndex += 1;
              this.checkCurrentOffsets();
              parameterValueStartedOn = this.currentIndex;
              const paramValue = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this), param = new nodes_1.ParameterNode();
              param.withParser(parser);
              param.name = this.currentContent.join("");
              param.value = paramValue.value;
              const nameStartOffset = node.relativeOffset(parameterStartedOn + 3), nameEndOffset = node.relativeOffset(parameterNameEndedOn + 3), valueStartOffset = node.relativeOffset(parameterValueStartedOn + 3), valueEndOffset = node.relativeOffset(paramValue.endedOn + 3);
              param.namePosition = {
                start: parser.positionFromOffset(nameStartOffset, nameStartOffset),
                end: parser.positionFromOffset(nameEndOffset, nameEndOffset)
              };
              param.valuePosition = {
                start: parser.positionFromOffset(valueStartOffset, valueStartOffset),
                end: parser.positionFromOffset(valueEndOffset, valueEndOffset)
              };
              param.terminatorStyle = terminatorStyle;
              param.wrappedValue = terminatorStyle + param.value + terminatorStyle;
              param.content = param.name + "=" + param.wrappedValue;
              param.realName = param.name;
              if (param.realName.startsWith(":")) {
                param.isExpression = true;
                param.realName = param.realName.substring(1);
                if (param.realName.startsWith(":")) {
                  param.isExpression = false;
                  param.realName = param.realName.substring(1);
                  param.isEscapedExpression = true;
                }
              }
              node.hasParameters = true;
              node.parameters.push(param);
              this.currentContent = [];
              isParsingParameter = false;
              parameterStartedOn = -1;
              parameterNameEndedOn = -1;
              parameterValueStartedOn = -1;
              terminatorStyle = '"';
              continue;
            }
          }
          this.currentContent.push(this.cur);
        }
        node.name = this.makeComponentName(node);
        node.parameterContent = this.parameterContent;
        if (node.hasParameters) {
          for (let i = 0; i < node.parameters.length; i++) {
            const thisParam = node.parameters[i];
            if (thisParam.type == nodes_1.ParameterType.InlineEcho) {
              const content = (_a2 = thisParam.inlineEcho) === null || _a2 === void 0 ? void 0 : _a2.content.trim();
              if (content.toLowerCase().startsWith("$attributes")) {
                node.receivesAttributeBag = true;
                break;
              }
            }
          }
        }
      }
      makeComponentName(component) {
        const parser = component.getParser(), componentName = new nodes_1.ComponentNameNode(), nameStartOffset = component.relativeOffset(this.nameStartsOn + 3), nameEndsOffset = component.relativeOffset(this.nameEndsOn + 3);
        componentName.withParser(parser);
        componentName.name = this.name;
        if (component.isClosingTag) {
          componentName.name = component.innerContent.trim().substring(1);
        }
        if (componentName.name.includes(":")) {
          const parts = componentName.name.split(":");
          componentName.name = parts[0];
          componentName.inlineName = parts.slice(1).join(":");
        }
        componentName.startPosition = parser.positionFromOffset(nameStartOffset, nameStartOffset);
        componentName.endPosition = parser.positionFromOffset(nameEndsOffset, nameEndsOffset);
        return componentName;
      }
    };
    exports.ComponentParser = ComponentParser;
  }
});

// node_modules/stillat-blade-parser/out/parser/fragmentsParser.js
var require_fragmentsParser = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/fragmentsParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FragmentsParser = void 0;
    var nodes_1 = require_nodes();
    var position_1 = require_position();
    var stringUtilities_1 = require_stringUtilities();
    var documentParser_1 = require_documentParser();
    var isStartOfString_1 = require_isStartOfString();
    var skipToEndOfLine_1 = require_skipToEndOfLine();
    var skipToEndOfMultilineComment_1 = require_skipToEndOfMultilineComment();
    var skipToEndOfString_1 = require_skipToEndOfString();
    var FragmentsParser = class {
      constructor() {
        this.content = "";
        this.nodeIndex = [];
        this.fragmentStartIndex = [];
        this.charLen = 0;
        this.documentOffsets = /* @__PURE__ */ new Map();
        this.inputLen = 0;
        this.seedOffset = 0;
        this.shiftLine = 0;
        this.chars = [];
        this.currentIndex = 0;
        this.lastDocumentOffsetKey = null;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.chunkSize = 5;
        this.currentChunkOffset = 0;
        this.fragments = [];
        this.isScript = false;
        this.fragmentOpeningIndex = /* @__PURE__ */ new Map();
        this.indexedFragments = /* @__PURE__ */ new Map();
        this.embeddedIndexedFragments = /* @__PURE__ */ new Map();
      }
      updateIndex(index) {
        this.currentIndex = index;
      }
      inputLength() {
        return this.inputLen;
      }
      incrementIndex() {
        this.currentIndex += 1;
      }
      getCurrentIndex() {
        return this.currentIndex;
      }
      getCurrent() {
        return this.cur;
      }
      getNext() {
        return this.next;
      }
      getPrev() {
        return this.prev;
      }
      pushChar(value) {
        return;
      }
      getChar(index) {
        return this.chars[index];
      }
      getSeedOffset() {
        return this.seedOffset;
      }
      setDocumentOffsets(offsets, lastOffsetIndex) {
        this.documentOffsets = offsets;
        this.lastDocumentOffsetKey = lastOffsetIndex;
        return this;
      }
      getClosingFragmentAfter(fragment) {
        const lowerName = fragment.name.toLowerCase();
        for (let i = 0; i < this.fragments.length; i++) {
          const thisFragment = this.fragments[i];
          if (thisFragment.isClosingFragment && !thisFragment.isSelfClosing && thisFragment.name.toLowerCase() == lowerName && thisFragment.index > fragment.index) {
            return thisFragment;
          }
        }
        return null;
      }
      getContentSubstring(from, length) {
        return this.content.substr(from, length);
      }
      resetState() {
        this.fragments = [];
        this.inputLen = 0;
        this.fragmentStartIndex = [];
        this.fragmentOpeningIndex.clear();
        return this;
      }
      resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.seedOffset = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
      }
      positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
          if (this.documentOffsets.size == 0) {
            lineToUse = 1;
            charToUse = offset + 1;
          } else {
            let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
            for (const documentOffset of this.documentOffsets.keys()) {
              if (documentOffset >= offset) {
                if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                  nearestOffset = lastOffset;
                  nearestOffsetIndex = lastOffsetIndex;
                } else {
                  nearestOffset = this.documentOffsets.get(documentOffset);
                  nearestOffsetIndex = documentOffset;
                }
                break;
              }
              lastOffset = this.documentOffsets.get(documentOffset);
              lastOffsetIndex = documentOffset;
            }
            if (nearestOffset == null) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            }
            if (nearestOffset != null) {
              if (isRelativeOffset) {
                const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              } else {
                const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              }
            } else {
              if (this.lastDocumentOffsetKey != null) {
                const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
                lineToUse = lastOffset2.line + 1;
                charToUse = offset + this.lastDocumentOffsetKey;
              }
            }
          }
        } else {
          const offsetDetails = this.documentOffsets.get(offset);
          lineToUse = offsetDetails.line;
          charToUse = offsetDetails.char;
        }
        const position = new position_1.Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
      }
      getFragments() {
        return this.fragments;
      }
      getFragmentsBetween(startIndex, endIndex) {
        const returnFragments = [];
        this.fragments.forEach((fragment) => {
          var _a2, _b, _c, _d;
          const start = (_b = (_a2 = fragment.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0, end = (_d = (_c = fragment.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0;
          if (start > startIndex && end < endIndex) {
            returnFragments.push(fragment);
          }
        });
        return returnFragments;
      }
      getFragmentContaining(position) {
        var _a2, _b, _c, _d;
        for (let i = 0; i < this.fragments.length; i++) {
          const thisFragment = this.fragments[i];
          if (((_b = (_a2 = thisFragment.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0) < position.index && ((_d = (_c = thisFragment.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) > position.index) {
            return thisFragment;
          }
        }
        return null;
      }
      checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
          this.cur = null;
          this.prev = null;
          this.next = null;
          return;
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          let doPeek = true;
          if (this.currentIndex == this.charLen - 1) {
            const nextChunk = stringUtilities_1.StringUtilities.split(stringUtilities_1.StringUtilities.substring(this.content, this.currentChunkOffset + this.chunkSize, this.chunkSize));
            this.currentChunkOffset += this.chunkSize;
            if (this.currentChunkOffset == this.inputLen) {
              doPeek = false;
            }
            nextChunk.forEach((nextChar) => {
              this.chars.push(nextChar);
              this.charLen += 1;
            });
          }
          if (doPeek && this.currentIndex + 1 < this.chars.length) {
            this.next = this.chars[this.currentIndex + 1];
          }
        }
      }
      processInputText(input) {
        this.content = input;
        this.inputLen = this.content.length;
        const fragmentCandidates = [...this.content.matchAll(/(<(?!\?[php|\?=]))/gm)], newCandidates = [];
        fragmentCandidates.forEach((candidate) => {
          var _a2;
          const candidateIndex = (_a2 = candidate.index) !== null && _a2 !== void 0 ? _a2 : 0;
          for (let i = 0; i < this.nodeIndex.length; i++) {
            const thisIndex = this.nodeIndex[i];
            if (candidateIndex >= thisIndex.start && candidateIndex <= thisIndex.end) {
              return;
            }
          }
          newCandidates.push(candidateIndex);
        });
        this.fragmentStartIndex = newCandidates;
      }
      setIndexRanges(index) {
        this.nodeIndex = index;
        return this;
      }
      fetchAt(start, length) {
        return this.content.substr(start, length);
      }
      getFragmentsContainingStructures() {
        const structures = [];
        this.fragments.forEach((fragment) => {
          if (!fragment.isClosingFragment && !fragment.isSelfClosing && fragment.containsStructures) {
            const close = this.getClosingFragmentAfter(fragment);
            if (close != null) {
              structures.push({
                start: fragment,
                end: close
              });
            }
          }
        });
        return structures;
      }
      parse(text) {
        this.resetState().processInputText(text);
        const indexCount = this.fragmentStartIndex.length;
        if (indexCount == 0) {
          return [];
        }
        for (let i = 0; i < this.fragmentStartIndex.length; i++) {
          const offset = this.fragmentStartIndex[i];
          this.resetIntermediateState();
          this.seedOffset = offset;
          this.currentChunkOffset = offset;
          this.parseIntermediateText();
          if (this.isScript) {
            let didFind = false;
            for (let j = i + 1; j < this.fragmentStartIndex.length; j++) {
              const checkIndex = this.fragmentStartIndex[j], thisChunk = this.fetchAt(checkIndex, 8).toLowerCase();
              if (thisChunk == "</script") {
                i = j - 1;
                this.isScript = false;
                didFind = true;
                break;
              }
            }
            if (!didFind) {
              break;
            }
          }
        }
        let fragmentIndex = 0, embeddedIndex = 0;
        this.fragments.forEach((fragment) => {
          const lowerName = fragment.name.toLowerCase();
          if (lowerName == "script" || lowerName == "style") {
            fragment.embeddedIndex = embeddedIndex;
            this.embeddedIndexedFragments.set(embeddedIndex, fragment);
            embeddedIndex += 1;
          }
          fragment.index = fragmentIndex;
          this.indexedFragments.set(fragmentIndex, fragment);
          fragmentIndex += 1;
        });
        return this.fragments;
      }
      getFragment(index) {
        return this.indexedFragments.get(index);
      }
      getEmbeddedFragment(index) {
        return this.embeddedIndexedFragments.get(index);
      }
      hasFragments() {
        return this.fragments.length > 0;
      }
      skipToEndOfPhp() {
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            (0, skipToEndOfString_1.skipToEndOfString)(this);
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
            (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_Asterisk) {
            (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_QuestionMark && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan || this.next == null) {
            break;
          }
        }
      }
      parseIntermediateText() {
        this.chars = this.content.substr(this.currentChunkOffset, this.chunkSize).split("");
        this.charLen = this.chars.length;
        const fragmentStartedAt = this.currentIndex, potentialParameterRanges = [], nameChars = [];
        let hasFoundName = false, isClosingFragment = false;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
            hasFoundName = true;
          }
          if (this.next == documentParser_1.DocumentParser.Punctuation_LessThan) {
            let shift = 1;
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
              shift = 2;
            }
            const curFetch = this.fetchAt(this.currentChunkOffset + shift, 5);
            if (curFetch.toLowerCase() == "<?php" || curFetch.startsWith("<?=")) {
              this.skipToEndOfPhp();
              continue;
            }
          }
          if (this.currentIndex > 0 && this.cur == documentParser_1.DocumentParser.Punctuation_LessThan) {
            break;
          }
          if (this.next == null && this.cur != documentParser_1.DocumentParser.Punctuation_GreaterThan) {
            break;
          }
          if (!hasFoundName && this.cur == documentParser_1.DocumentParser.Punctuation_LessThan && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
            isClosingFragment = true;
          }
          if (!hasFoundName && this.cur != documentParser_1.DocumentParser.Punctuation_LessThan && this.cur != documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.cur != documentParser_1.DocumentParser.Punctuation_GreaterThan) {
            nameChars.push(this.cur);
          }
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            const stringStartedOn = this.currentIndex;
            (0, skipToEndOfString_1.skipToEndOfString)(this);
            const fragmentParameter = new nodes_1.FragmentParameterNode();
            fragmentParameter.startPosition = this.positionFromOffset(stringStartedOn + this.seedOffset, stringStartedOn + this.seedOffset);
            fragmentParameter.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
            potentialParameterRanges.push(fragmentParameter);
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
            const fragment = new nodes_1.FragmentNode();
            fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
            fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset + 1, this.currentIndex + this.seedOffset + 1);
            fragment.parameters = potentialParameterRanges;
            fragment.isSelfClosing = true;
            fragment.name = nameChars.join("");
            fragment.isClosingFragment = isClosingFragment;
            this.fragments.push(fragment);
            if (isClosingFragment) {
              this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
            } else {
              this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
            }
            break;
          }
          if (this.cur == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
            const fragment = new nodes_1.FragmentNode();
            fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
            fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
            fragment.parameters = potentialParameterRanges;
            fragment.name = nameChars.join("");
            fragment.isClosingFragment = isClosingFragment;
            this.fragments.push(fragment);
            if (isClosingFragment) {
              this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
            } else {
              this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
            }
            if (fragment.name.toLowerCase() == "script" && fragment.isClosingFragment == false) {
              this.isScript = true;
            }
            break;
          }
        }
      }
    };
    exports.FragmentsParser = FragmentsParser;
  }
});

// node_modules/stillat-blade-parser/out/parser/excludeDirectives/cssAtRules.js
var require_cssAtRules = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/excludeDirectives/cssAtRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CssAtRules = void 0;
    exports.CssAtRules = [
      "media",
      "charset",
      "import",
      "namespace",
      "supports",
      "document",
      "page",
      "font-face",
      "keyframes",
      "viewport",
      "counter-style",
      "font-feature-values",
      "swash",
      "ornaments",
      "annotation",
      "stylistic",
      "styleset",
      "character-variant",
      "font-variant-alternates",
      "property",
      "color-profile"
    ];
  }
});

// node_modules/stillat-blade-parser/out/parser/excludeDirectives/commonEventShortcuts.js
var require_commonEventShortcuts = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/excludeDirectives/commonEventShortcuts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonEventShortcuts = void 0;
    exports.CommonEventShortcuts = [
      "click",
      "submit",
      "scroll",
      "keydown",
      "keypress",
      "keyup",
      "blur",
      "change",
      "contextmenu",
      "copy",
      "cut",
      "paste",
      "dblclick",
      "drag",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "dragstart",
      "drop",
      "focus",
      "focusin",
      "focusout",
      "input",
      "mousedown",
      "mouseenter",
      "mouseleave",
      "mousemove",
      "mouseover",
      "mouseout",
      "mouseup",
      "mousewheel",
      "resize",
      "select",
      "touchcancel",
      "touchend",
      "touchmove",
      "touchstart",
      "wheel"
    ];
  }
});

// node_modules/stillat-blade-parser/out/parser/parserOptions.js
var require_parserOptions = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/parserOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParserOptions = exports.updateParserOptions = void 0;
    var cssAtRules_1 = require_cssAtRules();
    var commonEventShortcuts_1 = require_commonEventShortcuts();
    var globalOptions = {
      ignoreDirectives: [
        ...cssAtRules_1.CssAtRules,
        ...commonEventShortcuts_1.CommonEventShortcuts
      ],
      directives: [],
      customIfs: []
    };
    function updateParserOptions(options) {
      globalOptions = options;
    }
    exports.updateParserOptions = updateParserOptions;
    function getParserOptions() {
      return globalOptions;
    }
    exports.getParserOptions = getParserOptions;
  }
});

// node_modules/stillat-blade-parser/out/parser/documentParser.js
var require_documentParser = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/documentParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentParser = void 0;
    var conditionalRewriteAnalyzer_1 = require_conditionalRewriteAnalyzer();
    var directivePairAnalyzer_1 = require_directivePairAnalyzer();
    var directiveStack_1 = require_directiveStack();
    var fragmentPositionAnalyzer_1 = require_fragmentPositionAnalyzer();
    var inlineEchoAnalyzer_1 = require_inlineEchoAnalyzer();
    var inlinePhpAnalyzer_1 = require_inlinePhpAnalyzer();
    var pairManager_1 = require_pairManager();
    var bladeDocument_1 = require_bladeDocument();
    var wordScanner_1 = require_wordScanner();
    var bladeError_1 = require_bladeError();
    var bladeErrorCodes_1 = require_bladeErrorCodes();
    var helpers_1 = require_helpers();
    var nodes_1 = require_nodes();
    var position_1 = require_position();
    var stringUtilities_1 = require_stringUtilities();
    var bladeKeywords_1 = require_bladeKeywords();
    var componentParser_1 = require_componentParser();
    var fragmentsParser_1 = require_fragmentsParser();
    var parserOptions_1 = require_parserOptions();
    var isStartOfString_1 = require_isStartOfString();
    var nextNonWhitespace_1 = require_nextNonWhitespace();
    var scanToEndOfLogicGroup_1 = require_scanToEndOfLogicGroup();
    var skipToEndOfLine_1 = require_skipToEndOfLine();
    var skipToEndOfMultilineComment_1 = require_skipToEndOfMultilineComment();
    var skipToEndOfString_1 = require_skipToEndOfString();
    var DocumentParser = class {
      constructor() {
        this.nodes = [];
        this.renderNodes = [];
        this.chars = [];
        this.currentIndex = 0;
        this.currentContent = [];
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.charLen = 0;
        this.inputLen = 0;
        this.maxLine = 1;
        this.chunkSize = 5;
        this.currentChunkOffset = 0;
        this.parsingOffset = 0;
        this.isVerbatim = false;
        this.isPhpNode = false;
        this.bladeStartIndex = [];
        this.bladeStartPositionIndex = /* @__PURE__ */ new Map();
        this.lastBladeEndIndex = -1;
        this.lastNode = null;
        this.documentOffsets = /* @__PURE__ */ new Map();
        this.lineIndex = /* @__PURE__ */ new Map();
        this.lastDocumentOffsetKey = null;
        this.content = "";
        this.originalContent = "";
        this.seedOffset = 0;
        this.seedStartLine = 1;
        this.shiftLine = 0;
        this.isParsingComponent = false;
        this.shouldIgnoreStructures = false;
        this.pushedErrors = /* @__PURE__ */ new Map();
        this.errors = [];
        this.structureErrors = [];
        this.doesHaveUnclosedIfStructures = false;
        this.doesHaveUnclosedSwitchStructures = false;
        this.doesHaveUnclosedComments = false;
        this.doesHaveUnclosedRegions = false;
        this.phpValidator = null;
        this.unclosedRegionErrors = [
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_PHP_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_PHP_CLOSING_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_VERBATIM,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_VERBATIM_CLOSING_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_CLOSING_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_ELSE_DIRECTIVE,
          bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_ELSE_CLOSING_DIRECTIVE
        ];
        this.componentParser = new componentParser_1.ComponentParser(this);
        this.fragmentsParser = new fragmentsParser_1.FragmentsParser();
        this.fragmentsAnalyzer = new fragmentPositionAnalyzer_1.FragmentPositionAnalyzer(this, this.fragmentsParser);
        this.parserOptions = (0, parserOptions_1.getParserOptions)();
      }
      withPhpValidator(validator) {
        this.phpValidator = validator;
        return this;
      }
      getPhpValidator() {
        return this.phpValidator;
      }
      withParserOptions(options) {
        this.parserOptions = options;
        return this;
      }
      hasUnclosedIfStructures() {
        return this.doesHaveUnclosedIfStructures;
      }
      hasUnclosedSwitchStructures() {
        return this.doesHaveUnclosedSwitchStructures;
      }
      hasUnclosedComments() {
        return this.doesHaveUnclosedComments;
      }
      hasUnclosedRegions() {
        return this.doesHaveUnclosedRegions;
      }
      hasUnclosedStructures() {
        return this.doesHaveUnclosedComments || this.doesHaveUnclosedIfStructures || this.doesHaveUnclosedSwitchStructures || this.doesHaveUnclosedRegions;
      }
      getErrors() {
        return this.errors;
      }
      getStructureErrors() {
        return this.structureErrors;
      }
      updateIndex(index) {
        this.currentIndex = index;
      }
      inputLength() {
        return this.inputLen;
      }
      incrementIndex() {
        this.currentIndex += 1;
      }
      getCurrentIndex() {
        return this.currentIndex;
      }
      getCurrent() {
        return this.cur;
      }
      getNext() {
        return this.next;
      }
      getPrev() {
        return this.prev;
      }
      getChar(index) {
        return this.chars[index];
      }
      pushChar(value) {
        this.currentContent.push(value);
      }
      getSeedOffset() {
        return this.seedOffset;
      }
      getContentSubstring(from, length) {
        return this.content.substr(from, length);
      }
      resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.currentContent = [];
        this.cur = null;
        this.next = null;
        this.prev = null;
      }
      setSeedPosition(position) {
        if (position == null) {
          this.shiftLine = 0;
        } else {
          this.shiftLine = position.line;
        }
        return this;
      }
      resetState() {
        this.nodes = [];
        this.renderNodes = [];
        this.charLen = 0;
        this.bladeStartIndex = [];
        this.lastBladeEndIndex = -1;
      }
      isStartingPhp() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_QuestionMark) {
          const fetch = this.fetchAt(this.currentChunkOffset, 5).toLowerCase();
          return fetch == "<?php";
        }
        return false;
      }
      isStartingShorthandPhp() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_QuestionMark) {
          const fetch = this.fetchAt(this.currentChunkOffset, 3).toLowerCase();
          return fetch == "<?=";
        }
        return false;
      }
      isStartingDirective() {
        if (this.next != null) {
          if (!stringUtilities_1.StringUtilities.ctypeAlpha(this.next)) {
            return false;
          }
        }
        if (this.cur == DocumentParser.AtChar && this.next != null && this.prev != DocumentParser.AtChar) {
          return true;
        }
        return false;
      }
      isClosingComponent() {
        if (this.cur == DocumentParser.Punctuation_GreaterThan && (this.prev != DocumentParser.Punctuation_Minus && this.prev != DocumentParser.Punctuation_Equals)) {
          return true;
        }
        return false;
      }
      isStartingClosingComponentTag() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_ForwardSlash && this.peekRelative(2) == "x" && (this.peekRelative(3) == DocumentParser.Punctuation_Minus || this.peekRelative(3) == DocumentParser.Punctuation_Colon)) {
          return true;
        }
        return false;
      }
      isStartingOpeningComponentTag() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == "x" && (this.peekRelative(2) == DocumentParser.Punctuation_Minus || this.peekRelative(2) == DocumentParser.Punctuation_Colon)) {
          return true;
        }
        return false;
      }
      isStartingEscapedEcho() {
        if ((this.prev == null || this.prev != null && this.prev != DocumentParser.AtChar) && this.next == DocumentParser.Punctuation_Exclamation) {
          if (this.cur == DocumentParser.LeftBrace && this.peek(2) == DocumentParser.Punctuation_Exclamation) {
            return true;
          }
        }
        return false;
      }
      isStartingBladeNodeStructure() {
        if ((this.prev == null || this.prev != null && this.prev != DocumentParser.AtChar) && this.next == DocumentParser.LeftBrace) {
          if (this.cur == DocumentParser.LeftBrace && this.next == DocumentParser.LeftBrace) {
            return true;
          }
        }
        return false;
      }
      hasEncounteredAnotherStructure() {
        if (this.shouldIgnoreStructures) {
          return false;
        }
        if (this.isStartingOpeningComponentTag()) {
          return true;
        }
        if (this.isParsingComponent) {
          return false;
        }
        if (this.isStartingClosingComponentTag() || this.isStartingDirective() || this.isStartingEscapedEcho() || this.isStartingBladeNodeStructure()) {
          return true;
        }
        return false;
      }
      processInputText(input) {
        var _a2;
        this.originalContent = input;
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(input);
        this.inputLen = this.content.length;
        const documentNewLines = [...this.content.matchAll(/(\n)/gm)];
        const newLineCountLen = documentNewLines.length;
        let currentLine = this.seedStartLine, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
        for (let i = 0; i < newLineCountLen; i++) {
          const thisNewLine = documentNewLines[i], thisIndex = (_a2 = thisNewLine.index) !== null && _a2 !== void 0 ? _a2 : 0;
          let indexChar = thisIndex;
          if (lastOffset != null) {
            indexChar = thisIndex - lastOffset;
          } else {
            indexChar = indexChar + 1;
          }
          this.documentOffsets.set(thisIndex, {
            char: indexChar,
            line: currentLine
          });
          let thisStartIndex = 0, thisEndIndex = 0;
          if (i == 0) {
            thisEndIndex = indexChar - 1;
            thisStartIndex = 0;
          } else {
            thisStartIndex = lastEndIndex + 1;
            thisEndIndex = thisIndex;
          }
          this.lineIndex.set(currentLine, {
            char: indexChar,
            line: currentLine,
            startIndex: thisStartIndex,
            endIndex: thisEndIndex
          });
          this.lastDocumentOffsetKey = thisIndex;
          this.maxLine = currentLine;
          currentLine += 1;
          lastOffset = thisIndex;
          lastEndIndex = thisEndIndex;
          lastStartIndex = thisStartIndex;
        }
        this.maxLine += 1;
        const bladeStartCandidates = [...this.content.matchAll(/(@?{{|<\?php|<\?=|@?{!!|@|<x-|<\/x-|<x:|<\/x:)/gm)];
        let lastBladeOffset = 0, lastWasEscaped = false;
        bladeStartCandidates.forEach((bladeRegion) => {
          const matchText = bladeRegion[0], seekIndex = this.content.indexOf(matchText, lastBladeOffset), seekText = this.content.substr(seekIndex, 10);
          if (seekText.startsWith("@@") || seekText.startsWith("@{{")) {
            lastBladeOffset = this.content.indexOf(matchText, lastBladeOffset);
            lastWasEscaped = true;
            return;
          }
          const offset = this.content.indexOf(matchText, lastBladeOffset);
          if (lastWasEscaped) {
            if (lastBladeOffset == offset) {
              lastBladeOffset = offset;
              return;
            }
          }
          let prefetchLength = 3, shouldCheckForIgnoredDirectives = false, exclusiveDirectivesSupplied = false;
          const lowerIgnoreDirectives = [], lowerExclusiveDirectives = [];
          if (this.parserOptions.ignoreDirectives.length > 0) {
            this.parserOptions.ignoreDirectives.forEach((directive) => {
              lowerIgnoreDirectives.push(directive.toLowerCase());
              if (directive.length > prefetchLength) {
                prefetchLength = directive.length;
              }
            });
            prefetchLength += 5;
            shouldCheckForIgnoredDirectives = true;
          }
          if (this.parserOptions.directives.length > 0) {
            prefetchLength = 3;
            this.parserOptions.directives.forEach((directive) => {
              lowerExclusiveDirectives.push(directive.toLowerCase());
              if (directive.length > prefetchLength) {
                prefetchLength = directive.length;
              }
            });
            prefetchLength += 5;
            shouldCheckForIgnoredDirectives = false;
            exclusiveDirectivesSupplied = true;
          }
          const preFetch = this.fetchAt(offset, prefetchLength);
          if (preFetch.startsWith("@{") == false) {
            const firstChar = preFetch.substring(0, 1), secondChar = preFetch.substring(1, 2);
            if (firstChar == "@" && stringUtilities_1.StringUtilities.ctypeAlpha(secondChar)) {
              if (exclusiveDirectivesSupplied) {
                const checkPrefetch = this.breakPreFetch(preFetch).toLowerCase();
                if (lowerExclusiveDirectives.includes(checkPrefetch)) {
                  this.bladeStartIndex.push(offset);
                }
              } else {
                if (shouldCheckForIgnoredDirectives) {
                  const checkPrefetch = this.breakPreFetch(preFetch).toLowerCase();
                  if (!lowerIgnoreDirectives.includes(checkPrefetch)) {
                    this.bladeStartIndex.push(offset);
                  }
                } else {
                  this.bladeStartIndex.push(offset);
                }
              }
            } else if (firstChar != "@") {
              this.bladeStartIndex.push(offset);
            }
          }
          this.bladeStartPositionIndex.set(offset, 1);
          lastBladeOffset = offset + 2;
          lastWasEscaped = false;
        });
        this.fragmentsParser.setDocumentOffsets(this.documentOffsets, this.lastDocumentOffsetKey);
        return true;
      }
      breakPreFetch(value) {
        const wsParts = stringUtilities_1.StringUtilities.replaceAllInString(stringUtilities_1.StringUtilities.normalizeLineEndings(value), "\n", " ").split(" "), parenParts = wsParts[0].split("(");
        let candidate = parenParts[0].trim();
        if (candidate.startsWith("@")) {
          candidate = candidate.substring(1);
        }
        return candidate.toLowerCase();
      }
      fetchAt(start, length) {
        return this.content.substr(start, length);
      }
      shouldSkipForward() {
        if (this.lastNode == null) {
          return true;
        }
        if (this.lastNode instanceof nodes_1.DirectiveNode) {
          if (this.lastNode.directiveName == bladeKeywords_1.BladeKeywords.Verbatim || this.lastNode.directiveName == bladeKeywords_1.BladeKeywords.Php) {
            return false;
          }
        }
        return true;
      }
      pushError(error) {
        const errorHash = error.hash();
        if (!this.pushedErrors.has(errorHash)) {
          if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION) {
            this.doesHaveUnclosedIfStructures = true;
            this.structureErrors.push(error);
          } else if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_SWITCH) {
            this.doesHaveUnclosedSwitchStructures = true;
            this.structureErrors.push(error);
          } else if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_COMMENT) {
            this.doesHaveUnclosedComments = true;
            this.structureErrors.push(error);
          } else if (this.unclosedRegionErrors.includes(error.errorCode)) {
            this.doesHaveUnclosedRegions = true;
            this.structureErrors.push(error);
          }
          this.pushedErrors.set(errorHash, error);
          this.errors.push(error);
        }
      }
      getContent() {
        return this.content;
      }
      getOriginalContent() {
        return this.originalContent;
      }
      getFragments() {
        return this.fragmentsParser.getFragments();
      }
      getFragmentsParser() {
        return this.fragmentsParser;
      }
      getFragmentsContainingStructures() {
        return this.fragmentsParser.getFragmentsContainingStructures();
      }
      charLeftAt(position) {
        if (position == null) {
          return null;
        }
        if (position.char <= 1) {
          return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char - 1));
      }
      charLeftAtCursor(line, char) {
        return this.charLeftAt(this.positionFromCursor(line, char));
      }
      charRightAt(position) {
        if (position == null) {
          return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char + 1));
      }
      charRightAtCursor(line, char) {
        return this.charRightAt(this.positionFromCursor(line, char));
      }
      punctuationLeftAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return wordScanner_1.WordScanner.findLeftNeighboringNextPunctuation(position.char, lineText, tabSize);
      }
      punctuationLeftAtCursor(line, char, tabSize = 4) {
        return this.punctuationLeftAt(this.positionFromCursor(line, char), tabSize);
      }
      punctuationRightAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return wordScanner_1.WordScanner.findRightBeighboringNextPunctuation(position.char, lineText, tabSize);
      }
      punctuationRightAtCursor(line, char, tabSize = 4) {
        return this.punctuationRightAt(this.positionFromCursor(line, char), tabSize);
      }
      wordRightAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        const rightWordChar = wordScanner_1.WordScanner.findRightNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (rightWordChar == null) {
          return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(rightWordChar, lineText, tabSize);
      }
      wordRightAtCursor(line, char, tabSize = 4) {
        return this.wordRightAt(this.positionFromCursor(line, char), tabSize);
      }
      wordLeftAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        const leftWordChar = wordScanner_1.WordScanner.findLeftNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (leftWordChar == null) {
          return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(leftWordChar, lineText, tabSize);
      }
      wordLeftAtCursor(line, char, tabSize = 4) {
        return this.wordLeftAt(this.positionFromCursor(line, char), tabSize);
      }
      wordAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(position.char, lineText, tabSize);
      }
      getLineText(lineNumber) {
        const index = this.getLineIndex(lineNumber);
        if (index != null) {
          return stringUtilities_1.StringUtilities.trimRight(this.getContent().substring(index.start, index.end + 1));
        }
        return null;
      }
      wordAtCursor(line, char, tabSize = 4) {
        return this.wordAt(this.positionFromCursor(line, char), tabSize);
      }
      charAt(position) {
        if (position == null) {
          return null;
        }
        return this.content.substr(position.offset, 1);
      }
      getLinesAround(line) {
        var _a2;
        const lines = /* @__PURE__ */ new Map();
        let startLine = line - 3, endLine = line + 3;
        if (startLine < 1) {
          startLine = 1;
        }
        if (endLine > this.maxLine) {
          endLine = this.maxLine;
        }
        for (let i = startLine; i <= endLine; i++) {
          lines.set(i, (_a2 = this.getLineText(i)) !== null && _a2 !== void 0 ? _a2 : "");
        }
        return lines;
      }
      charAtCursor(line, char) {
        return this.charAt(this.positionFromCursor(line, char));
      }
      getLineIndex(line) {
        if (line == this.maxLine) {
          const lastIndex = this.lineIndex.get(line - 1);
          if (lastIndex != null) {
            const startIndex = lastIndex.endIndex + 1, endIndex = this.inputLen - 1;
            return {
              end: endIndex,
              start: startIndex
            };
          }
          return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
          return {
            start: indexEntry.startIndex,
            end: indexEntry.endIndex
          };
        }
        return null;
      }
      positionFromCursor(line, char) {
        if (line == this.maxLine) {
          const lastIndex = this.lineIndex.get(line - 1);
          if (lastIndex != null) {
            const startIndex = lastIndex.endIndex + 1, thisOffset = startIndex + (char - 1);
            const position = new position_1.Position();
            position.offset = thisOffset;
            position.line = line;
            position.char = char;
            position.index = thisOffset;
            return position;
          }
          return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
          const position = new position_1.Position();
          position.offset = indexEntry.startIndex + (char - 1);
          position.line = indexEntry.line;
          position.char = char;
          position.index = indexEntry.startIndex + (char - 1);
          return position;
        }
        return null;
      }
      parse(text) {
        pairManager_1.PairManager.customIfs.clear();
        this.parserOptions.customIfs.forEach((customIf) => {
          pairManager_1.PairManager.customIfs.set(customIf, 1);
        });
        if (!this.processInputText(text)) {
          return [];
        }
        const indexCount = this.bladeStartIndex.length, lastIndex = indexCount - 1;
        if (indexCount == 0 && !this.isVerbatim) {
          const fullDocumentLiteral = new nodes_1.LiteralNode();
          fullDocumentLiteral.withParser(this);
          fullDocumentLiteral.content = this.prepareLiteralContent(this.content);
          fullDocumentLiteral.startPosition = this.positionFromOffset(0, 0);
          fullDocumentLiteral.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
          this.nodes.push(fullDocumentLiteral);
        } else {
          for (let i = 0; i < indexCount; i += 1) {
            let offset = this.bladeStartIndex[i];
            this.seedOffset = offset;
            if (i == 0 && offset > 0 && !this.isVerbatim) {
              const node = new nodes_1.LiteralNode();
              node.withParser(this);
              node.content = this.prepareLiteralContent(this.content.substr(0, offset));
              if (node.content.length > 0) {
                node.startPosition = this.positionFromOffset(0, 0);
                node.endPosition = this.positionFromOffset(offset, offset - 1);
                this.nodes.push(node);
              }
            }
            if (offset < this.lastBladeEndIndex) {
              continue;
            }
            this.currentChunkOffset = offset;
            this.parsingOffset = offset;
            this.resetIntermediateState();
            this.parseIntermediateText(offset);
            if (this.isVerbatim) {
              let found = false;
              for (let j = i + 1; j < this.bladeStartIndex.length; j++) {
                const checkIndex = this.bladeStartIndex[j], thisChunk = this.fetchAt(checkIndex, 12);
                if (thisChunk == "@endverbatim") {
                  i = j - 1;
                  this.isVerbatim = false;
                  found = true;
                  break;
                }
              }
              if (found) {
                continue;
              }
            }
            if (this.isPhpNode) {
              let found = false;
              for (let j = i + 1; j < this.bladeStartIndex.length; j++) {
                const checkIndex = this.bladeStartIndex[j], thisChunk = this.fetchAt(checkIndex, 7);
                if (thisChunk == "@endphp") {
                  i = j - 1;
                  this.isPhpNode = false;
                  found = true;
                  break;
                }
              }
              if (found) {
                continue;
              }
            }
            if (this.lastNode instanceof nodes_1.BladeCommentNode || this.lastNode instanceof nodes_1.InlinePhpNode) {
              let seekLiteralIndex = -1;
              for (let j = i; j < this.bladeStartIndex.length; j++) {
                const checkIndex = this.bladeStartIndex[j];
                if (checkIndex > this.lastBladeEndIndex) {
                  seekLiteralIndex = checkIndex;
                  break;
                }
              }
              if (seekLiteralIndex != -1) {
                let literalOffset = 1;
                if (this.lastNode instanceof nodes_1.InlinePhpNode) {
                  literalOffset = 0;
                }
                const literalStart = this.lastBladeEndIndex + literalOffset, literalContent = this.content.substr(this.lastBladeEndIndex + literalOffset, seekLiteralIndex - this.lastBladeEndIndex - literalOffset), literalEnd = seekLiteralIndex - 1;
                const literalNode = new nodes_1.LiteralNode();
                literalNode.withParser(this);
                literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                literalNode.endPosition = this.positionFromOffset(literalEnd, literalEnd);
                literalNode.content = literalContent;
                this.nodes.push(literalNode);
                this.lastNode = literalNode;
                this.lastBladeEndIndex = literalEnd;
                continue;
              }
            }
            if (this.lastNode instanceof nodes_1.BladeComponentNode) {
              offset -= 2;
            }
            let shouldProduceLiteralNode = false;
            if (!this.bladeStartPositionIndex.has(this.currentChunkOffset)) {
              shouldProduceLiteralNode = true;
            } else if (this.lastBladeEndIndex < this.currentChunkOffset) {
              shouldProduceLiteralNode = true;
            }
            if (shouldProduceLiteralNode) {
              if (i + 1 < indexCount) {
                let nextBladeStart = this.bladeStartIndex[i + 1];
                let literalNodeOffset = 1;
                if (this.lastNode instanceof nodes_1.InlinePhpNode) {
                  literalNodeOffset = 0;
                }
                const literalStartIndex = this.lastBladeEndIndex + literalNodeOffset;
                if (nextBladeStart < literalStartIndex) {
                  if (this.lastBladeEndIndex > nextBladeStart) {
                    if (i + 2 < indexCount) {
                      nextBladeStart = this.bladeStartIndex[i + 2];
                    }
                  } else {
                    continue;
                  }
                }
                if (this.shouldSkipForward()) {
                  for (let j = i; j < this.bladeStartIndex.length; j++) {
                    const checkIndex = this.bladeStartIndex[j];
                    if (checkIndex > this.lastBladeEndIndex) {
                      nextBladeStart = checkIndex;
                      break;
                    }
                  }
                }
                if (i + 1 == lastIndex && nextBladeStart <= this.lastBladeEndIndex) {
                  if (this.isVerbatim) {
                    break;
                  }
                  const thisOffset = this.currentChunkOffset, nodeContent = this.content.substr(literalStartIndex);
                  const literalNode = new nodes_1.LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(nodeContent);
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(thisOffset, thisOffset);
                    literalNode.endPosition = this.positionFromOffset(nextBladeStart, nextBladeStart - 1);
                    this.nodes.push(literalNode);
                  }
                  break;
                } else {
                  const literalLength = nextBladeStart - this.lastBladeEndIndex - 1;
                  if (literalLength == 0 || this.isVerbatim) {
                    continue;
                  }
                  const nodeContent = this.content.substr(literalStartIndex, literalLength);
                  const literalNode = new nodes_1.LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(nodeContent);
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(literalStartIndex, literalStartIndex);
                    literalNode.endPosition = this.positionFromOffset(nextBladeStart, nextBladeStart - 1);
                    this.nodes.push(literalNode);
                  }
                }
                continue;
              }
              if (i !== lastIndex && this.lastNode != null && this.lastNode.endPosition != null) {
                const startCandidate = this.positionFromOffset(offset, offset);
                if (startCandidate.isBefore(this.lastNode.endPosition)) {
                  if (i + 1 < indexCount) {
                    const nextBladeStart = this.bladeStartIndex[i + 1];
                    if (nextBladeStart < this.lastNode.endPosition.offset) {
                      continue;
                    }
                  } else {
                    if (i + 1 != lastIndex) {
                      continue;
                    }
                  }
                }
              }
              if (i == lastIndex) {
                const literalStart = this.currentIndex + offset;
                if (literalStart < this.inputLen && !this.isVerbatim) {
                  const literalNode = new nodes_1.LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(this.content.substr(literalStart));
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                    literalNode.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
                    this.nodes.push(literalNode);
                  }
                  break;
                }
              }
            }
          }
        }
        let curIndex = 0;
        this.nodes.forEach((node) => {
          node.index = curIndex;
          curIndex += 1;
        });
        let lastNode = null;
        for (let i = 0; i < this.nodes.length; i++) {
          const thisNode = this.nodes[i];
          let nextNode = null;
          if (i + 1 < this.nodes.length) {
            nextNode = this.nodes[i + 1];
          }
          thisNode.prevNode = lastNode;
          thisNode.nextNode = nextNode;
          lastNode = thisNode;
        }
        pairManager_1.PairManager.determineCandidates(this.nodes);
        this.nodes = conditionalRewriteAnalyzer_1.ConditionalRewriteAnalyzer.rewrite(this.nodes);
        const pairAnalyzer = new directivePairAnalyzer_1.DirectivePairAnalyzer();
        this.renderNodes = pairAnalyzer.associate(this.nodes, this);
        inlineEchoAnalyzer_1.InlineEchoAnalyzer.analyze(this.nodes);
        inlinePhpAnalyzer_1.InlinePhpAnalyzer.analyze(this.nodes);
        this.nodes.forEach((node) => {
          if (node instanceof nodes_1.DirectiveNode) {
            const directive = node, lowerName = directive.directiveName.toLowerCase();
            if (directive.isClosedBy != null) {
              const directiveChildren = directive.getImmediateChildren();
              for (let i = 0; i < directiveChildren.length; i++) {
                const child = directiveChildren[i];
                if (child instanceof nodes_1.DirectiveNode && child != directive.isClosedBy && child.isClosedBy != null) {
                  directive.containsChildStructures = true;
                  break;
                } else if (child instanceof nodes_1.ConditionNode || child instanceof nodes_1.SwitchStatementNode || child instanceof nodes_1.ForElseNode) {
                  directive.containsChildStructures = true;
                  break;
                }
              }
            }
            if (lowerName == "switch" && directive.isClosedBy == null || lowerName == "endswitch" && directive.isOpenedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_SWITCH, directive, "Unclosed switch control structure", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "php") {
              if (directive.hasDirectiveParameters == false && directive.isClosedBy == null) {
                directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_PHP_DIRECTIVE, directive, "Unclosed @php directive", bladeError_1.ErrrorLevel.Error));
              }
            } else if (lowerName == "endphp" && directive.isOpenedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_PHP_CLOSING_DIRECTIVE, directive, "Unpaired @endphp directive", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "verbatim" && directive.isClosedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_VERBATIM, directive, "Unclosed @verbatim directive", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "endverbatim" && directive.isOpenedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_VERBATIM_CLOSING_DIRECTIVE, directive, "Unpaired @endverbatim directive", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "for" && directive.isClosedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_DIRECTIVE, directive, "Unclosed @for directive", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "for" && directive.isClosingDirective == true && directive.isOpenedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_CLOSING_DIRECTIVE, directive, "Unpaired @endfor directive", bladeError_1.ErrrorLevel.Error));
            } else if (lowerName == "forelse") {
              if (directive.isClosedBy == null) {
                directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_ELSE_DIRECTIVE, directive, "Unclosed @forelse directive", bladeError_1.ErrrorLevel.Error));
              }
              const emptyChild = directive.findFirstDirectChildDirectiveOfType("empty");
              if (emptyChild == null) {
                directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_FOR_ELSE_MISSING_EMPTY_DIRECTIVE, directive, "@forelse missing @empty directive", bladeError_1.ErrrorLevel.Warning));
              }
            } else if (lowerName == "endforelse" && directive.isOpenedBy == null) {
              directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_ELSE_CLOSING_DIRECTIVE, directive, "Unpaired @endforelse directive", bladeError_1.ErrrorLevel.Error));
            }
          }
        });
        this.createChildDocuments(this.renderNodes);
        if (this.content.length > 0) {
          this.fragmentsParser.setIndexRanges(this.getNodeIndexRanges()).parse(this.content);
        }
        this.fragmentsAnalyzer.analyze();
        this.renderNodes.forEach((node) => {
          var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
          if (node instanceof nodes_1.ConditionNode) {
            node.fragment = (_b = (_a2 = node.constructedFrom) === null || _a2 === void 0 ? void 0 : _a2.fragment) !== null && _b !== void 0 ? _b : null;
            node.fragmentPosition = (_d = (_c = node.constructedFrom) === null || _c === void 0 ? void 0 : _c.fragmentPosition) !== null && _d !== void 0 ? _d : nodes_1.FragmentPosition.Unresolved;
          } else if (node instanceof nodes_1.ForElseNode) {
            node.fragment = (_f = (_e = node.constructedFrom) === null || _e === void 0 ? void 0 : _e.fragment) !== null && _f !== void 0 ? _f : null;
            node.fragmentPosition = (_h = (_g = node.constructedFrom) === null || _g === void 0 ? void 0 : _g.fragmentPosition) !== null && _h !== void 0 ? _h : nodes_1.FragmentPosition.Unresolved;
          } else if (node instanceof nodes_1.SwitchStatementNode) {
            node.fragment = (_k = (_j = node.constructedFrom) === null || _j === void 0 ? void 0 : _j.fragment) !== null && _k !== void 0 ? _k : null;
            node.fragmentPosition = (_m = (_l = node.constructedFrom) === null || _l === void 0 ? void 0 : _l.fragmentPosition) !== null && _m !== void 0 ? _m : nodes_1.FragmentPosition.Unresolved;
          }
        });
        directiveStack_1.DirectiveStack.setChildTypeCounts(this.nodes);
        return this.renderNodes;
      }
      getNodeIndexRanges() {
        const indexRanges = [];
        this.nodes.forEach((node) => {
          var _a2, _b, _c, _d;
          if (node instanceof nodes_1.LiteralNode == false) {
            indexRanges.push({
              start: (_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0,
              end: (_d = (_c = node.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0
            });
          }
        });
        return indexRanges;
      }
      createChildDocuments(renderNodes) {
        renderNodes.forEach((node) => {
          var _a2, _b, _c, _d, _e, _f, _g, _h;
          if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
            const isClosedBy = node.isClosedBy, docStart = ((_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.index) !== null && _b !== void 0 ? _b : 0) - 1, docLength = ((_d = (_c = isClosedBy.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) - docStart;
            node.nodeContent = this.content.substr(docStart, docLength);
            const startOffset = (_f = (_e = node.endPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0, length = ((_h = (_g = isClosedBy.startPosition) === null || _g === void 0 ? void 0 : _g.index) !== null && _h !== void 0 ? _h : 0) - 1 - startOffset, childText = this.content.substr(startOffset, length);
            node.childrenDocument = bladeDocument_1.BladeDocument.childFromText(childText, this, (0, helpers_1.getStartPosition)(node.getChildren()));
          }
        });
      }
      checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
          this.cur = null;
          this.prev = null;
          this.next = null;
          return;
        }
        const curChunk = Math.ceil(this.currentIndex / 5);
        if (curChunk > 0) {
          this.currentChunkOffset = this.parsingOffset + this.chunkSize * curChunk;
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          if (this.currentIndex + 1 < this.chars.length) {
            this.next = this.chars[this.currentIndex + 1];
          }
        }
      }
      parseIntermediateText(offset) {
        this.currentContent = [];
        this.chars = this.content.substring(offset).split("");
        this.charLen = this.chars.length;
        let parsedNode = false;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.isStartingShorthandPhp()) {
            this.scanToEndOfPhp(this.currentIndex, true);
            this.currentIndex += 2;
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
            this.currentContent = [];
            break;
          }
          if (this.isStartingPhp()) {
            this.scanToEndOfPhp(this.currentIndex);
            this.currentIndex += 2;
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
            this.currentContent = [];
            break;
          }
          if (this.isStartingDirective()) {
            this.currentIndex += 1;
            this.scanToEndOfDirective();
            this.currentContent = [];
            this.currentIndex += 1;
            parsedNode = true;
            break;
          }
          if (this.isStartingClosingComponentTag()) {
            const componentTagStartedOn = this.currentIndex;
            this.currentIndex += 4;
            this.currentContent = [];
            this.checkCurrentOffsets();
            this.isParsingComponent = true;
            this.scanToEndOfComponentTag(componentTagStartedOn, true);
            this.isParsingComponent = false;
            this.currentIndex += 3;
            this.currentContent = [];
            parsedNode = true;
            break;
          }
          if (this.isStartingOpeningComponentTag()) {
            const componentTagStartedOn = this.currentIndex;
            this.currentIndex += 3;
            this.currentContent = [];
            this.checkCurrentOffsets();
            this.isParsingComponent = true;
            this.scanToEndOfComponentTag(componentTagStartedOn, false);
            this.isParsingComponent = false;
            this.currentContent = [];
            this.currentIndex += 3;
            parsedNode = true;
            break;
          }
          if (this.isStartingEscapedEcho()) {
            const escapedEchoStartedOn = this.currentIndex;
            this.currentIndex += 3;
            this.currentContent = [];
            this.checkCurrentOffsets();
            this.scanToEndOfEscapedEcho(escapedEchoStartedOn);
            this.currentContent = [];
            this.currentIndex += 3;
            parsedNode = true;
            break;
          }
          if (this.isStartingBladeNodeStructure()) {
            const peekOne = this.peek(2), peekTwo = this.peek(3);
            if (peekOne == DocumentParser.Punctuation_Minus && peekTwo == DocumentParser.Punctuation_Minus) {
              const commentStartedOn = this.currentIndex;
              this.currentIndex += 4;
              this.currentContent = [];
              this.checkCurrentOffsets();
              this.scanToEndOfComment(commentStartedOn);
              this.currentContent = [];
              this.currentIndex += 4;
              parsedNode = true;
              break;
            } else {
              if (peekOne == DocumentParser.LeftBrace) {
                const echoStartedOn = this.currentIndex;
                this.currentIndex += 3;
                this.scanToEndOfBladeEntitiesEcho(echoStartedOn + 1);
                this.currentContent = [];
                this.currentIndex += 3;
                parsedNode = true;
                break;
              } else {
                const echoStartedOn = this.currentIndex;
                this.currentIndex += 2;
                this.scanToEndOfBladeEcho(echoStartedOn + 1);
                this.currentContent = [];
                this.currentIndex += 2;
                parsedNode = true;
                break;
              }
            }
          }
        }
        return parsedNode;
      }
      peek(count) {
        return this.chars[count];
      }
      peekRelative(count) {
        return this.peek(this.currentIndex + count);
      }
      scanToEndOfPhp(startedOn, isShorthand = false) {
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            (0, skipToEndOfString_1.skipToEndOfString)(this);
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_ForwardSlash) {
            this.shouldIgnoreStructures = true;
            (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
            this.shouldIgnoreStructures = false;
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_Asterisk) {
            this.shouldIgnoreStructures = true;
            (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
            this.shouldIgnoreStructures = false;
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_QuestionMark && this.next == DocumentParser.Punctuation_GreaterThan || this.next == null) {
            let inlinePhp = new nodes_1.InlinePhpNode();
            if (isShorthand) {
              inlinePhp = new nodes_1.ShorthandInlinePhpNode();
            }
            inlinePhp.withParser(this);
            inlinePhp.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
            inlinePhp.endPosition = this.positionFromOffset(this.currentIndex + 1 + this.seedOffset, this.currentIndex + 1 + this.seedOffset);
            const startOffset = inlinePhp.startPosition.index, length = inlinePhp.endPosition.index - inlinePhp.startPosition.index + 1;
            inlinePhp.sourceContent = this.content.substr(startOffset, length);
            this.nodes.push(inlinePhp);
            this.lastNode = inlinePhp;
            break;
          }
        }
      }
      scanToEndOfComponentTag(startedOn, isClosing) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
            hasObservedNewLine = true;
            newlineRecoveryIndex = this.currentIndex;
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
            hasObservedSpace = true;
            spaceRecoveryIndex = this.currentIndex;
          }
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            this.shouldIgnoreStructures = true;
            (0, skipToEndOfString_1.skipToEndOfString)(this);
            this.shouldIgnoreStructures = false;
            continue;
          }
          const isClosingComponent = this.isClosingComponent();
          if (this.hasEncounteredAnotherStructure() || this.next == null && !isClosingComponent) {
            createErrorNode = true;
            if (newlineRecoveryIndex != -1) {
              this.currentIndex = newlineRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
            } else if (spaceRecoveryIndex != -1) {
              this.currentIndex = spaceRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
            }
          }
          if (isClosingComponent || createErrorNode) {
            const tagComponent = new nodes_1.BladeComponentNode();
            tagComponent.withParser(this);
            tagComponent.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
            tagComponent.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
            const startOffset = tagComponent.startPosition.index, length = tagComponent.endPosition.index - tagComponent.startPosition.index + 1, endOffset = startOffset + length;
            tagComponent.sourceContent = this.content.substr(startOffset, length);
            tagComponent.isClosingTag = isClosing;
            tagComponent.isSelfClosing = this.prev == DocumentParser.Punctuation_ForwardSlash;
            tagComponent.offset = {
              start: startOffset,
              end: endOffset,
              length
            };
            let shiftRight = 3;
            if (tagComponent.isSelfClosing) {
              shiftRight += 1;
            }
            tagComponent.innerContent = this.content.substr(tagComponent.startPosition.index + 3, tagComponent.endPosition.index - tagComponent.startPosition.index - shiftRight);
            if (createErrorNode) {
              tagComponent.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, tagComponent, "Unexpected end of input while parsing component tag", bladeError_1.ErrrorLevel.Error));
            }
            this.componentParser.parse(tagComponent);
            this.currentContent = [];
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
            this.lastNode = tagComponent;
            this.nodes.push(tagComponent);
            break;
          }
        }
      }
      scanToEndOfEscapedEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
            hasObservedNewLine = true;
            newlineRecoveryIndex = this.currentIndex;
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
            hasObservedSpace = true;
            spaceRecoveryIndex = this.currentIndex;
          }
          if (this.hasEncounteredAnotherStructure() || this.next == null) {
            createErrorNode = true;
            if (newlineRecoveryIndex != -1) {
              this.currentIndex = newlineRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
            } else if (spaceRecoveryIndex != -1) {
              this.currentIndex = spaceRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
            }
          }
          if (this.cur == DocumentParser.Punctuation_Exclamation && this.next == DocumentParser.Punctuation_Exclamation && this.peekRelative(2) == DocumentParser.RightBrace || createErrorNode) {
            const echoEnd = this.currentIndex + 2;
            const echoNode = new nodes_1.BladeEscapedEchoNode();
            echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
            echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
            echoNode.withParser(this);
            const startOffset = echoNode.startPosition.index, length = echoNode.endPosition.index - echoNode.startPosition.index + 1, endOffset = startOffset + length;
            echoNode.sourceContent = this.content.substr(startOffset, length);
            echoNode.offset = {
              start: startOffset,
              end: endOffset,
              length
            };
            if (createErrorNode) {
              echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, "Unexpected end of input while parsing echo", bladeError_1.ErrrorLevel.Error));
            }
            echoNode.content = this.currentContent.join("");
            this.currentContent = [];
            this.lastBladeEndIndex = this.currentIndex + 2 + this.seedOffset;
            this.lastNode = echoNode;
            this.nodes.push(echoNode);
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
      }
      scanToEndOfComment(startedOn) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
            hasObservedNewLine = true;
            newlineRecoveryIndex = this.currentIndex;
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
            hasObservedSpace = true;
            spaceRecoveryIndex = this.currentIndex;
          }
          if (this.next == null) {
            createErrorNode = true;
            if (newlineRecoveryIndex != -1) {
              this.currentIndex = newlineRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
            } else if (spaceRecoveryIndex != -1) {
              this.currentIndex = spaceRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
            }
          }
          if (this.cur == DocumentParser.Punctuation_Minus && this.next == DocumentParser.Punctuation_Minus || this.next == null) {
            const peekOne = this.peekRelative(2), peekTwo = this.peekRelative(3);
            if (peekOne == DocumentParser.RightBrace && peekTwo == DocumentParser.RightBrace || this.next == null) {
              const commentEnd = this.currentIndex + 3;
              const comment = new nodes_1.BladeCommentNode();
              comment.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
              comment.endPosition = this.positionFromOffset(commentEnd + this.seedOffset, commentEnd + this.seedOffset);
              comment.innerContentPosition = {
                start: this.positionFromOffset(startedOn + 4 + this.seedOffset, startedOn + 4 + this.seedOffset),
                end: this.positionFromOffset(commentEnd - 4 + this.seedOffset, commentEnd - 4 + this.seedOffset)
              };
              comment.withParser(this);
              const startOffset = comment.startPosition.index, length = comment.endPosition.index - comment.startPosition.index + 1, endOffset = startOffset + length;
              comment.sourceContent = this.content.substr(startOffset, length);
              comment.offset = {
                start: startOffset,
                end: endOffset,
                length
              };
              if (createErrorNode) {
                comment.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_COMMENT, comment, "Unexpected end of input while parsing comment", bladeError_1.ErrrorLevel.Error));
              }
              comment.innerContent = this.content.substr((_c = (_b = (_a2 = comment.innerContentPosition) === null || _a2 === void 0 ? void 0 : _a2.start) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0, ((_f = (_e = (_d = comment.innerContentPosition) === null || _d === void 0 ? void 0 : _d.end) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0) - ((_j = (_h = (_g = comment.innerContentPosition) === null || _g === void 0 ? void 0 : _g.start) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0) + 1);
              this.currentContent = [];
              this.lastBladeEndIndex = this.currentIndex + 3 + this.seedOffset;
              this.lastNode = comment;
              this.nodes.push(comment);
              break;
            } else {
              if (this.cur != null) {
                this.currentContent.push(this.cur);
              }
              continue;
            }
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
      }
      scanToEndOfBladeEntitiesEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
            hasObservedNewLine = true;
            newlineRecoveryIndex = this.currentIndex;
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
            hasObservedSpace = true;
            spaceRecoveryIndex = this.currentIndex;
          }
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            const stringStart = this.cur;
            this.shouldIgnoreStructures = true;
            const results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
            this.shouldIgnoreStructures = false;
            this.currentIndex = results.endedOn;
            this.currentContent.push(stringStart);
            this.currentContent = this.currentContent.concat(results.value.split(""));
            this.currentContent.push(stringStart);
            this.currentIndex = results.endedOn;
            continue;
          }
          if (this.hasEncounteredAnotherStructure() || this.next == null) {
            createErrorNode = true;
            if (newlineRecoveryIndex != -1) {
              this.currentIndex = newlineRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
            } else if (spaceRecoveryIndex != -1) {
              this.currentIndex = spaceRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
            }
          }
          if (this.cur == DocumentParser.RightBrace && this.next == DocumentParser.RightBrace && this.peekRelative(2) == DocumentParser.RightBrace || createErrorNode) {
            const echoEnd = this.currentIndex + 1;
            const echoNode = new nodes_1.BladeEntitiesEchoNode();
            echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
            echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
            echoNode.withParser(this);
            const startOffset = echoNode.startPosition.index - 1, length = echoNode.endPosition.index - echoNode.startPosition.index + 3, endOffset = startOffset + length;
            echoNode.sourceContent = this.content.substr(startOffset, length);
            echoNode.offset = {
              start: startOffset,
              end: endOffset,
              length
            };
            if (createErrorNode) {
              echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, "Unexpected end of input while parsing echo", bladeError_1.ErrrorLevel.Error));
            }
            echoNode.content = this.currentContent.join("");
            this.currentContent = [];
            this.lastBladeEndIndex = this.currentIndex + 2 + this.seedOffset;
            this.lastNode = echoNode;
            this.nodes.push(echoNode);
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
      }
      scanToEndOfBladeEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
            hasObservedNewLine = true;
            newlineRecoveryIndex = this.currentIndex;
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
            hasObservedSpace = true;
            spaceRecoveryIndex = this.currentIndex;
          }
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            const stringStart = this.cur;
            this.shouldIgnoreStructures = true;
            const results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
            this.shouldIgnoreStructures = false;
            this.currentIndex = results.endedOn;
            this.currentContent.push(stringStart);
            this.currentContent = this.currentContent.concat(results.value.split(""));
            this.currentContent.push(stringStart);
            this.currentIndex = results.endedOn;
            continue;
          }
          if (this.hasEncounteredAnotherStructure() || this.next == null) {
            createErrorNode = true;
            if (newlineRecoveryIndex != -1) {
              this.currentIndex = newlineRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
            } else if (spaceRecoveryIndex != -1) {
              this.currentIndex = spaceRecoveryIndex - 2;
              this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
            }
          }
          if (this.cur == DocumentParser.RightBrace && this.next == DocumentParser.RightBrace || createErrorNode) {
            const echoEnd = this.currentIndex + 1;
            const echoNode = new nodes_1.BladeEchoNode();
            echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
            echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
            echoNode.withParser(this);
            const startOffset = echoNode.startPosition.index - 1, length = echoNode.endPosition.index - echoNode.startPosition.index + 2, endOffset = startOffset + length;
            echoNode.sourceContent = this.content.substr(startOffset, length);
            echoNode.offset = {
              start: startOffset,
              end: endOffset,
              length
            };
            if (createErrorNode) {
              echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, "Unexpected end of input while parsing echo", bladeError_1.ErrrorLevel.Error));
            }
            echoNode.content = this.currentContent.join("");
            this.currentContent = [];
            this.lastBladeEndIndex = this.currentIndex + 1 + this.seedOffset;
            this.lastNode = echoNode;
            this.nodes.push(echoNode);
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
      }
      makeDirective(name, nameStartsOn, nameEndsOn) {
        const directive = new nodes_1.DirectiveNode();
        directive.withParser(this);
        if (name == bladeKeywords_1.BladeKeywords.Verbatim) {
          this.isVerbatim = true;
        } else if (name == bladeKeywords_1.BladeKeywords.Php) {
          this.isPhpNode = true;
        } else if (name == bladeKeywords_1.BladeKeywords.EndVerbatim || name == bladeKeywords_1.BladeKeywords.EndPhp) {
          const lastNode = this.nodes[this.nodes.length - 1];
          if (lastNode instanceof nodes_1.LiteralNode) {
            const literal = this.nodes.pop();
            if (this.nodes[this.nodes.length - 1] instanceof nodes_1.DirectiveNode) {
              const openNode = this.nodes[this.nodes.length - 1];
              if (openNode.directiveName == bladeKeywords_1.BladeKeywords.Verbatim || openNode.directiveName == bladeKeywords_1.BladeKeywords.Php) {
                openNode.innerContent = literal.content;
              }
            }
          }
        }
        directive.directiveName = name.trim();
        directive.name = name.trim();
        const lowerName = directive.name.toLowerCase();
        if (lowerName == "endcan" || lowerName == "endcannot" || lowerName == "endauth" || lowerName == "endguest" || lowerName == "endenv" || lowerName == "endproduction") {
          directive.name = "if";
          directive.isClosingDirective = true;
        } else if (name.startsWith("end")) {
          directive.name = name.substring(3);
        } else if (name.startsWith("else") && name != "elseif" && name != "else") {
          directive.name = "elseif";
        }
        const nameStartPosition = this.positionFromOffset(this.seedOffset + nameStartsOn, this.seedOffset + nameStartsOn), nameEndPosition = this.positionFromOffset(this.seedOffset + nameEndsOn, this.seedOffset + nameEndsOn);
        directive.startPosition = nameStartPosition;
        directive.endPosition = nameEndPosition;
        directive.namePosition = {
          start: nameStartPosition,
          end: nameEndPosition
        };
        directive.hasDirectiveParameters = false;
        if (directive.startPosition != null && directive.endPosition != null) {
          const startOffset = directive.startPosition.index - 1, length = directive.endPosition.index - directive.startPosition.index + 1, endOffset = startOffset + length;
          directive.sourceContent = this.content.substr(startOffset, length);
          directive.offset = {
            start: startOffset,
            end: endOffset,
            length
          };
        }
        return directive;
      }
      makeDirectiveWithParameters(name, nameStartsOn, nameEndsOn, params) {
        var _a2, _b;
        const directive = this.makeDirective(name.trim(), nameStartsOn, nameEndsOn);
        if (this.isPhpNode && name == bladeKeywords_1.BladeKeywords.Php) {
          this.isPhpNode = false;
        }
        directive.hasDirectiveParameters = true;
        directive.directiveParameters = params.content;
        let checkParams = params.content.trim();
        if (checkParams.startsWith("(") && checkParams.endsWith(")")) {
          checkParams = checkParams.substring(1);
          checkParams = checkParams.substring(0, checkParams.length - 1);
          checkParams = checkParams.trim();
          directive.hasJsonParameters = checkParams.startsWith("{") && checkParams.endsWith("}");
        }
        const directiveParamtersStartPosition = this.positionFromOffset(params.start, params.start), directiveParametersEndPosition = this.positionFromOffset(params.end, params.end);
        directive.startPosition = (_b = (_a2 = directive.namePosition) === null || _a2 === void 0 ? void 0 : _a2.start) !== null && _b !== void 0 ? _b : null;
        directive.endPosition = directiveParametersEndPosition;
        directive.directiveParametersPosition = {
          start: directiveParamtersStartPosition,
          end: directiveParametersEndPosition
        };
        if (directive.startPosition != null && directive.endPosition != null) {
          const startOffset = directive.startPosition.index - 1, length = directive.endPosition.index - directive.startPosition.index + 1, endOffset = startOffset + length;
          directive.sourceContent = this.content.substr(startOffset, length);
          directive.offset = {
            start: startOffset,
            end: endOffset,
            length
          };
        }
        return directive;
      }
      scanToEndOfDirective() {
        const directiveNameStartsOn = this.currentIndex;
        let directiveName = "", directiveNameEndsOn = 0;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_Asterisk) {
            this.shouldIgnoreStructures = true;
            (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
            this.shouldIgnoreStructures = false;
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_ForwardSlash) {
            this.shouldIgnoreStructures = true;
            (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
            this.shouldIgnoreStructures = false;
            continue;
          }
          if (this.cur == DocumentParser.NewLine) {
            directiveNameEndsOn = this.currentIndex;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
            this.lastNode = directive;
            this.nodes.push(directive);
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset - 1;
            break;
          } else if (this.next == null) {
            this.currentContent.push(this.cur);
            directiveNameEndsOn = this.currentIndex + 1;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
            this.lastNode = directive;
            this.nodes.push(directive);
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
            break;
          }
          const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
          if (this.cur != DocumentParser.LeftParen && nextNonWs.didFind && stringUtilities_1.StringUtilities.ctypePunct(nextNonWs.char)) {
            if (nextNonWs.char != DocumentParser.LeftParen && nextNonWs.char != DocumentParser.Punctuation_Minus) {
              let endOffset = 0, brokeOnWhiteSpace = false;
              if (!stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                this.currentContent.push(this.cur);
              } else {
                endOffset = 1;
                brokeOnWhiteSpace = true;
              }
              directiveNameEndsOn = this.currentIndex + 1;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn - endOffset);
              this.lastNode = directive;
              this.nodes.push(directive);
              this.lastBladeEndIndex = this.currentIndex + this.seedOffset - endOffset;
              if (brokeOnWhiteSpace) {
                this.currentIndex -= 1;
              }
              break;
            }
          }
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
            const nextNonWs2 = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
            if (nextNonWs2.didFind && nextNonWs2.char == DocumentParser.LeftParen) {
              directiveNameEndsOn = this.currentIndex - 1;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              this.currentIndex = nextNonWs2.index;
              this.checkCurrentOffsets();
              const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this), directive = this.makeDirectiveWithParameters(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
              this.lastNode = directive;
              this.nodes.push(directive);
              this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
              break;
            } else {
              directiveNameEndsOn = this.currentIndex;
              directiveName = this.currentContent.join("");
              this.currentContent = [];
              const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
              this.lastNode = directive;
              this.nodes.push(directive);
              this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
              break;
            }
          } else if (this.cur == DocumentParser.LeftParen) {
            directiveNameEndsOn = this.currentIndex - 1;
            directiveName = this.currentContent.join("");
            this.currentContent = [];
            const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this), directive = this.makeDirectiveWithParameters(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
            this.lastNode = directive;
            this.nodes.push(directive);
            this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
            break;
          }
          if (this.cur == null) {
            break;
          }
          this.currentContent.push(this.cur);
        }
      }
      getText(start, end) {
        return this.content.substr(start, end - start);
      }
      getNodeText(nodes) {
        let text = "";
        nodes.forEach((node) => {
          if (node instanceof nodes_1.LiteralNode) {
            text += node.content;
          } else {
            if (node instanceof nodes_1.ForElseNode) {
              text += node.nodeContent;
            } else if (node instanceof nodes_1.SwitchStatementNode) {
              text += node.nodeContent;
            } else if (node instanceof nodes_1.ConditionNode) {
              text += node.nodeContent;
            } else {
              text += node.sourceContent;
            }
          }
        });
        return text;
      }
      getNodes() {
        return this.nodes;
      }
      getNodesBetween(start, end) {
        const returnNodes = [];
        this.nodes.forEach((node) => {
          var _a2, _b, _c, _d;
          if (((_b = (_a2 = node.startPosition) === null || _a2 === void 0 ? void 0 : _a2.offset) !== null && _b !== void 0 ? _b : 0) > start.offset && ((_d = (_c = node.endPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0) < end.offset) {
            returnNodes.push(node);
          }
        });
        return returnNodes;
      }
      getRenderNodes() {
        return this.renderNodes;
      }
      prepareLiteralContent(content) {
        return content;
      }
      positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
          if (this.documentOffsets.size == 0) {
            lineToUse = 1;
            charToUse = offset + 1;
          } else {
            let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
            for (const documentOffset of this.documentOffsets.keys()) {
              if (documentOffset >= offset) {
                if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                  nearestOffset = lastOffset;
                  nearestOffsetIndex = lastOffsetIndex;
                } else {
                  nearestOffset = this.documentOffsets.get(documentOffset);
                  nearestOffsetIndex = documentOffset;
                }
                break;
              }
              lastOffset = this.documentOffsets.get(documentOffset);
              lastOffsetIndex = documentOffset;
            }
            if (nearestOffset == null) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            }
            if (nearestOffset != null) {
              if (isRelativeOffset) {
                const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              } else {
                const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              }
            } else {
              if (this.lastDocumentOffsetKey != null) {
                const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
                lineToUse = lastOffset2.line + 1;
                charToUse = offset + this.lastDocumentOffsetKey;
              }
            }
          }
        } else {
          const offsetDetails = this.documentOffsets.get(offset);
          lineToUse = offsetDetails.line;
          charToUse = offsetDetails.char;
        }
        const position = new position_1.Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
      }
    };
    exports.DocumentParser = DocumentParser;
    DocumentParser.K_CHAR = "char";
    DocumentParser.K_LINE = "line";
    DocumentParser.NewLine = "\n";
    DocumentParser.AtChar = "@";
    DocumentParser.Punctuation_Colon = ":";
    DocumentParser.Punctuation_QuestionMark = "?";
    DocumentParser.LeftParen = "(";
    DocumentParser.RightParen = ")";
    DocumentParser.LeftBrace = "{";
    DocumentParser.RightBrace = "}";
    DocumentParser.String_Terminator_DoubleQuote = '"';
    DocumentParser.String_Terminator_SingleQuote = "'";
    DocumentParser.Punctuation_LessThan = "<";
    DocumentParser.Punctuation_GreaterThan = ">";
    DocumentParser.Punctuation_Equals = "=";
    DocumentParser.Punctuation_Exclamation = "!";
    DocumentParser.LeftBracket = "[";
    DocumentParser.RightBracket = "]";
    DocumentParser.Punctuation_Comma = ",";
    DocumentParser.Punctuation_Minus = "-";
    DocumentParser.Punctuation_Asterisk = "*";
    DocumentParser.Punctuation_ForwardSlash = "/";
    DocumentParser.Punctuation_Underscore = "_";
    DocumentParser.String_EscapeCharacter = "\\";
  }
});

// node_modules/stillat-blade-parser/out/document/scanners/nodeQueries.js
var require_nodeQueries = __commonJS({
  "node_modules/stillat-blade-parser/out/document/scanners/nodeQueries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeQueries = void 0;
    var nodes_1 = require_nodes();
    var NodeQueries = class {
      static findNodeAfterPosition(position, nodes) {
        if (position == null) {
          return null;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              return node;
            }
          }
        }
        return null;
      }
      static findNodeBeforePosition(position, nodes) {
        if (position == null) {
          return null;
        }
        let lastNode = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              break;
            }
            lastNode = node;
          }
        }
        return lastNode;
      }
      static findNodeAtPosition(position, nodes) {
        if (position == null) {
          return null;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null && node.endPosition != null) {
            if (position.index >= node.startPosition.index && position.index <= node.endPosition.index) {
              return node;
            }
          }
        }
        return null;
      }
      static isLiteralType(node) {
        if (node instanceof nodes_1.LiteralNode) {
          return true;
        }
        return false;
      }
      static findNodesBeforePosition(position, nodes) {
        const beforeNodes = [];
        if (position == null) {
          return beforeNodes;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null && node.endPosition != null) {
            if (node.startPosition.index > position.index) {
              break;
            }
            beforeNodes.push(node);
          }
        }
        return beforeNodes;
      }
      static findNodesAfterPosition(position, nodes) {
        const afterNodes = [];
        if (position == null) {
          return afterNodes;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              afterNodes.push(node);
            }
          }
        }
        return afterNodes;
      }
    };
    exports.NodeQueries = NodeQueries;
  }
});

// node_modules/stillat-blade-parser/out/document/documentCursor.js
var require_documentCursor = __commonJS({
  "node_modules/stillat-blade-parser/out/document/documentCursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentCursor = void 0;
    var nodeQueries_1 = require_nodeQueries();
    var DocumentCursor = class {
      constructor(doc) {
        this.doc = doc;
      }
      getNodeAt(line, char) {
        return nodeQueries_1.NodeQueries.findNodeAtPosition(this.position(line, char), this.doc.getParser().getNodes());
      }
      getNodeBefore(line, char) {
        return nodeQueries_1.NodeQueries.findNodeBeforePosition(this.position(line, char), this.doc.getParser().getNodes());
      }
      getNodeAfter(line, char) {
        return nodeQueries_1.NodeQueries.findNodeAfterPosition(this.position(line, char), this.doc.getParser().getNodes());
      }
      getNodesBefore(line, char) {
        return nodeQueries_1.NodeQueries.findNodesBeforePosition(this.position(line, char), this.doc.getParser().getNodes());
      }
      getNodesAfter(line, char) {
        return nodeQueries_1.NodeQueries.findNodesAfterPosition(this.position(line, char), this.doc.getParser().getNodes());
      }
      position(line, char) {
        return this.doc.getParser().positionFromCursor(line, char);
      }
      charLeftAt(line, char) {
        return this.doc.getParser().charLeftAtCursor(line, char);
      }
      charAt(line, char) {
        return this.doc.getParser().charAtCursor(line, char);
      }
      charRightAt(line, char) {
        return this.doc.getParser().charRightAtCursor(line, char);
      }
      wordLeftAt(line, char, tabSize = 4) {
        return this.doc.getParser().wordLeftAtCursor(line, char, tabSize);
      }
      wordRightAt(line, char, tabSize = 4) {
        return this.doc.getParser().wordRightAtCursor(line, char, tabSize);
      }
      wordAt(line, char, tabSize = 4) {
        return this.doc.getParser().wordAtCursor(line, char, tabSize);
      }
      punctuationLeftAt(line, char, tabSize = 4) {
        return this.doc.getParser().punctuationLeftAtCursor(line, char, tabSize);
      }
      punctuationRightAt(line, char, tabSize = 4) {
        return this.doc.getParser().punctuationRightAtCursor(line, char, tabSize);
      }
    };
    exports.DocumentCursor = DocumentCursor;
  }
});

// node_modules/stillat-blade-parser/out/document/documentErrors.js
var require_documentErrors = __commonJS({
  "node_modules/stillat-blade-parser/out/document/documentErrors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentErrors = void 0;
    var DocumentErrors = class {
      constructor(doc) {
        this.doc = doc;
      }
      hasStructureErrors() {
        return this.doc.getParser().getStructureErrors().length > 0;
      }
      getFirstStructureError() {
        return this.doc.getParser().getStructureErrors()[0];
      }
      hasAny() {
        return this.all().length > 0;
      }
      all() {
        const errorHashes = [], errors = [];
        this.doc.getAllNodes().forEach((node) => {
          node.getErrors().forEach((error) => {
            if (errorHashes.includes(error.hash()) == false) {
              errorHashes.push(error.hash());
              errors.push(error);
            }
          });
        });
        this.doc.getParser().getErrors().forEach((error) => {
          if (errorHashes.includes(error.hash()) == false) {
            errorHashes.push(error.hash());
            errors.push(error);
          }
        });
        return errors;
      }
    };
    exports.DocumentErrors = DocumentErrors;
  }
});

// node_modules/stillat-blade-parser/out/document/scanners/nodeScanner.js
var require_nodeScanner = __commonJS({
  "node_modules/stillat-blade-parser/out/document/scanners/nodeScanner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeScanner = void 0;
    var nodes_1 = require_nodes();
    var nodeQueries_1 = require_nodeQueries();
    var NodeScanner = class {
      constructor(doc) {
        this.doc = doc;
      }
      firstDirectiveOfType(name) {
        const nodes = this.doc.getAllNodes();
        for (let i = 0; i < nodes.length; i++) {
          const thisNode = nodes[i];
          if (thisNode instanceof nodes_1.DirectiveNode && thisNode.directiveName == name) {
            return thisNode;
          }
        }
        return null;
      }
      getNodeAt(position) {
        return nodeQueries_1.NodeQueries.findNodeAtPosition(position, this.doc.getParser().getNodes());
      }
      getNodesBefore(position) {
        return nodeQueries_1.NodeQueries.findNodesBeforePosition(position, this.doc.getParser().getNodes());
      }
      getNodeBefore(position) {
        return nodeQueries_1.NodeQueries.findNodeBeforePosition(position, this.doc.getParser().getNodes());
      }
      getNodeAfter(position) {
        return nodeQueries_1.NodeQueries.findNodeAfterPosition(position, this.doc.getParser().getNodes());
      }
      getNodesAfter(position) {
        return nodeQueries_1.NodeQueries.findNodesAfterPosition(position, this.doc.getParser().getNodes());
      }
      filter(predicate) {
        return this.doc.getParser().getNodes().filter(predicate);
      }
      getComments() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof nodes_1.BladeCommentNode) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      /**
       * Retrieves all literal and escaped content nodes in the document.
       */
      getAllLiteralNodes() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof nodes_1.LiteralNode) {
            nodes.push(node);
          }
        });
        return nodes;
      }
    };
    exports.NodeScanner = NodeScanner;
  }
});

// node_modules/stillat-blade-parser/out/parser/simpleArrayParser.js
var require_simpleArrayParser = __commonJS({
  "node_modules/stillat-blade-parser/out/parser/simpleArrayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleArrayParser = void 0;
    var nodes_1 = require_nodes();
    var stringUtilities_1 = require_stringUtilities();
    var documentParser_1 = require_documentParser();
    var isStartOfString_1 = require_isStartOfString();
    var skipToEndOfString_1 = require_skipToEndOfString();
    var SimpleArrayParser = class {
      constructor() {
        this.content = "";
        this.chars = [];
        this.inputLen = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.currentIndex = 0;
        this.currentContent = [];
        this.tokens = [];
        this.createdArrays = [];
      }
      updateIndex(index) {
        this.currentIndex = index;
      }
      inputLength() {
        return this.inputLen;
      }
      getCurrentIndex() {
        return this.currentIndex;
      }
      incrementIndex() {
        this.currentIndex += 1;
      }
      getCurrent() {
        return this.cur;
      }
      getNext() {
        return this.next;
      }
      getPrev() {
        return this.prev;
      }
      checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          this.next = this.chars[this.currentIndex + 1];
        }
      }
      pushChar(value) {
        this.currentContent.push(value);
      }
      getChar(index) {
        return this.chars[index];
      }
      getSeedOffset() {
        return 0;
      }
      getContentSubstring(from, length) {
        return this.content.substr(from, length);
      }
      checkCurrentContent() {
        if (this.currentContent.length > 0) {
          const value = this.currentContent.join(""), valueNode = new nodes_1.AbstractNode();
          if (value.trim().length == 0) {
            this.currentContent = [];
            return;
          }
          valueNode.sourceContent = value;
          this.tokens.push(valueNode);
          this.currentContent = [];
        }
      }
      parse(text) {
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(text);
        this.chars = this.content.split("");
        this.inputLen = this.chars.length;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
            continue;
          }
          if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
            const terminator = this.cur, results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
            this.pushChar(terminator);
            this.currentContent = this.currentContent.concat(results.value.split(""));
            this.pushChar(terminator);
            this.currentIndex = results.endedOn;
            continue;
          }
          if (this.cur == documentParser_1.DocumentParser.LeftBracket) {
            this.checkCurrentContent();
            this.tokens.push(new nodes_1.ArrayStartNode());
            continue;
          } else if (this.cur == documentParser_1.DocumentParser.RightBracket) {
            this.checkCurrentContent();
            this.tokens.push(new nodes_1.ArrayEndNode());
          } else if (this.cur == documentParser_1.DocumentParser.Punctuation_Comma) {
            this.checkCurrentContent();
            this.tokens.push(new nodes_1.ArrayElementSeparatorNode());
            this.currentContent = [];
          } else if (this.cur == documentParser_1.DocumentParser.Punctuation_Equals && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
            this.checkCurrentContent();
            this.currentIndex += 1;
            this.tokens.push(new nodes_1.ArrayKeyValueNode());
            continue;
          } else {
            this.currentContent.push(this.cur);
          }
        }
        const array = this.parseArrays(this.tokens);
        this.fillArrayDetails();
        return array;
      }
      fillArrayDetails() {
        this.createdArrays.forEach((array) => {
          array.elements.forEach((element, index) => {
            if (element.key != null) {
              array.containsKeys = true;
              if (element.key.sourceContent.length > array.maxKeyLength) {
                array.maxKeyLength = element.key.sourceContent.length;
              }
            }
            element.isLast = index == array.elements.length - 1;
          });
        });
      }
      parseArrays(tokens) {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (token instanceof nodes_1.ArrayStartNode) {
            const arrayNodes = this.findEndOfArray(tokens.slice(i));
            i += arrayNodes.length;
            arrayNodes.shift();
            arrayNodes.pop();
            return this.createArray(arrayNodes);
          }
        }
        return null;
      }
      createArray(tokens) {
        const returnArray = new nodes_1.ArrayNode();
        this.createdArrays.push(returnArray);
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          let nextToken = null;
          if (i + 1 < tokens.length) {
            nextToken = tokens[i + 1];
          }
          if (nextToken instanceof nodes_1.ArrayElementSeparatorNode || nextToken == null) {
            const element = new nodes_1.ArrayElementNode();
            element.value = token;
            returnArray.elements.push(element);
            i += 1;
            continue;
          } else if (nextToken instanceof nodes_1.ArrayKeyValueNode) {
            const valueNode = tokens[i + 2];
            if (valueNode instanceof nodes_1.ArrayStartNode == false) {
              const element = new nodes_1.ArrayElementNode();
              element.key = token;
              element.value = valueNode;
              returnArray.elements.push(element);
              i += 3;
              continue;
            } else {
              const arrayNodes = this.findEndOfArray(tokens.slice(i + 2)), element = new nodes_1.ArrayElementNode();
              i += arrayNodes.length + 1;
              arrayNodes.shift();
              arrayNodes.pop();
              element.key = token;
              element.value = this.createArray(arrayNodes);
              returnArray.elements.push(element);
              continue;
            }
          } else if (token instanceof nodes_1.ArrayStartNode) {
            const arrayNodes = this.findEndOfArray(tokens.slice(i)), element = new nodes_1.ArrayElementNode();
            i += arrayNodes.length;
            arrayNodes.shift();
            arrayNodes.pop();
            element.value = this.createArray(arrayNodes);
            continue;
          }
        }
        return returnArray;
      }
      findEndOfArray(tokens) {
        const arrayTokens = [];
        let stackCount = 0;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          arrayTokens.push(token);
          if (token instanceof nodes_1.ArrayStartNode) {
            stackCount += 1;
            continue;
          } else if (token instanceof nodes_1.ArrayEndNode) {
            stackCount -= 1;
            if (stackCount <= 0) {
              break;
            }
            continue;
          }
        }
        return arrayTokens;
      }
    };
    exports.SimpleArrayParser = SimpleArrayParser;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/stringBuffer.js
var require_stringBuffer = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/stringBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringBuffer = void 0;
    var StringBuffer = class {
      constructor(tabSize, activeLevel) {
        this.tabSize = 0;
        this.content = "";
        this.activeIndentLevel = 0;
        this.tabSize = tabSize;
        this.activeIndentLevel = activeLevel;
      }
      appendNoRepeat(text) {
        if (this.content.trimEnd().endsWith(text) == false) {
          return this.append(text);
        }
        return this;
      }
      append(text) {
        this.content += text;
        return this;
      }
      getContents() {
        return this.content;
      }
      newLine() {
        this.content += "\n";
        return this;
      }
      indent() {
        this.content += " ".repeat(this.tabSize * this.activeIndentLevel);
        return this;
      }
      outdent() {
        let target = this.activeIndentLevel - 1;
        if (target < 1) {
          target = 1;
        }
        this.content += " ".repeat(this.tabSize * target);
        return this;
      }
    };
    exports.StringBuffer = StringBuffer;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/arrayPrinter.js
var require_arrayPrinter = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/arrayPrinter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayPrinter = void 0;
    var nodes_1 = require_nodes();
    var stringBuffer_1 = require_stringBuffer();
    var ArrayPrinter = class {
      static print(array, tabSize, level) {
        const arrayBuffer = new stringBuffer_1.StringBuffer(tabSize, level);
        arrayBuffer.append("[").newLine();
        if (array.elements.length > 0) {
          let trailingWs = "";
          arrayBuffer.indent();
          array.elements.forEach((element) => {
            if (array.maxKeyLength > 0 && element.key != null) {
              trailingWs = " ".repeat(array.maxKeyLength - element.key.sourceContent.length);
            }
            if (element.key != null) {
              arrayBuffer.append(element.key.sourceContent + trailingWs).append(" => ");
              if (element.value != null) {
                if (element.value instanceof nodes_1.ArrayNode) {
                  arrayBuffer.append(ArrayPrinter.print(element.value, tabSize, level + 1));
                } else {
                  arrayBuffer.append(element.value.sourceContent);
                }
              }
            } else {
              if (element.value != null) {
                if (element.value instanceof nodes_1.ArrayNode) {
                  arrayBuffer.append(ArrayPrinter.print(element.value, tabSize, level + 1));
                } else {
                  arrayBuffer.append(element.value.sourceContent);
                }
              }
            }
            arrayBuffer.appendNoRepeat(",").newLine();
            if (!element.isLast) {
              arrayBuffer.indent();
            }
          });
        }
        if (level > 1) {
          arrayBuffer.outdent();
        }
        arrayBuffer.append("]");
        return arrayBuffer.getContents();
      }
    };
    exports.ArrayPrinter = ArrayPrinter;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/commentPrinter.js
var require_commentPrinter = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/commentPrinter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommentPrinter = void 0;
    var stringUtilities_1 = require_stringUtilities();
    var CommentPrinter = class {
      static printComment(comment, tabSize, targetIndent) {
        if (comment.isMultiline()) {
          const lines = stringUtilities_1.StringUtilities.breakByNewLine(comment.innerContent.trim()), reflowedLines = [];
          lines.forEach((line) => {
            reflowedLines.push(" ".repeat(tabSize + targetIndent) + line.trim());
          });
          const content = reflowedLines.join("\n");
          let newComment = "{{--\n";
          newComment += content;
          newComment += "\n" + " ".repeat(targetIndent) + "--}}";
          return newComment;
        }
        return "{{-- " + comment.innerContent.trim() + " --}}";
      }
    };
    exports.CommentPrinter = CommentPrinter;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/directivePrinter.js
var require_directivePrinter = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/directivePrinter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectivePrinter = void 0;
    var stringUtilities_1 = require_stringUtilities();
    var DirectivePrinter = class {
      static printDirective(directive, options, phpFormatter, jsonFormatter) {
        let result = "@" + directive.directiveName.trim();
        if (directive.hasDirectiveParameters) {
          let paramContent = directive.directiveParameters;
          if (!directive.hasJsonParameters) {
            if (options.formatDirectivePhpParameters && phpFormatter != null && directive.hasValidPhp()) {
              let params = directive.getPhpContent().trim();
              if (params.startsWith("(") && params.endsWith(")")) {
                params = params.substring(1);
                params = params.substring(0, params.length - 1);
              }
              let tResult = phpFormatter("<?php " + params);
              tResult = stringUtilities_1.StringUtilities.replaceAllInString(tResult, "\n", " ");
              if (directive.directiveName.toLowerCase() == "forelse") {
                tResult = tResult.substring(9);
                tResult = tResult.substring(0, tResult.length - 14);
              }
              paramContent = "(" + tResult + ")";
            }
          } else {
            if (options.formatDirectiveJsonParameters && jsonFormatter && directive.hasValidJson()) {
              let params = directive.getPhpContent().trim();
              if (params.startsWith("(") && params.endsWith(")")) {
                params = params.substring(1);
                params = params.substring(0, params.length - 1);
              }
              const tResult = jsonFormatter(params);
              paramContent = "(" + tResult + ")";
            }
          }
          result += " ".repeat(options.spacesAfterDirective) + paramContent;
        }
        return result;
      }
    };
    exports.DirectivePrinter = DirectivePrinter;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/echoPrinter.js
var require_echoPrinter = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/echoPrinter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EchoPrinter = void 0;
    var nodes_1 = require_nodes();
    var stringUtilities_1 = require_stringUtilities();
    var EchoPrinter = class {
      static printEcho(echo, phpFormatter) {
        let start = "{{ ", end = " }}";
        if (echo instanceof nodes_1.BladeEscapedEchoNode) {
          start = "{!! ";
          end = " !!}";
        } else if (echo instanceof nodes_1.BladeEntitiesEchoNode) {
          start = "{{{ ";
          end = " }}}";
        }
        let result = start;
        let innerContent = echo.content.trim();
        if (phpFormatter != null && echo.hasValidPhp()) {
          let tResult = phpFormatter("<?php " + innerContent);
          tResult = stringUtilities_1.StringUtilities.replaceAllInString(tResult, "\n", " ");
          innerContent = tResult;
        }
        result += innerContent + end;
        return result;
      }
    };
    exports.EchoPrinter = EchoPrinter;
  }
});

// node_modules/stillat-blade-parser/out/document/printers/indentLevel.js
var require_indentLevel = __commonJS({
  "node_modules/stillat-blade-parser/out/document/printers/indentLevel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndentLevel = void 0;
    var stringUtilities_1 = require_stringUtilities();
    var IndentLevel = class {
      static indentRelative(value, targetIndent) {
        const sourceLines = stringUtilities_1.StringUtilities.breakByNewLine(value);
        let reflowedLines = [];
        for (let i = 0; i < sourceLines.length; i++) {
          const thisLine = sourceLines[i];
          if (thisLine.trim().length > 0) {
            reflowedLines = sourceLines.slice(i);
            break;
          }
        }
        for (let i = reflowedLines.length - 1; i >= 0; i--) {
          const thisLine = reflowedLines[i];
          if (thisLine.trim().length == 0) {
            reflowedLines.pop();
          } else {
            break;
          }
        }
        let leastIndentChange = -1;
        let thatLine = "";
        for (let i = 0; i < reflowedLines.length; i++) {
          const thisLine = reflowedLines[i], checkLine = thisLine.trimLeft(), wsDiff = thisLine.length - checkLine.length;
          if (i == 0) {
            leastIndentChange = wsDiff;
            thatLine = thisLine;
          } else {
            if (wsDiff < leastIndentChange) {
              leastIndentChange = wsDiff;
              thatLine = thisLine;
            }
          }
        }
        if (leastIndentChange >= 0) {
          const targetWs = " ".repeat(targetIndent);
          for (let i = 0; i < reflowedLines.length; i++) {
            const thisLine = reflowedLines[i];
            if (thisLine.trim().length == 0) {
              reflowedLines[i] = "";
              continue;
            }
            const reflowed = thisLine.substring(leastIndentChange);
            if (i == 0) {
              reflowedLines[i] = thisLine.trimLeft();
              continue;
            } else {
              reflowedLines[i] = targetWs + reflowed;
            }
          }
        }
        return reflowedLines.join("\n");
      }
      static shiftIndent(value, targetIndent, skipFirst = false) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value.trim()), reflowedLines = [];
        for (let i = 0; i < lines.length; i++) {
          if (i == 0 && skipFirst) {
            reflowedLines.push(lines[i]);
            continue;
          }
          const line = lines[i];
          reflowedLines.push(" ".repeat(targetIndent) + line);
        }
        return reflowedLines.join("\n");
      }
      static shiftClean(value, indent) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value), reflowedLines = [], pad = " ".repeat(indent);
        let hasFoundContent = false;
        lines.forEach((line) => {
          if (line.trim().length > 0) {
            hasFoundContent = true;
          }
          if (!hasFoundContent) {
            return;
          }
          reflowedLines.push(pad + line);
        });
        return reflowedLines.join("\n");
      }
      static inferIndentLevel(structureLines, value, defaultIndent) {
        let targetLevel = 0, targetLevelFoundOn = -1;
        for (let i = 0; i < structureLines.length; i++) {
          const thisLine = structureLines[i];
          if (thisLine.includes(value)) {
            const trimmed = thisLine.trimLeft();
            targetLevel = thisLine.length - trimmed.length;
            targetLevelFoundOn = i;
            break;
          }
        }
        if (targetLevelFoundOn > 0) {
          for (let i = targetLevelFoundOn - 1; i >= 0; i--) {
            const thisLine = structureLines[i], trimmed = thisLine.trim(), trimmedLeft = thisLine.trimLeft(), checkLevel = thisLine.length - trimmed.length;
            if (trimmedLeft.length == 0) {
              continue;
            }
            if (checkLevel != targetLevel && checkLevel < targetLevel) {
              const inferred = targetLevel - checkLevel;
              return {
                targetLevel,
                referenceLevel: checkLevel,
                sourceTabSize: inferred
              };
            }
          }
        }
        return {
          targetLevel,
          referenceLevel: targetLevel,
          sourceTabSize: defaultIndent
        };
      }
      static indent(structureLines, value, defaultIndent) {
        const levels = IndentLevel.inferIndentLevel(structureLines, value, defaultIndent);
        return " ".repeat(levels.targetLevel);
      }
    };
    exports.IndentLevel = IndentLevel;
  }
});

// node_modules/stillat-blade-parser/out/document/transformer.js
var require_transformer = __commonJS({
  "node_modules/stillat-blade-parser/out/document/transformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transformer = void 0;
    var nodes_1 = require_nodes();
    var simpleArrayParser_1 = require_simpleArrayParser();
    var stringUtilities_1 = require_stringUtilities();
    var bladeDocument_1 = require_bladeDocument();
    var arrayPrinter_1 = require_arrayPrinter();
    var commentPrinter_1 = require_commentPrinter();
    var directivePrinter_1 = require_directivePrinter();
    var echoPrinter_1 = require_echoPrinter();
    var indentLevel_1 = require_indentLevel();
    var Transformer = class {
      constructor(doc) {
        this.inlineDirectiveBlocks = /* @__PURE__ */ new Map();
        this.contentDirectives = /* @__PURE__ */ new Map();
        this.dynamicEchoBlocks = /* @__PURE__ */ new Map();
        this.pairedDirectives = /* @__PURE__ */ new Map();
        this.dynamicInlineDirectives = /* @__PURE__ */ new Map();
        this.inlineDirectives = /* @__PURE__ */ new Map();
        this.inlineEchos = /* @__PURE__ */ new Map();
        this.spanEchos = /* @__PURE__ */ new Map();
        this.inlinePhpNodes = /* @__PURE__ */ new Map();
        this.echoBlockSlugs = /* @__PURE__ */ new Map();
        this.parentTransformer = null;
        this.forElseWithEmpty = [];
        this.forElseNoEmpty = [];
        this.conditions = [];
        this.switchStatements = [];
        this.removeLines = [];
        this.virtualStructureOpens = [];
        this.virtualStructureClose = [];
        this.inlineComments = /* @__PURE__ */ new Map();
        this.blockComments = [];
        this.blockPhpNodes = /* @__PURE__ */ new Map();
        this.breakDirectives = /* @__PURE__ */ new Map();
        this.dynamicElementDirectives = /* @__PURE__ */ new Map();
        this.dynamicElementDirectiveNodes = /* @__PURE__ */ new Map();
        this.dynamicElementConditions = /* @__PURE__ */ new Map();
        this.dynamicElementConditionNodes = /* @__PURE__ */ new Map();
        this.dynamicElementSwitch = /* @__PURE__ */ new Map();
        this.dynamicElementSwitchNodes = /* @__PURE__ */ new Map();
        this.dynamicElementForElse = /* @__PURE__ */ new Map();
        this.dynamicElementForElseNodes = /* @__PURE__ */ new Map();
        this.dynamicElementPhpNodes = /* @__PURE__ */ new Map();
        this.dynamicElementPhp = /* @__PURE__ */ new Map();
        this.embeddedEchos = /* @__PURE__ */ new Map();
        this.embeddedDirectives = /* @__PURE__ */ new Map();
        this.structureLines = [];
        this.directiveParameters = /* @__PURE__ */ new Map();
        this.expressionParameters = /* @__PURE__ */ new Map();
        this.slugs = [];
        this.extractedEmbeddedDocuments = /* @__PURE__ */ new Map();
        this.propDirectives = /* @__PURE__ */ new Map();
        this.phpFormatter = null;
        this.blockPhpFormatter = null;
        this.phpTagFormatter = null;
        this.jsonFormatter = null;
        this.transformOptions = {
          spacesAfterDirective: 0,
          tabSize: 4,
          formatDirectiveJsonParameters: true,
          formatDirectivePhpParameters: true
        };
        this.forceCleanLines = [
          "@endphp",
          "@elseif",
          "@else",
          "@endif",
          "@endswitch",
          "@endverbatim",
          "@case",
          "@default"
        ];
        this.doc = doc;
      }
      setParentTransformer(transformer) {
        this.parentTransformer = transformer;
        return this;
      }
      withJsonFormatter(formatter) {
        this.jsonFormatter = formatter;
        return this;
      }
      withBlockPhpFormatter(formatter) {
        this.blockPhpFormatter = formatter;
        return this;
      }
      withPhpTagFormatter(formatter) {
        this.phpTagFormatter = formatter;
        return this;
      }
      withPhpFormatter(formatter) {
        this.phpFormatter = formatter;
        return this;
      }
      /**
       * Returns a document with Blade removed.
       * @returns string
       */
      removeBlade() {
        const allNodes = this.doc.getAllNodes();
        let text = "";
        allNodes.forEach((node) => {
          if (node instanceof nodes_1.LiteralNode) {
            text += node.getOutputContent();
          } else if (node instanceof nodes_1.InlinePhpNode) {
            text += node.sourceContent;
          } else if (node instanceof nodes_1.DirectiveNode && node.directiveName == "verbatim") {
            text += node.innerContent;
          }
        });
        return text;
      }
      close(value) {
        return "</" + value + ">";
      }
      open(value) {
        return "<" + value + ">";
      }
      selfClosing(value) {
        return "<" + value + " />";
      }
      pair(value, innerContent = "") {
        return "<" + value + ">" + innerContent + "</" + value + ">";
      }
      printDirective(directive) {
        return directivePrinter_1.DirectivePrinter.printDirective(directive, this.transformOptions, this.phpFormatter, this.jsonFormatter);
      }
      makeSlug(length) {
        if (length <= 2) {
          length = 7;
        }
        let result = "";
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", charactersLength = characters.length;
        for (let i = 0; i < length - 1; i++) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        const slug = "B" + result + "B";
        if (this.slugs.includes(slug)) {
          return this.makeSlug(length + 1);
        }
        this.slugs.push(slug);
        return slug;
      }
      registerDirectiveParameter(slug, param) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerDirectiveParameter(slug, param);
        } else {
          this.directiveParameters.set(slug, param);
        }
      }
      registerExpressionParameter(slug, param) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerExpressionParameter(slug, param);
        } else {
          this.expressionParameters.set(slug, param);
        }
      }
      registerCondition(transformedCondition) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerCondition(transformedCondition);
        } else {
          this.conditions.push(transformedCondition);
        }
      }
      registerSwitchStatement(transformedSwitch) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerSwitchStatement(transformedSwitch);
        } else {
          this.switchStatements.push(transformedSwitch);
        }
      }
      registerPairedDirective(slug, directive) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerPairedDirective(slug, directive);
        } else {
          if (directive.isInline == false) {
            this.pairedDirectives.set(slug, directive);
          } else {
            this.inlineDirectives.set(directive.slug, directive);
            this.dynamicInlineDirectives.set(directive.directive.nodeContent, directive.slug);
          }
        }
      }
      registerInlineDirectiveBlock(slug, directive) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerInlineDirectiveBlock(slug, directive);
        } else {
          this.inlineDirectiveBlocks.set(slug, directive);
        }
      }
      registerContentDirective(slug, directive) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerContentDirective(slug, directive);
        } else {
          this.contentDirectives.set(slug, directive);
        }
      }
      registerComment(slug, comment) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerComment(slug, comment);
        } else {
          this.inlineComments.set(slug, comment);
        }
      }
      registerDynamicDirective(slug, directive) {
        if (this.parentTransformer != null) {
          this.dynamicElementDirectives.set(directive.nodeContent, slug);
          this.parentTransformer.registerDynamicDirective(slug, directive);
        } else {
          this.dynamicElementDirectives.set(directive.nodeContent, slug);
          this.dynamicElementDirectiveNodes.set(slug, directive);
        }
      }
      prepareConditionalDirective(directive) {
        if (this.dynamicElementDirectives.has(directive.nodeContent)) {
          return this.dynamicElementDirectives.get(directive.nodeContent);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.registerDynamicDirective(slug, directive);
        return slug;
      }
      prepareInlineBlockDirective(directive) {
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerInlineDirectiveBlock(slug, directive);
        return this.selfClosing(slug);
      }
      prepareContentDirective(directive) {
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerContentDirective(slug, directive);
        return slug;
      }
      registerPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerPhpBlock(slug, php);
        } else {
          this.removeLines.push(this.close(slug));
          this.blockPhpNodes.set(slug, php);
        }
      }
      registerConditionalPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
          this.dynamicElementPhp.set(php.sourceContent, slug);
          this.parentTransformer.registerConditionalPhpBlock(slug, php);
        } else {
          this.dynamicElementPhp.set(php.sourceContent, slug);
          this.dynamicElementPhpNodes.set(slug, php);
        }
      }
      prepareConditionalPhpBlock(php) {
        if (this.dynamicElementPhp.has(php.sourceContent)) {
          return this.dynamicElementPhp.get(php.sourceContent);
        }
        const slug = this.makeSlug(php.sourceContent.length);
        this.registerConditionalPhpBlock(slug, php);
        return slug;
      }
      registerInlinePhpBlock(php) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerInlinePhpBlock(php);
        } else {
          const slug = this.makeSlug(php.sourceContent.length);
          this.inlinePhpNodes.set(slug, php);
          return slug;
        }
      }
      prepareInlinePhpBlock(php) {
        return this.registerInlinePhpBlock(php);
      }
      preparePhpBlock(php) {
        if (php.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
          return this.prepareConditionalPhpBlock(php);
        }
        if (php.isInline) {
          return this.prepareInlinePhpBlock(php);
        }
        const slug = this.makeSlug(35);
        this.registerPhpBlock(slug, php);
        const open = this.open(slug), close = this.close(slug);
        return "\n" + open + close + "\n";
      }
      transformPhpBlock(content) {
        let value = content;
        this.blockPhpNodes.forEach((php, slug) => {
          const open = this.open(slug), targetIndent = this.indentLevel(open);
          let result = php.sourceContent;
          if (this.phpTagFormatter != null && php.hasValidPhp()) {
            result = this.phpTagFormatter(result);
            result = indentLevel_1.IndentLevel.shiftIndent(result, targetIndent, true);
          }
          value = value.replace(open, result);
        });
        this.dynamicElementPhpNodes.forEach((php, slug) => {
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, this.printInlinePhp(php));
        });
        this.inlinePhpNodes.forEach((php, slug) => {
          value = value.replace(slug, this.printInlinePhp(php));
        });
        return value;
      }
      printInlinePhp(php) {
        let phpContent = php.sourceContent;
        if (this.phpTagFormatter && php.hasValidPhp()) {
          phpContent = this.phpTagFormatter(phpContent);
          phpContent = stringUtilities_1.StringUtilities.replaceAllInString(phpContent, "\n", " ");
        }
        return phpContent;
      }
      shouldCreateVirutal(directive) {
        const children = directive.getImmediateChildren();
        if (children.length == 0) {
          return true;
        }
        let allEchosInline = true, allLiteralsWhitespace = true, inlineEchos = 0, bladeCount = 0, literalCount = 0, createVirtual = true;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child instanceof nodes_1.BladeEchoNode && child.isInlineEcho) {
            allEchosInline = false;
            inlineEchos += 1;
            bladeCount += 1;
          } else if (child instanceof nodes_1.LiteralNode) {
            literalCount += 1;
            if (child.content.trim().length > 0) {
              allLiteralsWhitespace = false;
            }
          } else {
            bladeCount += 1;
          }
        }
        if (inlineEchos == 0) {
          createVirtual = true;
        }
        if (bladeCount > 0 && allEchosInline == true) {
          return false;
        }
        if (allLiteralsWhitespace == false && bladeCount == 0) {
          createVirtual = true;
        }
        if (allLiteralsWhitespace == true && bladeCount == 0) {
          createVirtual = true;
        }
        return createVirtual;
      }
      preparePairedDirective(directive) {
        var _a2;
        const slug = this.makeSlug(directive.sourceContent.length), directiveName = directive.directiveName.toLowerCase(), innerDoc = (_a2 = directive.childrenDocument) === null || _a2 === void 0 ? void 0 : _a2.document.transform().setParentTransformer(this).toStructure();
        if (directive.fragmentPosition != nodes_1.FragmentPosition.IsDynamicFragmentName) {
          let virtualSlug = "";
          let result = `${this.open(slug)}
`;
          if (directiveName == "php" || directiveName == "verbatim") {
            virtualSlug = this.makeSlug(15);
            result += this.pair(virtualSlug);
          } else {
            if (this.shouldCreateVirutal(directive) && directive.containsChildStructures == false && directive.containsAnyFragments == false) {
              virtualSlug = this.makeSlug(15);
              result += this.pair(virtualSlug, innerDoc);
            } else {
              result += innerDoc;
            }
          }
          result += `${this.close(slug)}
`;
          this.virtualStructureOpens.push(this.open(virtualSlug));
          this.virtualStructureClose.push(this.close(virtualSlug));
          this.virtualStructureClose.push(this.close(slug));
          this.registerPairedDirective(slug, {
            innerDoc,
            slug,
            directive,
            virtualElementSlug: virtualSlug,
            isInline: false
          });
          return result;
        }
        if (this.dynamicInlineDirectives.has(directive.nodeContent)) {
          const existingSlug = this.dynamicInlineDirectives.get(directive.nodeContent);
          return existingSlug + " ";
        }
        const dynamicSlug = this.makeSlug(directive.nodeContent.length);
        this.registerPairedDirective(slug, {
          innerDoc,
          slug: dynamicSlug,
          directive,
          virtualElementSlug: "",
          isInline: true
        });
        return dynamicSlug + " ";
      }
      registerForElseWithEmpty(forElse) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerForElseWithEmpty(forElse);
        } else {
          this.forElseWithEmpty.push(forElse);
        }
      }
      prepareForElse(forElse) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
        if (forElse.fragmentPosition == nodes_1.FragmentPosition.Unresolved || forElse.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
          if (forElse.elseNode != null) {
            const truthSlug = this.makeSlug((_b = (_a2 = forElse.constructedFrom) === null || _a2 === void 0 ? void 0 : _a2.sourceContent.length) !== null && _b !== void 0 ? _b : 0), elseSlug = this.makeSlug((_d = (_c = forElse.elseNode) === null || _c === void 0 ? void 0 : _c.sourceContent.length) !== null && _d !== void 0 ? _d : 0), truthTransform = (_e = forElse.truthDocument) === null || _e === void 0 ? void 0 : _e.document.transform().setParentTransformer(this).toStructure(), falseTransform = (_f = forElse.falseDocument) === null || _f === void 0 ? void 0 : _f.document.transform().setParentTransformer(this).toStructure();
            const repForElse = {
              truthDoc: truthTransform,
              falseDoc: falseTransform,
              forElse,
              truthClose: this.close(truthSlug),
              emptyOpen: this.open(elseSlug),
              pairClose: this.close(elseSlug),
              truthSlug,
              falseSlug: elseSlug
            };
            let result2 = this.open(truthSlug);
            result2 += truthTransform;
            result2 += repForElse.truthClose;
            result2 += "\n" + repForElse.emptyOpen + "\n";
            result2 += falseTransform + "";
            result2 += repForElse.pairClose;
            this.registerForElseWithEmpty(repForElse);
            return result2;
          }
          const construction = forElse.constructedFrom, truthDoc = (_g = forElse.truthDocument) === null || _g === void 0 ? void 0 : _g.document.transform().setParentTransformer(this).toStructure(), openSlug = this.makeSlug(construction.sourceContent.length), closeSlug = this.makeSlug((_j = (_h = construction.isClosedBy) === null || _h === void 0 ? void 0 : _h.sourceContent.length) !== null && _j !== void 0 ? _j : 0);
          const noElseForElse = {
            truthDoc,
            falseDoc: "",
            forElse,
            truthSlug: openSlug,
            falseSlug: "",
            pairClose: this.close(closeSlug),
            emptyOpen: "",
            truthClose: ""
          };
          this.forElseNoEmpty.push(noElseForElse);
          let result = this.open(openSlug);
          result += truthDoc;
          result += this.close(openSlug);
          return result;
        }
        if (this.dynamicElementForElse.has(forElse.nodeContent)) {
          const existingSlug = this.dynamicElementForElse.get(forElse.nodeContent);
          return existingSlug + " ";
        }
        const slug = this.makeSlug(forElse.nodeContent.length);
        this.registerDynamicElementForElse(slug, forElse);
        return slug + " ";
      }
      registerBreak(slug, directive) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerBreak(slug, directive);
        } else {
          this.breakDirectives.set(slug, directive);
        }
      }
      registerProps(slug, directive) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerProps(slug, directive);
        } else {
          this.propDirectives.set(slug, directive);
        }
      }
      preparePropsDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerProps(virtualSlug, directive);
        return `

${this.pair(virtualSlug)}`;
      }
      prepareBreakDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerBreak(virtualSlug, directive);
        return `

${this.pair(virtualSlug)}`;
      }
      registerEmbeddedDirective(directive) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerEmbeddedDirective(directive);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.embeddedDirectives.set(slug, directive);
        return slug;
      }
      registerEmbeddedDocument(slug, content, isScript) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerEmbeddedDocument(slug, content, isScript);
        }
        this.extractedEmbeddedDocuments.set(slug, {
          slug,
          content,
          isScript
        });
        return slug;
      }
      prepareDirective(directive) {
        if (directive.isEmbedded()) {
          return this.registerEmbeddedDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == "break") {
          return this.prepareBreakDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == "props") {
          return this.preparePropsDirective(directive);
        }
        if (directive.isClosedBy != null) {
          return this.preparePairedDirective(directive);
        }
        if (directive.fragmentPosition == nodes_1.FragmentPosition.Unresolved) {
          return this.prepareInlineBlockDirective(directive);
        } else if (directive.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
          return this.prepareConditionalDirective(directive);
        }
        return this.prepareContentDirective(directive);
      }
      registerVirtualComment(structure) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerVirtualComment(structure);
        } else {
          this.blockComments.push(structure);
        }
      }
      prepareComment(comment) {
        if (comment.isMultiline()) {
          const slug2 = this.makeSlug(10), virtualSlug = this.makeSlug(10);
          const virtualStructure = {
            node: comment,
            pairOpen: this.open(slug2),
            pairClose: this.close(slug2),
            virtualElement: this.selfClosing(virtualSlug)
          };
          this.registerVirtualComment(virtualStructure);
          return virtualStructure.pairOpen + "\n" + virtualStructure.virtualElement + "\n" + virtualStructure.pairClose;
        }
        const slug = this.makeSlug(comment.sourceContent.length);
        this.registerComment(slug, comment);
        return this.selfClosing(slug);
      }
      registerDynamicFragmentEcho(echo) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerDynamicFragmentEcho(echo);
        } else {
          if (!this.echoBlockSlugs.has(echo.sourceContent)) {
            const slug = this.makeSlug(echo.sourceContent.length);
            this.dynamicEchoBlocks.set(slug, echo);
            this.echoBlockSlugs.set(echo.sourceContent, slug);
            return slug;
          } else {
            return this.echoBlockSlugs.get(echo.sourceContent);
          }
        }
      }
      registerInlineEcho(echo) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerInlineEcho(echo);
        } else {
          const slug = this.makeSlug(echo.sourceContent.length);
          if (echo.isInlineEcho) {
            this.spanEchos.set(slug, echo);
            return slug;
          } else {
            this.inlineEchos.set(slug, echo);
            return this.selfClosing(slug);
          }
        }
      }
      prepareComponent(component) {
        var _a2, _b;
        if (component.isClosingTag) {
          if (((_a2 = component.name) === null || _a2 === void 0 ? void 0 : _a2.name) == "slot") {
            return "</x-slot>";
          }
          return "</x-" + component.getComponentName() + ">";
        }
        let value = "<x-";
        if (((_b = component.name) === null || _b === void 0 ? void 0 : _b.name) == "slot" && component.isSelfClosing == false) {
          if (component.name.inlineName.trim().length > 0) {
            let slotName = component.name.inlineName;
            if (slotName.startsWith(":")) {
              slotName = slotName.substring(1);
            }
            value += 'slot name="' + slotName + '"';
          } else {
            value += component.getComponentName();
          }
        } else {
          value += component.getComponentName();
        }
        if (component.hasParameters) {
          value += " ";
          component.parameters.forEach((param) => {
            var _a3, _b2;
            if (param.type == nodes_1.ParameterType.Parameter) {
              if (param.isExpression) {
                const expressionSlug = this.makeSlug(param.content.length);
                this.registerExpressionParameter(expressionSlug, param);
                value += expressionSlug + " ";
              } else {
                value += param.content + " ";
              }
            } else if (param.type == nodes_1.ParameterType.Attribute) {
              value += param.name + " ";
            } else if (param.type == nodes_1.ParameterType.Directive) {
              const directiveSlug = this.makeSlug((_b2 = (_a3 = param.directive) === null || _a3 === void 0 ? void 0 : _a3.sourceContent.length) !== null && _b2 !== void 0 ? _b2 : 0);
              this.registerDirectiveParameter(directiveSlug, param);
              value += directiveSlug + " ";
            }
          });
        }
        if (component.isSelfClosing) {
          value += " />";
        } else {
          value += ">";
        }
        return value;
      }
      registerEmbeddedEcho(echo) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerEmbeddedEcho(echo);
        }
        const slug = this.makeSlug(echo.sourceContent.length);
        this.embeddedEchos.set(slug, echo);
        return slug;
      }
      prepareEcho(echo) {
        if (echo.isEmbedded()) {
          return this.registerEmbeddedEcho(echo);
        }
        if (echo.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
          return this.registerDynamicFragmentEcho(echo);
        } else if (echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragment || echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragmentParameter) {
          return this.registerDynamicFragmentEcho(echo);
        }
        return this.registerInlineEcho(echo);
      }
      prepareSwitch(switchNode) {
        if (switchNode.fragmentPosition == nodes_1.FragmentPosition.Unresolved || switchNode.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
          const tCases = [];
          let result = "";
          switchNode.cases.forEach((caseNode, index) => {
            var _a2, _b;
            const directive = caseNode.head, innerDoc = (_a2 = caseNode.childDocument) === null || _a2 === void 0 ? void 0 : _a2.document.transform().setParentTransformer(this).toStructure();
            const openSlug = this.makeSlug(directive.sourceContent.length);
            const virtualOpen = this.makeSlug(5);
            const tCase = {
              case: caseNode,
              slug: openSlug,
              doc: innerDoc,
              virtualOpen: this.selfClosing(virtualOpen),
              virtualClose: this.close(virtualOpen),
              pairOpen: this.open(openSlug),
              pairClose: this.close(openSlug),
              isFirst: index == 0,
              isLast: index == switchNode.cases.length - 1,
              leadingClose: "",
              leadingOpen: ""
            };
            if (caseNode.leadingDocument != null) {
              const leadingSlug = this.makeSlug(25);
              tCase.leadingOpen = this.open(leadingSlug);
              tCase.leadingClose = this.close(leadingSlug);
              result += "\n" + caseNode.leadingDocument.document.transform().setParentTransformer(this).toStructure() + "\n";
            }
            result += tCase.pairOpen;
            if (((_b = caseNode.head) === null || _b === void 0 ? void 0 : _b.directiveName) == "default") {
              result += tCase.virtualOpen;
            }
            result += innerDoc;
            result += tCase.pairClose;
            tCases.push(tCase);
          });
          const pairOpen = tCases[0].pairOpen, pairClose = tCases[tCases.length - 1].pairClose;
          const virtualSwitchSlug = this.makeSlug(10), virtualSwitchOpen = this.open(virtualSwitchSlug), virtualSwitchClose = this.close(virtualSwitchSlug);
          const tSwitch = {
            switchNode,
            pairOpen,
            pairClose,
            structures: tCases,
            virtualSwitchClose,
            virtualSwitchOpen
          };
          const virtualStruct = "\n" + virtualSwitchOpen + "\n" + result + "\n" + virtualSwitchClose;
          this.registerSwitchStatement(tSwitch);
          return virtualStruct;
        }
        if (this.dynamicElementSwitch.has(switchNode.nodeContent)) {
          const existingSlug = this.dynamicElementSwitch.get(switchNode.nodeContent);
          return existingSlug + " ";
        }
        const slug = this.makeSlug(switchNode.nodeContent.length);
        this.registerDynamicElementSwitch(slug, switchNode);
        return slug + " ";
      }
      registerDynamicElementSwitch(slug, switchNode) {
        if (this.parentTransformer != null) {
          this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
          this.parentTransformer.registerDynamicElementSwitch(slug, switchNode);
        } else {
          this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
          this.dynamicElementSwitchNodes.set(slug, switchNode);
        }
      }
      registerDynamicElementCondition(slug, condition) {
        if (this.parentTransformer != null) {
          this.dynamicElementConditions.set(condition.nodeContent, slug);
          this.parentTransformer.registerDynamicElementCondition(slug, condition);
        } else {
          this.dynamicElementConditions.set(condition.nodeContent, slug);
          this.dynamicElementConditionNodes.set(slug, condition);
        }
      }
      registerDynamicElementForElse(slug, forElse) {
        if (this.parentTransformer != null) {
          this.dynamicElementForElse.set(forElse.nodeContent, slug);
          this.parentTransformer.registerDynamicElementForElse(slug, forElse);
        } else {
          this.dynamicElementForElse.set(forElse.nodeContent, slug);
          this.dynamicElementForElseNodes.set(slug, forElse);
        }
      }
      prepareConditions(condition) {
        if (condition.fragmentPosition == nodes_1.FragmentPosition.Unresolved || condition.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
          if (condition.chain.length == 1 && condition.constructedFrom != null) {
            const construction = condition.constructedFrom.clone();
            construction.childrenDocument = condition.logicBranches[0].childDocument;
            return this.preparePairedDirective(construction);
          }
          const transformedBranches = [];
          let result = "";
          condition.logicBranches.forEach((branch, index) => {
            var _a2, _b, _c, _d;
            const directive = branch.head, innerDoc = (_a2 = branch.childDocument) === null || _a2 === void 0 ? void 0 : _a2.document.transform().setParentTransformer(this).toStructure();
            const openSlug = this.makeSlug(directive.sourceContent.length), virtualSlug = this.makeSlug(10);
            const tBranch = {
              branch,
              slug: openSlug,
              doc: innerDoc,
              pairOpen: this.open(openSlug),
              pairClose: this.close(openSlug),
              virtualOpen: this.open(virtualSlug),
              virtualClose: this.close(virtualSlug),
              isFirst: index == 0,
              isLast: index == condition.logicBranches.length - 1,
              virtualBreakClose: "",
              virtualBreakOpen: ""
            };
            if (((_b = branch.head) === null || _b === void 0 ? void 0 : _b.directiveName) == "else") {
              result += "\n" + tBranch.pairOpen;
              const virtualBreakSlug = this.makeSlug(25);
              if (branch.head.containsChildStructures == false && branch.head.containsAnyFragments == false) {
                tBranch.virtualBreakOpen = this.open(virtualBreakSlug);
                tBranch.virtualBreakClose = this.close(virtualBreakSlug);
                result += "\n" + tBranch.virtualBreakOpen + "\n";
                result += innerDoc;
                result += "\n" + tBranch.virtualBreakClose + "\n" + tBranch.pairClose;
              } else {
                tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                result += tBranch.virtualBreakOpen + "\n";
                result += innerDoc;
                result += "\n" + tBranch.pairClose;
              }
            } else {
              if (((_c = branch.head) === null || _c === void 0 ? void 0 : _c.containsAnyFragments) == false && ((_d = branch.head) === null || _d === void 0 ? void 0 : _d.containsChildStructures) == false) {
                const ifBreakSlug = this.makeSlug(25);
                tBranch.virtualBreakOpen = this.open(ifBreakSlug);
                tBranch.virtualBreakClose = this.close(ifBreakSlug);
                result += tBranch.pairOpen;
                result += "\n" + tBranch.virtualBreakOpen;
                result += innerDoc;
                result += "\n" + tBranch.virtualBreakClose;
                result += tBranch.pairClose;
              } else {
                result += tBranch.pairOpen;
                result += "\n";
                result += innerDoc;
                result += "\n";
                result += tBranch.pairClose;
              }
            }
            transformedBranches.push(tBranch);
          });
          const pairOpen = transformedBranches[0].pairOpen, pairClose = transformedBranches[transformedBranches.length - 1].pairClose;
          const tCond = {
            pairOpen,
            pairClose,
            structures: transformedBranches,
            condition
          };
          this.registerCondition(tCond);
          return result;
        }
        if (this.dynamicElementConditions.has(condition.nodeContent)) {
          const existingSlug = this.dynamicElementConditions.get(condition.nodeContent);
          return existingSlug + " ";
        }
        const slug = this.makeSlug(condition.nodeContent.length);
        this.registerDynamicElementCondition(slug, condition);
        return slug + " ";
      }
      toStructure() {
        let result = "";
        this.doc.getRenderNodes().forEach((node) => {
          if (node instanceof nodes_1.LiteralNode) {
            result += node.content;
          } else if (node instanceof nodes_1.SwitchStatementNode) {
            if (node.cases.length > 0) {
              result += this.prepareSwitch(node);
            } else {
              result += this.preparePairedDirective(node.constructedFrom);
            }
          } else if (node instanceof nodes_1.ConditionNode) {
            result += this.prepareConditions(node);
          } else if (node instanceof nodes_1.DirectiveNode) {
            result += this.prepareDirective(node);
          } else if (node instanceof nodes_1.BladeEchoNode) {
            result += this.prepareEcho(node);
          } else if (node instanceof nodes_1.ForElseNode) {
            result += this.prepareForElse(node);
          } else if (node instanceof nodes_1.BladeCommentNode) {
            result += this.prepareComment(node);
          } else if (node instanceof nodes_1.BladeComponentNode) {
            result += this.prepareComponent(node);
          } else if (node instanceof nodes_1.InlinePhpNode) {
            result += this.preparePhpBlock(node);
          }
        });
        const structures = this.doc.getParser().getFragmentsContainingStructures();
        if (structures.length > 0) {
          const referenceDocument = bladeDocument_1.BladeDocument.fromText(result);
          structures.forEach((pair) => {
            var _a2, _b, _c, _d, _e, _f, _g, _h;
            const ref = this.doc.getParser().getText(((_b = (_a2 = pair.start.endPosition) === null || _a2 === void 0 ? void 0 : _a2.offset) !== null && _b !== void 0 ? _b : 0) + 1, (_d = (_c = pair.end.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0), refOpen = referenceDocument.getParser().getFragmentsParser().getEmbeddedFragment(pair.start.embeddedIndex), refClose = referenceDocument.getParser().getFragmentsParser().getClosingFragmentAfter(refOpen), curRef = referenceDocument.getParser().getText(((_f = (_e = refOpen.endPosition) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0) + 1, (_h = (_g = refClose === null || refClose === void 0 ? void 0 : refClose.startPosition) === null || _g === void 0 ? void 0 : _g.offset) !== null && _h !== void 0 ? _h : 0), refSlug = this.makeSlug(16), isScript = pair.start.name.toLowerCase() == "script";
            let replaceSlug = refSlug;
            if (isScript) {
              replaceSlug = "//" + refSlug;
            } else {
              replaceSlug = "/*" + refSlug + "*/";
            }
            result = result.replace(curRef, replaceSlug);
            this.registerEmbeddedDocument(refSlug, ref, isScript);
          });
        }
        return result;
      }
      withOptions(options) {
        this.transformOptions = options;
        return this;
      }
      transformInlineDirectives(content) {
        let value = content;
        this.inlineDirectiveBlocks.forEach((directive, slug) => {
          const search = this.selfClosing(slug), replace = this.printDirective(directive);
          value = value.replace(search, replace);
        });
        return value;
      }
      transformContentDirectives(content) {
        let value = content;
        this.contentDirectives.forEach((directive, slug) => {
          value = value.replace(slug, this.printDirective(directive));
        });
        return value;
      }
      transformDynamicEcho(content) {
        let value = content;
        this.dynamicEchoBlocks.forEach((echo, slug) => {
          const echoContent = echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter);
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, echoContent);
        });
        return value;
      }
      transformDynamicDirectives(content) {
        let value = content;
        this.dynamicElementDirectiveNodes.forEach((directive, slug) => {
          const directiveContent = this.printDirective(directive);
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, directiveContent);
        });
        return value;
      }
      transformBlockPhp(content, withNewLine) {
        if (this.blockPhpFormatter == null) {
          return content;
        }
        let value = content.trim();
        if (value.startsWith("<?php") == false) {
          value = "<?php " + value;
        }
        value = this.blockPhpFormatter(value);
        if (withNewLine) {
          value = "\n" + value + "\n";
        }
        return value;
      }
      transformPairedDirectives(content) {
        let value = content;
        this.pairedDirectives.forEach((directive, slug) => {
          var _a2;
          const originalDirective = directive.directive;
          if (directive.virtualElementSlug.length > 0) {
            const open2 = this.open(directive.virtualElementSlug), close2 = this.close(directive.virtualElementSlug);
            this.virtualStructureOpens.push(open2);
            this.removeLines.push(open2);
            this.removeLines.push(close2);
          }
          const open = this.open(slug), close = this.close(slug);
          if (originalDirective.directiveName.trim().toLowerCase() == "php") {
            const virtualOpen = this.open(directive.virtualElementSlug), targetIndent = this.indentLevel(virtualOpen), replacePhp = directive.directive.sourceContent;
            const formattedPhp = indentLevel_1.IndentLevel.shiftIndent(this.transformBlockPhp(originalDirective.innerContent, true), targetIndent, true);
            value = value.replace(open, replacePhp);
            value = value.replace(virtualOpen, formattedPhp);
          } else if (originalDirective.directiveName.trim().toLowerCase() == "verbatim") {
            const replaceVerbatim = directive.directive.sourceContent + "\n" + indentLevel_1.IndentLevel.shiftClean(originalDirective.innerContent, this.transformOptions.tabSize);
            value = value.replace(open, replaceVerbatim);
          } else {
            value = value.replace(open, this.printDirective(directive.directive));
          }
          value = value.replace(close, (_a2 = directive.directive.isClosedBy) === null || _a2 === void 0 ? void 0 : _a2.sourceContent);
        });
        this.inlineDirectives.forEach((directive, slug) => {
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, directive.directive.nodeContent);
        });
        return value;
      }
      transformForElseWithNoEmpty(content) {
        let value = content;
        this.forElseNoEmpty.forEach((forElse) => {
          var _a2;
          const construction = forElse.forElse.constructedFrom, open = this.open(forElse.truthSlug), close = this.close(forElse.truthSlug), openContent = this.printDirective(construction), closeContent = (_a2 = construction.isClosedBy) === null || _a2 === void 0 ? void 0 : _a2.sourceContent;
          value = value.replace(open, openContent);
          value = value.replace(close, closeContent);
        });
        return value;
      }
      transformForElseWithEmpty(content) {
        let value = content;
        this.forElseWithEmpty.forEach((forElse) => {
          var _a2, _b;
          const truthOpen = this.open(forElse.truthSlug), construction = forElse.forElse.constructedFrom, constructionContent = this.printDirective(construction);
          value = value.replace(truthOpen, constructionContent);
          value = value.replace(forElse.pairClose, (_a2 = construction.isClosedBy) === null || _a2 === void 0 ? void 0 : _a2.sourceContent);
          value = value.replace(forElse.emptyOpen, (_b = forElse.forElse.elseNode) === null || _b === void 0 ? void 0 : _b.sourceContent);
          this.removeLines.push(forElse.truthClose);
        });
        return value;
      }
      transformInlineEcho(content) {
        let value = content;
        this.inlineEchos.forEach((echo, slug) => {
          const inline = this.selfClosing(slug);
          value = value.replace(inline, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        this.spanEchos.forEach((echo, slug) => {
          value = value.replace(slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        return value;
      }
      transformConditions(content) {
        let value = content;
        this.conditions.forEach((condition) => {
          condition.structures.forEach((structure) => {
            const structureDirective = structure.branch.head;
            if (structure.virtualBreakOpen.length > 0) {
              this.removeLines.push(structure.virtualBreakOpen);
            }
            if (structure.virtualBreakClose.length > 0) {
              value = value.replace(structure.virtualBreakClose, structure.virtualBreakClose + "\n");
              this.removeLines.push(structure.virtualBreakClose);
            }
            this.virtualStructureOpens.push(structure.virtualOpen);
            this.removeLines.push(structure.virtualOpen);
            this.removeLines.push(structure.virtualClose);
            if (!structure.isLast) {
              this.removeLines.push(structure.pairClose);
              value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
            } else {
              value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
              const closeDirective = structureDirective.isClosedBy;
              value = value.replace(structure.pairClose, this.printDirective(closeDirective));
            }
          });
        });
        return value;
      }
      transformSwitchStatements(content) {
        let value = content;
        this.switchStatements.forEach((switchStatement) => {
          const open = switchStatement.switchNode.constructedFrom;
          value = value.replace(switchStatement.virtualSwitchOpen, this.printDirective(open));
          const closeDirective = open.isClosedBy;
          value = value.replace(switchStatement.virtualSwitchClose, closeDirective.sourceContent);
          switchStatement.structures.forEach((structure) => {
            const structureDirective = structure.case.head;
            this.removeLines.push(structure.virtualClose);
            this.removeLines.push(structure.virtualOpen);
            if (!structure.isLast) {
              if (structure.isFirst) {
                this.removeLines.push(structure.pairClose);
                value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
              } else {
                this.removeLines.push(structure.pairClose);
                value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
              }
            } else {
              value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
              this.removeLines.push(structure.pairClose);
            }
          });
        });
        return value;
      }
      transformProps(content) {
        let value = content;
        this.propDirectives.forEach((directive, slug) => {
          const close = this.close(slug), open = this.open(slug);
          this.removeLines.push(close);
          let content2 = directive.sourceContent;
          try {
            if (this.transformOptions.formatDirectivePhpParameters && this.phpFormatter != null && directive.hasValidPhp()) {
              let params = directive.getPhpContent().trim();
              if (params.startsWith("(") && params.endsWith(")")) {
                params = params.substring(1);
                params = params.substring(0, params.length - 1);
              }
              let tResult = this.phpFormatter("<?php " + params);
              tResult = stringUtilities_1.StringUtilities.replaceAllInString(tResult, "\n", " ");
              const arrayParser = new simpleArrayParser_1.SimpleArrayParser(), array = arrayParser.parse(tResult), targetIndent = this.indentLevel(open);
              if (array != null) {
                tResult = arrayPrinter_1.ArrayPrinter.print(array, this.transformOptions.tabSize, 1);
                if (targetIndent > 0) {
                  tResult = stringUtilities_1.StringUtilities.removeEmptyNewLines(indentLevel_1.IndentLevel.shiftIndent(tResult, targetIndent, true));
                }
                content2 = "@props" + " ".repeat(this.transformOptions.spacesAfterDirective) + "(" + tResult + ")";
              }
            }
          } catch (err) {
            content2 = directive.sourceContent;
          }
          value = value.replace(open, content2);
        });
        return value;
      }
      transformBreaks(content) {
        let value = content;
        this.breakDirectives.forEach((directive, slug) => {
          const close = this.close(slug), open = this.open(slug);
          this.removeLines.push(close);
          value = value.replace(open, directive.sourceContent);
        });
        return value;
      }
      transformComments(content) {
        let value = content;
        this.inlineComments.forEach((comment, slug) => {
          const open = this.selfClosing(slug);
          value = value.replace(open, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, 0));
        });
        return value;
      }
      indentLevel(value) {
        for (let i = 0; i < this.structureLines.length; i++) {
          const thisLine = this.structureLines[i];
          if (thisLine.includes(value)) {
            const trimmed = thisLine.trimLeft();
            return thisLine.length - trimmed.length;
          }
        }
        return 0;
      }
      transformVirtualComments(content) {
        let value = content;
        this.blockComments.forEach((structure) => {
          const comment = structure.node;
          value = value.replace(structure.pairOpen, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, this.indentLevel(structure.pairOpen)));
          this.removeLines.push(structure.pairClose);
          this.removeLines.push(structure.virtualElement);
        });
        return value;
      }
      transformDynamicElementForElse(content) {
        let value = content;
        this.dynamicElementForElseNodes.forEach((forElse, slug) => {
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, forElse.nodeContent);
        });
        return value;
      }
      transformDynamicElementConditions(content) {
        let value = content;
        this.dynamicElementConditionNodes.forEach((condition, slug) => {
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, condition.nodeContent);
        });
        return value;
      }
      transformDynamicElementSwitch(content) {
        let value = content;
        this.dynamicElementSwitchNodes.forEach((switchNode, slug) => {
          value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, switchNode.nodeContent);
        });
        return value;
      }
      transformDirectiveParameters(content) {
        let value = content;
        this.directiveParameters.forEach((param, slug) => {
          const paramDirective = param.directive;
          value = value.replace(slug, this.printDirective(paramDirective));
        });
        return value;
      }
      transformExpressionParameters(content) {
        let value = content;
        this.expressionParameters.forEach((param, slug) => {
          value = value.replace(slug, param.content);
        });
        return value;
      }
      transformEmbeddedEcho(content) {
        let value = content;
        this.embeddedEchos.forEach((echo, slug) => {
          value = value.replace(slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        return value;
      }
      transformEmbeddedDirectives(content) {
        let value = content;
        this.embeddedDirectives.forEach((directive, slug) => {
          value = value.replace(slug, this.printDirective(directive));
        });
        return value;
      }
      transformExtractedDocuments(content) {
        let value = content;
        this.extractedEmbeddedDocuments.forEach((document, slug) => {
          let target = "", indent = 0;
          if (document.isScript) {
            target = "//" + slug;
          } else {
            target = "/*" + slug + "*/";
          }
          indent = this.indentLevel(target);
          if (value.includes(target)) {
            value = value.replace(target, indentLevel_1.IndentLevel.indentRelative(document.content, indent));
          }
        });
        return value;
      }
      removeVirtualStructures(content) {
        let value = content;
        this.removeLines.forEach((line) => {
          value = value.replace(line, "");
        });
        return value;
      }
      shouldCleanAfter(line) {
        for (let i = 0; i < this.removeLines.length; i++) {
          if (line.startsWith(this.removeLines[i])) {
            return true;
          }
        }
        return false;
      }
      shouldCleanLine(line) {
        for (let i = 0; i < this.forceCleanLines.length; i++) {
          if (line.startsWith(this.forceCleanLines[i])) {
            return true;
          }
        }
        return false;
      }
      cleanVirtualStructures(content) {
        const newLines = [], contentLines = stringUtilities_1.StringUtilities.breakByNewLine(content);
        let removeNewLines = false;
        for (let i = 0; i < contentLines.length; i++) {
          const checkLine = contentLines[i].trim();
          if (removeNewLines) {
            if (checkLine.length == 0) {
              continue;
            } else {
              removeNewLines = false;
            }
          } else {
            removeNewLines = this.shouldCleanAfter(checkLine);
          }
          if (this.shouldCleanLine(checkLine)) {
            for (let j = newLines.length - 1; j > 0; j--) {
              const tLine = newLines[j];
              if (tLine.trim().length == 0) {
                newLines.pop();
              } else {
                break;
              }
            }
          }
          if (this.removeLines.includes(checkLine)) {
            continue;
          } else {
            let newLine = contentLines[i];
            this.removeLines.forEach((line) => {
              if (newLine.includes(line)) {
                newLine = newLine.replace(line, "");
              }
            });
            newLines.push(newLine);
          }
        }
        return newLines.join("\n");
      }
      reflowSlugs(content) {
        let result = content;
        this.slugs.forEach((slug) => {
          const open = this.open(slug), close = this.close(slug), selfClose = this.selfClosing(slug), openRegex = "/<" + slug + "(.*?)>/gms", closeRegex = "/</" + slug + "(.*?)>/gms", selfCloseRegex = "/<" + slug + "(.*?)/>/gms";
          result = result.replace(openRegex, open);
          result = result.replace(closeRegex, close);
          result = result.replace(selfCloseRegex, selfClose);
        });
        return result;
      }
      fromStructure(content) {
        const reflowedContent = this.reflowSlugs(content);
        this.structureLines = stringUtilities_1.StringUtilities.breakByNewLine(reflowedContent);
        let results = this.transformInlineDirectives(reflowedContent);
        results = this.transformContentDirectives(results);
        results = this.transformDynamicEcho(results);
        results = this.transformPairedDirectives(results);
        results = this.transformForElseWithEmpty(results);
        results = this.transformForElseWithNoEmpty(results);
        results = this.transformDynamicElementForElse(results);
        results = this.transformInlineEcho(results);
        results = this.transformConditions(results);
        results = this.transformDynamicElementConditions(results);
        results = this.transformSwitchStatements(results);
        results = this.transformDynamicElementSwitch(results);
        results = this.transformBreaks(results);
        results = this.transformProps(results);
        results = this.transformComments(results);
        results = this.transformVirtualComments(results);
        results = this.transformDirectiveParameters(results);
        results = this.transformExpressionParameters(results);
        results = this.transformDynamicDirectives(results);
        results = this.cleanVirtualStructures(results);
        results = this.removeVirtualStructures(results);
        results = this.transformEmbeddedEcho(results);
        results = this.transformEmbeddedDirectives(results);
        results = this.transformExtractedDocuments(results);
        results = this.transformPhpBlock(results);
        return results;
      }
    };
    exports.Transformer = Transformer;
  }
});

// node_modules/stillat-blade-parser/out/document/bladeDocument.js
var require_bladeDocument = __commonJS({
  "node_modules/stillat-blade-parser/out/document/bladeDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BladeDocument = void 0;
    var documentParser_1 = require_documentParser();
    var documentCursor_1 = require_documentCursor();
    var documentErrors_1 = require_documentErrors();
    var nodeScanner_1 = require_nodeScanner();
    var transformer_1 = require_transformer();
    var BladeDocument2 = class {
      constructor() {
        this.documentParser = new documentParser_1.DocumentParser();
        this.transformer = null;
        this.cursor = new documentCursor_1.DocumentCursor(this);
        this.nodes = new nodeScanner_1.NodeScanner(this);
        this.errors = new documentErrors_1.DocumentErrors(this);
      }
      static fromText(text, seedPosition = null) {
        const document = new BladeDocument2();
        if (seedPosition != null) {
          document.getParser().setSeedPosition(seedPosition);
        }
        return document.loadString(text);
      }
      static childFromText(text, parentParser, seedPosition = null) {
        const document = new BladeDocument2();
        if (seedPosition != null) {
          document.getParser().setSeedPosition(seedPosition);
        }
        document.getParser().withPhpValidator(parentParser.getPhpValidator());
        document.loadString(text);
        return {
          renderNodes: document.getRenderNodes(),
          content: text,
          document
        };
      }
      isValid() {
        if (this.documentParser.hasUnclosedStructures()) {
          return false;
        }
        return true;
      }
      transform() {
        if (this.transformer == null) {
          this.transformer = new transformer_1.Transformer(this);
        }
        return this.transformer;
      }
      loadString(text) {
        this.documentParser.parse(text);
        return this;
      }
      getLinesAround(line) {
        return this.documentParser.getLinesAround(line);
      }
      getContent() {
        return this.documentParser.getContent();
      }
      getOriginalContent() {
        return this.documentParser.getOriginalContent();
      }
      getAllNodes() {
        return this.documentParser.getNodes();
      }
      getRenderNodes() {
        return this.documentParser.getRenderNodes();
      }
      getFragments() {
        return this.documentParser.getFragments();
      }
      getParser() {
        return this.documentParser;
      }
      getText(start, end) {
        return this.documentParser.getText(start, end);
      }
      charLeftAt(position) {
        return this.documentParser.charLeftAt(position);
      }
      charAt(position) {
        return this.documentParser.charAt(position);
      }
      charRightAt(position) {
        return this.documentParser.charRightAt(position);
      }
      getLineIndex(lineNumber) {
        return this.documentParser.getLineIndex(lineNumber);
      }
      getLineText(lineNumber) {
        return this.documentParser.getLineText(lineNumber);
      }
      wordAt(position, tabSize = 4) {
        return this.documentParser.wordAt(position, tabSize);
      }
      wordLeftAt(position, tabSize = 4) {
        return this.documentParser.wordLeftAt(position, tabSize);
      }
      wordRightAt(position, tabSize = 4) {
        return this.documentParser.wordRightAt(position, tabSize);
      }
      punctuationLeftAt(position, tabSize = 4) {
        return this.documentParser.punctuationLeftAt(position, tabSize);
      }
      punctuationRightAt(position, tabSize = 4) {
        return this.documentParser.punctuationRightAt(position, tabSize);
      }
      getLineChars(lineNumber) {
        const lineText = this.getLineText(lineNumber);
        if (lineText != null) {
          return lineText.split("");
        }
        return null;
      }
    };
    exports.BladeDocument = BladeDocument2;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc21 = require("coc.nvim");

// src/config.ts
var import_coc = require("coc.nvim");
function getConfigBladeEnable() {
  return import_coc.workspace.getConfiguration("blade").get("enable", true);
}
function getConfigBladeFormatterEnable() {
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.enable", true);
}
function getConfigBladeParserLintEnable() {
  return import_coc.workspace.getConfiguration("blade").get("bladeParserLint.enable", true);
}
function getConfigBladeParserLintDebug() {
  return import_coc.workspace.getConfiguration("blade").get("bladeParserLint.debug", false);
}
function getConfigBladeParserLintOptCustomIfs() {
  return import_coc.workspace.getConfiguration("blade").get("bladeParserLint.optCustomIfs", []);
}
function getConfigBladeParserLintOptDirectives() {
  return import_coc.workspace.getConfiguration("blade").get("bladeParserLint.optDirectives", []);
}
function getConfigBladeParserLintOptIgnoreDirectives() {
  return import_coc.workspace.getConfiguration("blade").get("bladeParserLint.optIgnoreDirectives", []);
}
function getConfigBladeCompletionEnable() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enable", true);
}
function getConfigBladeCompletionEnableSnippets() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableSnippets", true);
}
function getConfigBladeCompletionEnableDirective() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableDirective", true);
}
function getConfigBladeCompletionExcludeSnippets() {
  return import_coc.workspace.getConfiguration("blade").get("completion.excludeSnippets", []);
}
function getConfigBladeCompletionEnableLivewireDirectiveComponent() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireDirectiveComponent", true);
}
function getConfigBladeCompletionEnableLivewireTag() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireTag", true);
}
function getConfigBladeCompletionEnableLivewireWire() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireWire", true);
}
function getConfigBladeFormatterOptIndentSize() {
  const defaultValue = 4;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optIndentSize", defaultValue);
}
function getConfigBladeFormatterOptWrapLineLength() {
  const defaultValue = 120;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optWrapLineLength", defaultValue);
}
function getConfigBladeFormatterOptWrapAttributes() {
  const defaultValue = "auto";
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optWrapAttributes", defaultValue);
}
function getConfigBladeFormatterOptEndWithNewLine() {
  const defaultValue = true;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optEndWithNewLine", defaultValue);
}
function getConfigBladeFormatterOptEndOfLine() {
  const defaultValue = null;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optEndOFLine", defaultValue);
}
function getConfigBladeFormatterOptUseTabs() {
  const defaultValue = false;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optUseTabs", defaultValue);
}
function getConfigBladeFormatterOptSortTailwindcssClasses() {
  const defaultValue = false;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optSortTailwindcssClasses", defaultValue);
}
function getConfigBladeFormatterOptSortHtmlAttributes() {
  const defaultValue = "none";
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optSortHtmlAttributes", defaultValue);
}
function getConfigBladeFormatterOptCustomHtmlAttributesOrder() {
  const defaultValue = null;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optCustomHtmlAttributesOrder", defaultValue);
}
function getConfigBladeFormatterOptNoMultipleEmptyLines() {
  const defaultValue = false;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optNoMultipleEmptyLines", defaultValue);
}
function getConfigBladeFormatterOptNoPhpSyntaxCheck() {
  const defaultValue = false;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.noPhpSyntaxCheck", defaultValue);
}

// src/actions/action.ts
var import_coc2 = require("coc.nvim");
async function register(context) {
  const documentSelector = [{ language: "blade", scheme: "file" }];
  context.subscriptions.push(
    import_coc2.languages.registerCodeActionProvider(documentSelector, new BladeCodeActionProvider(), "blade")
  );
}
var BladeCodeActionProvider = class {
  constructor() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async provideCodeActions(document, range, context) {
    const doc = import_coc2.workspace.getDocument(document.uri);
    const codeActions = [];
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-disable-next-line --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-disable-next-line --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-disable-next-line" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-disable --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-disable --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-disable" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-enable --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-enable --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-enable" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.wholeRange(doc, range) || this.cursorRange(range)) {
      const pos = import_coc2.Position.create(0, 0);
      const edit = import_coc2.TextEdit.insert(pos, "{{-- blade-formatter-disable --}}\n");
      codeActions.push({
        title: 'Add "blade-formatter-disable" for whole file',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    return codeActions;
  }
  wholeRange(doc, range) {
    const whole = import_coc2.Range.create(0, 0, doc.lineCount, 0);
    return whole.start.line === range.start.line && whole.start.character === range.start.character && whole.end.line === range.end.line && whole.end.character === whole.end.character;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
  cursorRange(r) {
    return r.start.line === r.end.line && r.start.character === r.end.character;
  }
};

// src/commands/bladeFormatterRun.ts
var import_coc5 = require("coc.nvim");

// src/common.ts
var import_coc3 = require("coc.nvim");
function fullDocumentRange(document) {
  const lastLineId = document.lineCount - 1;
  const doc = import_coc3.workspace.getDocument(document.uri);
  return import_coc3.Range.create({ character: 0, line: 0 }, { character: doc.getline(lastLineId).length, line: lastLineId });
}

// src/engines/bladeFormatter.ts
var import_coc4 = require("coc.nvim");
var import_fs = __toESM(require("fs"));
var import_ignore = __toESM(require_ignore());
var import_path2 = __toESM(require("path"));

// node_modules/synckit/lib/index.js
var import_path = __toESM(require("path"), 1);
var import_worker_threads = require("worker_threads");
var _a;
var { SYNCKIT_BUFFER_SIZE, SYNCKIT_TIMEOUT, SYNCKIT_TS_ESM, SYNCKIT_EXEC_ARV } = process.env;
var TS_USE_ESM = !!SYNCKIT_TS_ESM && ["1", "true"].includes(SYNCKIT_TS_ESM);
var DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE ? +SYNCKIT_BUFFER_SIZE : void 0;
var DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
var DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
var DEFAULT_EXEC_ARGV = (_a = SYNCKIT_EXEC_ARV === null || SYNCKIT_EXEC_ARV === void 0 ? void 0 : SYNCKIT_EXEC_ARV.split(",")) !== null && _a !== void 0 ? _a : [];
var syncFnCache = /* @__PURE__ */ new Map();
function createSyncFn(workerPath, bufferSizeOrOptions, timeout) {
  if (!import_path.default.isAbsolute(workerPath)) {
    throw new Error("`workerPath` must be absolute");
  }
  const cachedSyncFn = syncFnCache.get(workerPath);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  const syncFn = startWorkerThread(workerPath, typeof bufferSizeOrOptions === "number" ? { bufferSize: bufferSizeOrOptions, timeout } : bufferSizeOrOptions);
  syncFnCache.set(workerPath, syncFn);
  return syncFn;
}
var throwError = (msg) => {
  throw new Error(msg);
};
function startWorkerThread(workerPath, { bufferSize = DEFAULT_WORKER_BUFFER_SIZE, timeout = DEFAULT_TIMEOUT, execArgv = DEFAULT_EXEC_ARGV } = {}) {
  const { port1: mainPort, port2: workerPort } = new import_worker_threads.MessageChannel();
  const isTs = workerPath.endsWith(".ts");
  const worker = new import_worker_threads.Worker(isTs ? TS_USE_ESM ? throwError("Native esm in `.ts` file is not supported yet, please use `.cjs` instead") : `require('ts-node/register');require('${workerPath}')` : workerPath, {
    eval: isTs,
    workerData: { workerPort },
    transferList: [workerPort],
    execArgv
  });
  let nextID = 0;
  const syncFn = (...args) => {
    const id = nextID++;
    const sharedBuffer = new SharedArrayBuffer(bufferSize);
    const sharedBufferView = new Int32Array(sharedBuffer);
    const msg = { sharedBuffer, id, args };
    worker.postMessage(msg);
    const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
    if (!["ok", "not-equal"].includes(status)) {
      throw new Error("Internal error: Atomics.wait() failed: " + status);
    }
    const { id: id2, result, error } = (0, import_worker_threads.receiveMessageOnPort)(mainPort).message;
    if (id !== id2) {
      throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
    }
    if (error) {
      throw error;
    }
    return result;
  };
  worker.unref();
  return syncFn;
}

// src/engines/bladeFormatter.ts
async function doFormat(context, outputChannel, document, range) {
  const fileName = import_coc4.Uri.parse(document.uri).fsPath;
  const originalText = document.getText(range);
  if (document.languageId !== "blade") {
    import_coc4.window.showErrorMessage("blade-formatter cannot run, not a blade file");
    return originalText;
  }
  const formatIndentSize = getConfigBladeFormatterOptIndentSize();
  const formatWrapLineLength = getConfigBladeFormatterOptWrapLineLength();
  const formatWrapAttributes = getConfigBladeFormatterOptWrapAttributes();
  const formatEndWithNewLine = getConfigBladeFormatterOptEndWithNewLine();
  const formatEndOFLine = getConfigBladeFormatterOptEndOfLine();
  const formatUseTabs = getConfigBladeFormatterOptUseTabs();
  const formatSortTailwindcssClasses = getConfigBladeFormatterOptSortTailwindcssClasses();
  const formatSortHtmlAttributes = getConfigBladeFormatterOptSortHtmlAttributes();
  const formatNoMultipleEmptyLines = getConfigBladeFormatterOptNoMultipleEmptyLines();
  const formatNoPhpSyntaxCheck = getConfigBladeFormatterOptNoPhpSyntaxCheck();
  const formatCustomHtmlAttributesOrder = getConfigBladeFormatterOptCustomHtmlAttributesOrder();
  const options = {
    indentSize: formatIndentSize,
    wrapAttributes: formatWrapAttributes,
    wrapLineLength: formatWrapLineLength,
    endWithNewline: formatEndWithNewLine,
    endOfLine: formatEndOFLine ? formatEndOFLine : void 0,
    useTabs: formatUseTabs,
    // MEMO: type is ----> sortTailwindcssClasses?: true;
    sortTailwindcssClasses: formatSortTailwindcssClasses ? formatSortTailwindcssClasses : void 0,
    sortHtmlAttributes: formatSortHtmlAttributes,
    customHtmlAttributesOrder: formatCustomHtmlAttributesOrder ? formatCustomHtmlAttributesOrder : void 0,
    noMultipleEmptyLines: formatNoMultipleEmptyLines,
    noPhpSyntaxCheck: formatNoPhpSyntaxCheck
  };
  const cwd = import_coc4.Uri.file(import_coc4.workspace.root).fsPath;
  const opts = { cwd };
  outputChannel.appendLine(`${"#".repeat(10)} blade-formatter
`);
  outputChannel.appendLine(`Cwd: ${opts.cwd}`);
  outputChannel.appendLine(`Option: ${JSON.stringify(options)}`);
  outputChannel.appendLine(`File: ${fileName}`);
  const isIgnoreFile = shouldIgnore(fileName, outputChannel);
  if (isIgnoreFile) {
    import_coc4.window.showWarningMessage(".bladeignore matched file.");
    return originalText;
  }
  return new Promise((resolve) => {
    const workerPath = import_path2.default.join(context.extensionPath, "worker", "index.js");
    const syncFn = createSyncFn(workerPath);
    let newText = "";
    try {
      newText = syncFn(originalText, options);
      outputChannel.appendLine(`
==== OUTPUT ===
`);
      outputChannel.appendLine(`${newText}`);
      outputChannel.appendLine(`== success ==
`);
      resolve(newText);
    } catch (error) {
      import_coc4.window.showWarningMessage(`[blade-formatter]: ${error.message}`);
      outputChannel.appendLine(`
==== ERROR ===
`);
      outputChannel.appendLine(`${error.message}`);
      outputChannel.appendLine(`
==== originalText: ===
`);
      outputChannel.appendLine(`${originalText}`);
      resolve(originalText);
    }
  });
}
function shouldIgnore(filepath, outputChannel) {
  const workspaceRootDir = import_coc4.Uri.file(import_coc4.workspace.root).fsPath;
  const ignoreFilename = ".bladeignore";
  const ignoreFilePath = import_path2.default.join(workspaceRootDir, ignoreFilename);
  if (import_fs.default.existsSync(ignoreFilePath)) {
    const ignoreFileContent = import_fs.default.readFileSync(ignoreFilePath, "utf-8");
    const ig = (0, import_ignore.default)().add(ignoreFileContent);
    try {
      const isMatch = ig.ignores(import_path2.default.relative(workspaceRootDir, filepath));
      if (isMatch)
        outputChannel.appendLine(`IGNORE: matched ${filepath}
`);
      return isMatch;
    } catch (err) {
      return false;
    }
  }
  return false;
}

// src/commands/bladeFormatterRun.ts
async function register2(context, outputChannel) {
  if (getConfigBladeFormatterEnable()) {
    context.subscriptions.push(
      import_coc5.commands.registerCommand("blade.bladeFormatter.run", async () => {
        const doc = await import_coc5.workspace.document;
        const code = await doFormat(context, outputChannel, doc.textDocument, void 0);
        const edits = [import_coc5.TextEdit.replace(fullDocumentRange(doc.textDocument), code)];
        if (edits) {
          await doc.applyEdits(edits);
        }
      })
    );
  }
}

// src/commands/showOutput.ts
var import_coc6 = require("coc.nvim");
async function register3(context, outputChannel) {
  context.subscriptions.push(
    import_coc6.commands.registerCommand("blade.showOutput", () => {
      if (outputChannel) {
        outputChannel.show();
      }
    })
  );
}

// src/completions/completion.ts
var import_coc16 = require("coc.nvim");

// src/completions/provider/bladeDirective.ts
var import_coc7 = require("coc.nvim");
var import_fs2 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
var BladeDirectiveCompletionProvider = class {
  constructor(context) {
    this._context = context;
    this.directiveJsonPaths = [
      import_path3.default.join(this._context.extensionPath, "data", "completion", "blade-directive.json"),
      import_path3.default.join(this._context.extensionPath, "data", "completion", "livewire-directive.json")
    ];
  }
  async getCompletionItems(completionDataPath, text, position) {
    const completionList = [];
    if (import_fs2.default.existsSync(completionDataPath)) {
      const completionJsonText = import_fs2.default.readFileSync(completionDataPath, "utf8");
      const completionJson = JSON.parse(completionJsonText);
      if (completionJson) {
        Object.keys(completionJson).map((key) => {
          const docDataPath = import_path3.default.join(
            this._context.extensionPath,
            "data",
            "documantation",
            "blade",
            key.replace("@", "") + ".md"
          );
          let documentationText;
          try {
            documentationText = import_fs2.default.readFileSync(docDataPath, "utf8");
          } catch (e) {
            documentationText = void 0;
          }
          const edit = {
            range: {
              start: { line: position.line, character: position.character - text.length },
              end: position
            },
            newText: key
          };
          completionList.push({
            label: key,
            kind: import_coc7.CompletionItemKind.Text,
            insertText: key,
            detail: completionJson[key],
            textEdit: edit,
            documentation: documentationText
          });
        });
      }
    }
    return completionList;
  }
  async provideCompletionItems(document, position, token, context) {
    const doc = import_coc7.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc7.Position.create(position.line, position.character - 1), "@");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (!text.startsWith("@"))
      return [];
    const completionItemList = [];
    this.directiveJsonPaths.forEach((v) => {
      this.getCompletionItems(v, text, position).then((vv) => completionItemList.push(...vv));
    });
    return completionItemList;
  }
};

// src/completions/provider/bladeSnippets.ts
var import_coc8 = require("coc.nvim");
var import_fs3 = __toESM(require("fs"));
var import_path4 = __toESM(require("path"));
var BladeSnippetsCompletionProvider = class {
  constructor(context, outputChannel) {
    this._context = context;
    this._outputChannel = outputChannel;
    this.snippetsFilePaths = [
      import_path4.default.join(this._context.extensionPath, "data", "snippets", "snippets.json"),
      import_path4.default.join(this._context.extensionPath, "data", "snippets", "helpers.json"),
      import_path4.default.join(this._context.extensionPath, "data", "snippets", "blade.json"),
      import_path4.default.join(this._context.extensionPath, "data", "snippets", "livewire.json")
    ];
    this.excludeSnippetsKeys = getConfigBladeCompletionExcludeSnippets();
  }
  async getSnippetsCompletionItems(snippetsFilePath, text, position) {
    const snippetsCompletionList = [];
    if (import_fs3.default.existsSync(snippetsFilePath)) {
      const snippetsJsonText = import_fs3.default.readFileSync(snippetsFilePath, "utf8");
      const snippetsJson = JSON.parse(snippetsJsonText);
      if (snippetsJson) {
        Object.keys(snippetsJson).map((key) => {
          if (this.excludeSnippetsKeys.includes(snippetsJson[key].prefix))
            return;
          let snippetsText;
          const body = snippetsJson[key].body;
          if (body instanceof Array) {
            snippetsText = body.join("\n");
          } else {
            snippetsText = body;
          }
          const edit = {
            range: {
              start: { line: position.line, character: position.character - text.length },
              end: position
            },
            newText: snippetsJson[key].prefix
          };
          snippetsCompletionList.push({
            label: snippetsJson[key].prefix,
            kind: import_coc8.CompletionItemKind.Snippet,
            detail: snippetsJson[key].description,
            documentation: { kind: "markdown", value: "```blade\n" + snippetsText + "\n```" },
            insertTextFormat: import_coc8.InsertTextFormat.Snippet,
            textEdit: edit,
            // The "snippetsText" that will eventually be added to the insertText
            // will be stored in the "data" key
            data: snippetsText
          });
        });
      }
    }
    return snippetsCompletionList;
  }
  async provideCompletionItems(document, position, token, context) {
    const doc = import_coc8.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc8.Position.create(position.line, position.character - 1), ":<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (text.match(/(<livewire:).*$/))
      return [];
    const completionItemList = [];
    this.snippetsFilePaths.forEach((v) => {
      this.getSnippetsCompletionItems(v, text, position).then((vv) => completionItemList.push(...vv));
    });
    return completionItemList;
  }
  async resolveCompletionItem(item) {
    if (item.textEdit) {
      item.textEdit.newText = item.data;
    }
    return item;
  }
};

// src/completions/provider/livewireDirectiveComponent.ts
var import_coc10 = require("coc.nvim");

// src/completions/util/livewireUtil.ts
var import_coc9 = require("coc.nvim");
var import_fs4 = __toESM(require("fs"));
var import_path5 = __toESM(require("path"));
async function getAllComponents(prefix) {
  const componentWithSrcFile = [];
  try {
    const text = await import_fs4.default.promises.readFile(
      import_path5.default.join(import_coc9.workspace.root, "bootstrap", "cache", "livewire-components.php"),
      {
        encoding: "utf8"
      }
    );
    const regex = /'(.*)'\s*=>\s*'(.*)',*/g;
    const matches = [...text.matchAll(regex)];
    for (const m of matches) {
      if (!prefix || m[1].startsWith(prefix)) {
        componentWithSrcFile.push({
          name: m[1],
          srcFile: m[2]
        });
      }
    }
  } catch (e) {
  }
  return componentWithSrcFile;
}
async function getAllComponentsWithProps(prefix) {
  const componentWithProps = [];
  try {
    const components = await getAllComponents(prefix);
    for (const component of components) {
      const params = await getComponentParams(component.name, component.srcFile);
      const properties = await getComponentPropertiesFromComponent(component.name, component.srcFile);
      const prepareProps = [];
      if (params)
        prepareProps.push(...params.filter((v) => !!v));
      if (properties)
        prepareProps.push(...properties.filter((v) => !!v));
      const props = [...new Set(prepareProps)];
      componentWithProps.push({
        name: component.name,
        props: props ? props : void 0
      });
    }
  } catch (e) {
  }
  return componentWithProps;
}
async function getComponentPath(componentName) {
  try {
    const components = await getAllComponents();
    const component = components.find((component2) => component2.name === componentName);
    if (!component) {
      throw new Error("Cannot find component");
    }
    return component.srcFile;
  } catch (e) {
    return void 0;
  }
}
async function getComponentClassSource(component, srcFile) {
  try {
    if (!srcFile) {
      srcFile = await getComponentPath(component);
    }
    if (!srcFile) {
      throw new Error("Cannot find class src file");
    }
    srcFile = srcFile.replace(/\\\\/g, import_path5.default.sep);
    srcFile = srcFile.replace(/App/g, "app");
    const srcFileSplit = srcFile.split(import_path5.default.sep);
    return await import_fs4.default.promises.readFile(import_path5.default.join(import_coc9.workspace.root, ...srcFileSplit) + ".php", {
      encoding: "utf8"
    });
  } catch (e) {
    return null;
  }
}
async function getComponentParams(component, srcFile) {
  try {
    const classText = await getComponentClassSource(component, srcFile);
    if (!classText) {
      throw new Error("Cannot find class");
    }
    const match = /function\s*mount\s*\(([^\)]*)/gm.exec(classText);
    if (!match || !match.length) {
      throw new Error("Cannot find mount() function");
    }
    const variables = match[1].split(/,/gm);
    const params = [];
    for (const variable of variables) {
      const words = variable.split(/\$/gm);
      if (words.length) {
        params.push(words[1]);
      }
    }
    return params;
  } catch (e) {
    return null;
  }
}
async function getComponentFromView(viewFile) {
  try {
    viewFile = viewFile.replace(/\\/g, import_path5.default.sep);
    const viewMatch = new RegExp(`.*${import_path5.default.sep}resources${import_path5.default.sep}views${import_path5.default.sep}(.*).blade.php`).exec(viewFile);
    if (!viewMatch || !viewMatch.length) {
      throw new Error("View file path is not correct");
    }
    let view;
    if (process.platform === "win32") {
      view = viewMatch[1].replace(/\\/g, "\\.");
    } else {
      view = viewMatch[1].replace(/\//g, "\\.");
    }
    const components = await getAllComponents();
    for (const component of components) {
      const classText = await getComponentClassSource(component.name, component.srcFile);
      if (!classText) {
        continue;
      }
      const match = new RegExp(view, "mg").exec(classText);
      if (match) {
        return component;
      }
    }
    return null;
  } catch (e) {
    return null;
  }
}
async function getComponentActionsFromView(viewFile) {
  try {
    const component = await getComponentFromView(viewFile);
    if (!component) {
      throw new Error("Cannot find component");
    }
    const classText = await getComponentClassSource(component.name, component.srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /^\s*(?:public\s+)?function\s*(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        if (match[1] !== "mount" && match[1] !== "render") {
          actions.push(match[1]);
        }
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}
async function getComponentPropertiesFromView(viewFile) {
  try {
    const component = await getComponentFromView(viewFile);
    if (!component) {
      throw new Error("Cannot find component");
    }
    const classText = await getComponentClassSource(component.name, component.srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /(?<![\/\*#].*)public\s+\$(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        actions.push(match[1]);
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}
async function getComponentPropertiesFromComponent(name, srcFile) {
  try {
    const classText = await getComponentClassSource(name, srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /(?<![\/\*#].*)public\s+\$(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        actions.push(match[1]);
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}

// src/completions/provider/livewireDirectiveComponent.ts
var LivewireDirectiveComponentProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /@livewire\(([A-Za-z0-9_.-]*)$/g.exec(linePrefix);
    if (!match) {
      return [];
    }
    const prefix = match[1] || "";
    const completionList = await getAllComponentsWithProps(prefix);
    return completionList.map((c) => {
      let completeText = `'${c.name}'`;
      if (c.props && c.props.length) {
        const props = [];
        for (let i = 0; i < c.props.length; i++) {
          props.push(`'\${${i + 2}:${c.props[i]}}' => ''`);
        }
        completeText += `\${1:, [${props.join(", ")}]}`;
      }
      const item = {
        label: `${c.name}`,
        kind: import_coc10.CompletionItemKind.Method,
        insertText: new import_coc10.SnippetString(completeText).value,
        insertTextFormat: import_coc10.InsertTextFormat.Snippet
      };
      return item;
    });
  }
};

// src/completions/provider/livewireTag.ts
var import_coc11 = require("coc.nvim");
var LivewireTagProvider = class {
  provideCompletionItems(document, position, token, context) {
    const doc = import_coc11.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc11.Position.create(position.line, position.character - 1), "<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (!text.startsWith("<"))
      return [];
    const item = {
      label: "livewire",
      kind: import_coc11.CompletionItemKind.Text,
      insertText: new import_coc11.SnippetString("livewire:${1}").value,
      insertTextFormat: import_coc11.InsertTextFormat.Snippet,
      command: { command: "editor.action.triggerSuggest", title: "Re-trigger completions..." }
    };
    return [item];
  }
};

// src/completions/provider/livewireTagComponent.ts
var import_coc12 = require("coc.nvim");
var LivewireTagComponentProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /<livewire:([A-Za-z0-9_.-]*)$/g.exec(linePrefix);
    if (!match) {
      return [];
    }
    const prefix = match[1] || "";
    const completionList = await getAllComponentsWithProps(prefix);
    const words = prefix.split(/\W+/g);
    const prefixLen = prefix.length - (words.length ? words[words.length - 1].length : 0);
    return completionList.map((c) => {
      let params = "";
      if (c.props && c.props.length) {
        for (let i = 0; i < c.props.length; i++) {
          if (c.props[i]) {
            params += ` :\${${i + 1}:${c.props[i]}=''}`;
          }
        }
      }
      const item = {
        label: "livewire:" + c.name,
        kind: import_coc12.CompletionItemKind.Method,
        insertText: new import_coc12.SnippetString(`livewire:${c.name.slice(prefixLen)}${params}`).value,
        insertTextFormat: import_coc12.InsertTextFormat.Snippet
      };
      return item;
    });
  }
};

// src/completions/provider/livewireWire.ts
var import_coc13 = require("coc.nvim");
var LivewireWireProvider = class {
  provideCompletionItems(document, position, token, context) {
    const doc = import_coc13.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc13.Position.create(position.line, position.character - 1), "<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (text.startsWith("<"))
      return [];
    const item = {
      label: "wire",
      kind: import_coc13.CompletionItemKind.Text,
      insertText: new import_coc13.SnippetString("wire:").value,
      insertTextFormat: import_coc13.InsertTextFormat.Snippet,
      command: { command: "editor.action.triggerSuggest", title: "Re-trigger completions..." }
    };
    return [item];
  }
};

// src/completions/provider/livewireWireAction.ts
var import_coc14 = require("coc.nvim");
var LivewireWireActionProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /(?:^|\s+)wire:(\w+)(?:\.(\w+))?(?:\.?([A-Za-z0-9_.]*))=(['"][A-Za-z0-9_.]*)?$/g.exec(linePrefix);
    if (!match || match.length < 4) {
      return [];
    }
    let attributes = [];
    switch (match[1]) {
      case "click":
        attributes = await getComponentActionsFromView(import_coc14.Uri.parse(document.uri).fsPath) || [];
        break;
      case "model":
        attributes = await getComponentPropertiesFromView(import_coc14.Uri.parse(document.uri).fsPath) || [];
        break;
    }
    if (!match[4] && !attributes.length) {
      return [];
    }
    const completionList = attributes.map((attribute) => {
      const item = {
        label: attribute,
        kind: import_coc14.CompletionItemKind.Value,
        insertText: new import_coc14.SnippetString(`${match[4] ? "" : "'"}\${1:${attribute}}${match[4] ? "" : "'"}`).value,
        insertTextFormat: import_coc14.InsertTextFormat.Snippet
      };
      return item;
    });
    return completionList;
  }
};

// src/completions/provider/livewireWireEvent.ts
var import_coc15 = require("coc.nvim");
var LivewireWireEventProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /(?:^|\s+)wire:(\w*)(?:(?:\.?)([A-Za-z0-9_.]*))?$/g.exec(linePrefix);
    if (!match || match.length < 3) {
      return [];
    }
    const attributes = [
      "key",
      "model",
      "model.debounce.100ms",
      "model.debounce.500ms",
      "model.lazy",
      "model.defer",
      "poll",
      "poll.500ms",
      "poll.keep-alive",
      "poll.visible",
      "init",
      "loading",
      "loading.class",
      "loading.class.remove",
      "loading.attr",
      "loading.delay",
      "loading.delay.shortest",
      "loading.delay.shorter",
      "loading.delay.short",
      "loading.delay.long",
      "loading.delay.longer",
      "loading.delay.longest",
      "dirty",
      "dirty.class",
      "dirty.class.remove",
      "dirty.attr",
      "offline",
      "offline.class",
      "offline.class.remove",
      "offline.attr",
      "target",
      "ignore",
      "ignore.self",
      "abort",
      "afterprint",
      "animationend",
      "animationiteration",
      "animationstart",
      "beforeprint",
      "beforeunload",
      "blur",
      "canplay",
      "canplaythrough",
      "change",
      "click",
      "click.prefetch",
      "contextmenu",
      "copy",
      "cut",
      "dblclick",
      "drag",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "dragstart",
      "drop",
      "durationchange",
      "ended",
      "error",
      "focus",
      "focusin",
      "focusout",
      "fullscreenchange",
      "fullscreenerror",
      "hashchange",
      "input",
      "invalid",
      "keydown",
      "keydown.enter",
      "keypress",
      "keyup",
      "load",
      "loadeddata",
      "loadedmetadata",
      "loadstart",
      "message",
      "mousedown",
      "mouseenter",
      "mouseleave",
      "mousemove",
      "mouseover",
      "mouseout",
      "mouseup",
      "online",
      "open",
      "pagehide",
      "pageshow",
      "paste",
      "pause",
      "play",
      "playing",
      "popstate",
      "progress",
      "ratechange",
      "resize",
      "reset",
      "scroll",
      "search",
      "seeked",
      "seeking",
      "select",
      "show",
      "stalled",
      "storage",
      "submit",
      "submit.prevent",
      "suspend",
      "timeupdate",
      "toggle",
      "touchcancel",
      "touchend",
      "touchmove",
      "touchstart",
      "transitionend",
      "unload",
      "volumechange",
      "waiting",
      "wheel"
    ];
    const completionList = attributes.map((attribute) => {
      const item = {
        label: "wire:" + attribute,
        kind: import_coc15.CompletionItemKind.Field
      };
      return item;
    });
    return completionList;
  }
};

// src/completions/completion.ts
async function register4(context, outputChannel) {
  if (getConfigBladeCompletionEnable()) {
    const { document } = await import_coc16.workspace.getCurrentState();
    if (document.languageId === "blade") {
      const existsBladeIndent = await import_coc16.workspace.nvim.eval('exists("*GetBladeIndent")');
      let indentexpr;
      if (existsBladeIndent === 1) {
        indentexpr = "GetBladeIndent()";
      } else {
        indentexpr = await (await import_coc16.workspace.nvim.buffer).getOption("indentexpr");
      }
      try {
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=:");
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=-");
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=.");
        await import_coc16.workspace.nvim.command(`setlocal indentexpr=${indentexpr}`);
        import_coc16.workspace.registerAutocmd({
          event: "FileType",
          pattern: "blade",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=:");
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=-");
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=.");
          }
        });
        import_coc16.workspace.registerAutocmd({
          event: "InsertEnter",
          pattern: "*.blade.php",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command("setlocal indentexpr=");
          }
        });
        import_coc16.workspace.registerAutocmd({
          event: "InsertLeave",
          pattern: "*.blade.php",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command(`setlocal indentexpr=${indentexpr}`);
          }
        });
      } catch {
      }
    }
    if (getConfigBladeCompletionEnableSnippets()) {
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "blade-snippets",
          "blade",
          ["blade"],
          new BladeSnippetsCompletionProvider(context, outputChannel),
          [":"]
        )
      );
    }
    if (getConfigBladeCompletionEnableDirective()) {
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "blade-directive",
          "blade",
          ["blade"],
          new BladeDirectiveCompletionProvider(context),
          ["@"]
        )
      );
    }
    if (getConfigBladeCompletionEnableLivewireDirectiveComponent()) {
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "livewire-directive-component",
          "livewire",
          ["blade"],
          new LivewireDirectiveComponentProvider(),
          ["("]
        )
      );
    }
    if (getConfigBladeCompletionEnableLivewireTag()) {
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider("livewire-tag", "livewire", ["blade"], new LivewireTagProvider(), [
          "<"
        ])
      );
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "livewire-tag-component",
          "livewire",
          ["blade"],
          new LivewireTagComponentProvider()
          //[...':.-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_']
        )
      );
    }
    if (getConfigBladeCompletionEnableLivewireWire()) {
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider("livewire-wire", "livewire", ["blade"], new LivewireWireProvider(), [
          "w"
        ])
      );
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "livewire-wire-event",
          "livewire",
          ["blade"],
          new LivewireWireEventProvider(),
          [":", "."]
        )
      );
      context.subscriptions.push(
        import_coc16.languages.registerCompletionItemProvider(
          "livewire-wire-action",
          "livewire",
          ["blade"],
          new LivewireWireActionProvider(),
          ["=", "'", '"']
        )
      );
    }
  }
}

// src/definitions/definition.ts
var import_coc17 = require("coc.nvim");
var import_fs5 = __toESM(require("fs"));
async function register5(context) {
  const documentSelector = [{ language: "blade", scheme: "file" }];
  context.subscriptions.push(import_coc17.languages.registerDefinitionProvider(documentSelector, new BladeDefinitionProvider()));
}
var BladeDefinitionProvider = class {
  provideDefinition(document, position, token) {
    const doc = import_coc17.workspace.getDocument(document.uri);
    if (!doc)
      return null;
    const wordRange = doc.getWordRangeAtPosition(position, `-."'`);
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    let locationPath;
    if (text.startsWith("x-jet-")) {
      locationPath = this.getComponentLocationPath(import_coc17.workspace.root, text, true);
    } else if (text.startsWith("x-")) {
      locationPath = this.getComponentLocationPath(import_coc17.workspace.root, text, false);
    } else if (text.startsWith('"') || text.startsWith("'")) {
      const templateStr = text.replace(/\"/g, "").replace(/\'/g, "");
      locationPath = this.getTemplateLocationPath(import_coc17.workspace.root, templateStr);
    }
    if (locationPath) {
      const location = {
        uri: locationPath,
        range: import_coc17.Range.create(import_coc17.Position.create(0, 0), import_coc17.Position.create(0, 0))
      };
      return location;
    }
    return null;
  }
  getComponentLocationPath(workspaceRootPath, componentTag, isJet) {
    let componentText = componentTag.replace(/^x-/, "");
    if (isJet) {
      componentText = componentTag.replace(/^x-jet-/, "");
    }
    let componentPath = this.componentNameToPath(componentText, isJet);
    if (!import_fs5.default.existsSync(workspaceRootPath + componentPath)) {
      componentPath = this.componentNameToIndexPath(componentText, isJet);
      if (!import_fs5.default.existsSync(workspaceRootPath + componentPath)) {
        return void 0;
      }
    }
    const locationPath = import_coc17.Uri.parse(workspaceRootPath + componentPath).toString();
    return locationPath;
  }
  getTemplateLocationPath(workspaceRootPath, templateStr) {
    let templatePath = this.templateNameToPath(templateStr);
    if (!import_fs5.default.existsSync(workspaceRootPath + templatePath)) {
      templatePath = this.templateNameToIndexPath(templateStr);
      if (!import_fs5.default.existsSync(workspaceRootPath + templatePath)) {
        return void 0;
      }
    }
    const locationPath = import_coc17.Uri.parse(workspaceRootPath + templatePath).toString();
    return locationPath;
  }
  componentNameToPath(path7, isJet) {
    if (isJet) {
      return `/resources/views/vendor/jetstream/components/${path7.replace(/\./g, "/")}.blade.php`;
    } else {
      return `/resources/views/components/${path7.replace(/\./g, "/")}.blade.php`;
    }
  }
  componentNameToIndexPath(path7, isJet) {
    if (isJet) {
      return `/resources/views/vendor/jetstream/components/${path7.replace(/\./g, "/")}/index.blade.php`;
    } else {
      return `/resources/views/components/${path7.replace(/\./g, "/")}/index.blade.php`;
    }
  }
  templateNameToPath(path7) {
    return `/resources/views/${path7.replace(/\./g, "/")}.blade.php`;
  }
  templateNameToIndexPath(path7) {
    return `/resources/views/${path7.replace(/\./g, "/")}/index.blade.php`;
  }
};

// src/documentFormats/documentFormat.ts
var import_coc18 = require("coc.nvim");
var formatterHandler;
function disposeHandlers() {
  if (formatterHandler) {
    formatterHandler.dispose();
  }
  formatterHandler = void 0;
}
function register6(context, outputChannel) {
  const documentSelector = [{ language: "blade", scheme: "file" }];
  if (getConfigBladeFormatterEnable()) {
    let registerFormatter2 = function() {
      disposeHandlers();
      formatterHandler = import_coc18.languages.registerDocumentFormatProvider(documentSelector, editProvider, priority);
    };
    var registerFormatter = registerFormatter2;
    const editProvider = new BladeFormatterDocumantFormattingEditProvider(context, outputChannel);
    const priority = 1;
    registerFormatter2();
  }
}
var BladeFormatterDocumantFormattingEditProvider = class {
  constructor(context, outputChannel) {
    this._context = context;
    this._outputChannel = outputChannel;
  }
  provideDocumentFormattingEdits(document) {
    return this._provideEdits(document, void 0);
  }
  async _provideEdits(document, range) {
    const code = await doFormat(this._context, this._outputChannel, document, range);
    if (!range) {
      range = fullDocumentRange(document);
    }
    return [import_coc18.TextEdit.replace(range, code)];
  }
};

// src/hovers/hover.ts
var import_coc19 = require("coc.nvim");
var import_fs6 = __toESM(require("fs"));
var import_path6 = __toESM(require("path"));

// src/hovers/lang.ts
var bladeHovers = [
  {
    prefix: "@json",
    alias: []
  },
  {
    prefix: "@js",
    alias: []
  },
  {
    prefix: "@verbatim",
    alias: ["@endverbatim"]
  },
  // ==== Blade Directives ====
  // ---- If Statements ----
  {
    prefix: "@if",
    alias: ["@elseif", "@else", "@endif"]
  },
  {
    prefix: "@unless",
    alias: ["@endunless"]
  },
  {
    prefix: "@isset",
    alias: ["@endisset"]
  },
  {
    prefix: "@empty",
    alias: ["@endempty"]
  },
  // ---- Authentication Directives ----
  {
    prefix: "@auth",
    alias: ["@endauth"]
  },
  {
    prefix: "@guest",
    alias: ["@endguest"]
  },
  // ---- Environment Directives ----
  {
    prefix: "@production",
    alias: ["@endproduction"]
  },
  {
    prefix: "@env",
    alias: ["@endenv"]
  },
  // ---- Section Directives ----
  {
    prefix: "@hasSection",
    alias: []
  },
  {
    prefix: "@sectionMissing",
    alias: []
  },
  // ---- Switch Statements ----
  {
    prefix: "@switch",
    alias: ["@case", "@break", "@default", "@endswitch"]
  },
  // ---- Loops ----
  {
    prefix: "@for",
    alias: ["@endfor"]
  },
  {
    prefix: "@foreach",
    alias: ["@endforeach"]
  },
  {
    prefix: "@forelse",
    alias: ["@endforelse"]
  },
  {
    prefix: "@while",
    alias: ["@endwhile"]
  },
  {
    prefix: "@continue",
    alias: []
  },
  // ---- The Loop Variable ----
  {
    prefix: "$loop",
    alias: ["loop"]
  },
  // ---- Conditional Classes ----
  {
    prefix: "@class",
    alias: []
  },
  // ==== 9.x ====
  // ---- Checked / Selected ----
  {
    prefix: "@checked",
    alias: []
  },
  {
    prefix: "@selected",
    alias: []
  },
  {
    prefix: "@disabled",
    alias: []
  },
  // ---- Including Subviews ----
  {
    prefix: "@include",
    alias: []
  },
  {
    prefix: "@includeIf",
    alias: []
  },
  {
    prefix: "@includeWhen",
    alias: []
  },
  {
    prefix: "@includeFirst",
    alias: []
  },
  // ---- Rendering Views For Collections ----
  {
    prefix: "@each",
    alias: []
  },
  // ---- The @once Directive ----
  {
    prefix: "@once",
    alias: ["@endonce"]
  },
  // ---- Raw PHP ----
  {
    prefix: "@php",
    alias: ["@endphp"]
  },
  // ==== Components ====
  // ---- Data Properties / Attributes ----
  {
    prefix: "@props",
    alias: []
  },
  // ---- Accessing Parent Data ----
  {
    prefix: "@aware",
    alias: []
  },
  // ---- 6.x ----
  // https://laravel.com/docs/6.x/blade#components-and-slots
  {
    prefix: "@component",
    alias: ["@endcomponent"]
  },
  // ---- 6.x ----
  // https://laravel.com/docs/6.x/blade#components-and-slots
  {
    prefix: "@slot",
    alias: ["endslot"]
  },
  // ==== Building Layouts ====
  // ---- Layouts Using Template Inheritance ----
  {
    prefix: "@section",
    alias: ["@endsection"]
  },
  {
    prefix: "@show",
    alias: []
  },
  {
    prefix: "@yield",
    alias: []
  },
  {
    prefix: "@extends",
    alias: []
  },
  {
    prefix: "@parent",
    alias: []
  },
  // ==== Forms ====
  // ---- CSRF Field ----
  {
    prefix: "@csrf",
    alias: []
  },
  // ---- Method Field ----
  {
    prefix: "@method",
    alias: []
  },
  // ---- Validation Errors ----
  {
    prefix: "@error",
    alias: ["@enderror"]
  },
  // ==== Stack ====
  {
    prefix: "@push",
    alias: ["@endpush"]
  },
  {
    prefix: "@stack",
    alias: []
  },
  {
    prefix: "@prepend",
    alias: ["@endprepend"]
  },
  // ==== Service Injection ====
  {
    prefix: "@inject",
    alias: []
  },
  // ==== authorization ====
  // https://laravel.com/docs/8.x/authorization
  {
    prefix: "@can",
    alias: ["@cannot", "@elsecan", "@endcan", "@elsecannot", "@endcannot"]
  },
  // ==== 7.x ====
  // ---- Localization ----
  // https://laravel.com/docs/7.x/localization#overriding-package-language-files
  {
    prefix: "@lang",
    alias: []
  }
];

// src/hovers/hover.ts
async function register7(context) {
  const documentSelector = [{ language: "blade", scheme: "file" }];
  context.subscriptions.push(import_coc19.languages.registerHoverProvider(documentSelector, new BladeHoverProvider(context)));
}
var BladeHoverProvider = class {
  constructor(context) {
    this.context = context;
  }
  async provideHover(document, position) {
    const doc = import_coc19.workspace.getDocument(document.uri);
    if (!doc)
      return null;
    const wordRange = doc.getWordRangeAtPosition(position, "@");
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    const result = await this.getHover(text, "blade");
    if (!result)
      return null;
    return {
      contents: {
        kind: "markdown",
        value: result
      }
    };
  }
  async getHover(text, hoverLang) {
    const defineHovers = bladeHovers;
    let result = "";
    for (const h in defineHovers) {
      if (text === defineHovers[h].prefix || defineHovers[h].alias.includes(text)) {
        const markdownPath = import_path6.default.join(
          this.context.extensionPath,
          "data",
          "documantation",
          hoverLang,
          // File names remove the @ and $.
          defineHovers[h].prefix.replace(/@|\$/, "") + ".md"
        );
        try {
          result = import_fs6.default.readFileSync(markdownPath, { encoding: "utf8" });
        } catch (e) {
          return result;
        }
        break;
      }
    }
    return result;
  }
};

// src/linters/bladeParserLint.ts
var import_coc20 = require("coc.nvim");
var import_bladeDocument = __toESM(require_bladeDocument());
async function register8(context, outputChannel) {
  if (getConfigBladeParserLintEnable()) {
    const engine = new BladeParserLintEngine(outputChannel);
    import_coc20.workspace.documents.map(async (doc) => {
      await engine.lint(doc.textDocument);
    });
    import_coc20.workspace.onDidOpenTextDocument(
      async (e) => {
        await engine.lint(e);
      },
      null,
      context.subscriptions
    );
    import_coc20.workspace.onDidChangeTextDocument(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async (_e) => {
        const doc = await import_coc20.workspace.document;
        await engine.lint(doc.textDocument);
      },
      null,
      context.subscriptions
    );
    import_coc20.workspace.onDidSaveTextDocument(
      async (e) => {
        await engine.lint(e);
      },
      null,
      context.subscriptions
    );
  }
}
var BladeParserLintEngine = class {
  constructor(outputChannel) {
    this.collection = import_coc20.languages.createDiagnosticCollection("bladeParser");
    this.outputChannel = outputChannel;
  }
  async lint(textDocument) {
    if (textDocument.languageId !== "blade")
      return;
    const diagnostics = [];
    const content = textDocument.getText();
    const parserDocument = new import_bladeDocument.BladeDocument();
    const parserOptions = {
      customIfs: getConfigBladeParserLintOptCustomIfs(),
      directives: getConfigBladeParserLintOptDirectives(),
      ignoreDirectives: getConfigBladeParserLintOptIgnoreDirectives()
    };
    parserDocument.getParser().withParserOptions(parserOptions);
    try {
      const res = parserDocument.loadString(content);
      res.errors.all().forEach((e) => {
        var _a2, _b;
        if (getConfigBladeParserLintDebug()) {
          this.outputChannel.appendLine(`${"#".repeat(10)} bladeParser
`);
          this.outputChannel.appendLine(`errorCode: ${e.errorCode}`);
          this.outputChannel.appendLine(`level: ${e.level}`);
          this.outputChannel.appendLine(`message: ${e.message}`);
          this.outputChannel.appendLine(`startPosition: ${JSON.stringify((_a2 = e.node) == null ? void 0 : _a2.startPosition)}`);
          this.outputChannel.appendLine(`endPosition: ${JSON.stringify((_b = e.node) == null ? void 0 : _b.endPosition)}
`);
        }
        const message = e.message;
        const level = e.level;
        const severity = this.convertBladeErrorLevelToDiagnosticsSeverity(level);
        const errorCode = e.errorCode;
        let startPosition;
        let endPosition;
        if (e.node && e.node.startPosition && e.node.endPosition) {
          startPosition = import_coc20.Position.create(e.node.startPosition.line - 1, e.node.startPosition.char - 1);
          endPosition = import_coc20.Position.create(e.node.startPosition.line - 1, e.node.startPosition.char);
        }
        if (startPosition && endPosition) {
          const diagnostic = {
            source: "bladeParser",
            code: errorCode,
            range: import_coc20.Range.create(startPosition, endPosition),
            message,
            severity,
            relatedInformation: []
          };
          diagnostics.push(diagnostic);
        }
      });
    } catch (e) {
      this.collection.set(textDocument.uri, null);
    }
    this.collection.set(textDocument.uri, diagnostics);
  }
  convertBladeErrorLevelToDiagnosticsSeverity(level) {
    switch (level) {
      case 0:
        return import_coc20.DiagnosticSeverity.Error;
      case 1:
        return import_coc20.DiagnosticSeverity.Warning;
      default:
        return import_coc20.DiagnosticSeverity.Error;
    }
  }
};

// src/index.ts
async function activate(context) {
  if (!getConfigBladeEnable())
    return;
  const outputChannel = import_coc21.window.createOutputChannel("blade");
  register3(context, outputChannel);
  register2(context, outputChannel);
  await register4(context, outputChannel);
  register6(context, outputChannel);
  register7(context);
  register5(context);
  register(context);
  register8(context, outputChannel);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
