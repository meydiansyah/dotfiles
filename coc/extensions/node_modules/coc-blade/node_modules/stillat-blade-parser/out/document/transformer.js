"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = void 0;
const nodes_1 = require("../nodes/nodes");
const simpleArrayParser_1 = require("../parser/simpleArrayParser");
const stringUtilities_1 = require("../utilities/stringUtilities");
const bladeDocument_1 = require("./bladeDocument");
const arrayPrinter_1 = require("./printers/arrayPrinter");
const commentPrinter_1 = require("./printers/commentPrinter");
const directivePrinter_1 = require("./printers/directivePrinter");
const echoPrinter_1 = require("./printers/echoPrinter");
const indentLevel_1 = require("./printers/indentLevel");
class Transformer {
    constructor(doc) {
        this.inlineDirectiveBlocks = new Map();
        this.contentDirectives = new Map();
        this.dynamicEchoBlocks = new Map();
        this.pairedDirectives = new Map();
        this.dynamicInlineDirectives = new Map();
        this.inlineDirectives = new Map();
        this.inlineEchos = new Map();
        this.spanEchos = new Map();
        this.inlinePhpNodes = new Map();
        this.echoBlockSlugs = new Map();
        this.parentTransformer = null;
        this.forElseWithEmpty = [];
        this.forElseNoEmpty = [];
        this.conditions = [];
        this.switchStatements = [];
        this.removeLines = [];
        this.virtualStructureOpens = [];
        this.virtualStructureClose = [];
        this.inlineComments = new Map();
        this.blockComments = [];
        this.blockPhpNodes = new Map();
        this.breakDirectives = new Map();
        this.dynamicElementDirectives = new Map();
        this.dynamicElementDirectiveNodes = new Map();
        this.dynamicElementConditions = new Map();
        this.dynamicElementConditionNodes = new Map();
        this.dynamicElementSwitch = new Map();
        this.dynamicElementSwitchNodes = new Map();
        this.dynamicElementForElse = new Map();
        this.dynamicElementForElseNodes = new Map();
        this.dynamicElementPhpNodes = new Map();
        this.dynamicElementPhp = new Map();
        this.embeddedEchos = new Map();
        this.embeddedDirectives = new Map();
        this.structureLines = [];
        this.directiveParameters = new Map();
        this.expressionParameters = new Map();
        this.slugs = [];
        this.extractedEmbeddedDocuments = new Map();
        this.propDirectives = new Map();
        this.phpFormatter = null;
        this.blockPhpFormatter = null;
        this.phpTagFormatter = null;
        this.jsonFormatter = null;
        this.transformOptions = {
            spacesAfterDirective: 0,
            tabSize: 4,
            formatDirectiveJsonParameters: true,
            formatDirectivePhpParameters: true
        };
        this.forceCleanLines = [
            '@endphp',
            '@elseif',
            '@else',
            '@endif',
            '@endswitch',
            '@endverbatim',
            '@case',
            '@default',
        ];
        this.doc = doc;
    }
    setParentTransformer(transformer) {
        this.parentTransformer = transformer;
        return this;
    }
    withJsonFormatter(formatter) {
        this.jsonFormatter = formatter;
        return this;
    }
    withBlockPhpFormatter(formatter) {
        this.blockPhpFormatter = formatter;
        return this;
    }
    withPhpTagFormatter(formatter) {
        this.phpTagFormatter = formatter;
        return this;
    }
    withPhpFormatter(formatter) {
        this.phpFormatter = formatter;
        return this;
    }
    /**
     * Returns a document with Blade removed.
     * @returns string
     */
    removeBlade() {
        const allNodes = this.doc.getAllNodes();
        let text = '';
        allNodes.forEach((node) => {
            if (node instanceof nodes_1.LiteralNode) {
                text += node.getOutputContent();
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                text += node.sourceContent;
            }
            else if (node instanceof nodes_1.DirectiveNode && node.directiveName == 'verbatim') {
                text += node.innerContent;
            }
        });
        return text;
    }
    close(value) {
        return '</' + value + '>';
    }
    open(value) {
        return '<' + value + '>';
    }
    selfClosing(value) {
        return '<' + value + ' />';
    }
    pair(value, innerContent = '') {
        return '<' + value + '>' + innerContent + '</' + value + '>';
    }
    printDirective(directive) {
        return directivePrinter_1.DirectivePrinter.printDirective(directive, this.transformOptions, this.phpFormatter, this.jsonFormatter);
    }
    makeSlug(length) {
        if (length <= 2) {
            length = 7;
        }
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', charactersLength = characters.length;
        for (let i = 0; i < length - 1; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        const slug = 'B' + result + 'B';
        if (this.slugs.includes(slug)) {
            return this.makeSlug(length + 1);
        }
        this.slugs.push(slug);
        return slug;
    }
    registerDirectiveParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerDirectiveParameter(slug, param);
        }
        else {
            this.directiveParameters.set(slug, param);
        }
    }
    registerExpressionParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerExpressionParameter(slug, param);
        }
        else {
            this.expressionParameters.set(slug, param);
        }
    }
    registerCondition(transformedCondition) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerCondition(transformedCondition);
        }
        else {
            this.conditions.push(transformedCondition);
        }
    }
    registerSwitchStatement(transformedSwitch) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerSwitchStatement(transformedSwitch);
        }
        else {
            this.switchStatements.push(transformedSwitch);
        }
    }
    registerPairedDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerPairedDirective(slug, directive);
        }
        else {
            if (directive.isInline == false) {
                this.pairedDirectives.set(slug, directive);
            }
            else {
                this.inlineDirectives.set(directive.slug, directive);
                this.dynamicInlineDirectives.set(directive.directive.nodeContent, directive.slug);
            }
        }
    }
    registerInlineDirectiveBlock(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerInlineDirectiveBlock(slug, directive);
        }
        else {
            this.inlineDirectiveBlocks.set(slug, directive);
        }
    }
    registerContentDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerContentDirective(slug, directive);
        }
        else {
            this.contentDirectives.set(slug, directive);
        }
    }
    registerComment(slug, comment) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerComment(slug, comment);
        }
        else {
            this.inlineComments.set(slug, comment);
        }
    }
    registerDynamicDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.dynamicElementDirectives.set(directive.nodeContent, slug);
            this.parentTransformer.registerDynamicDirective(slug, directive);
        }
        else {
            this.dynamicElementDirectives.set(directive.nodeContent, slug);
            this.dynamicElementDirectiveNodes.set(slug, directive);
        }
    }
    prepareConditionalDirective(directive) {
        if (this.dynamicElementDirectives.has(directive.nodeContent)) {
            return this.dynamicElementDirectives.get(directive.nodeContent);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.registerDynamicDirective(slug, directive);
        return slug;
    }
    prepareInlineBlockDirective(directive) {
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerInlineDirectiveBlock(slug, directive);
        return this.selfClosing(slug);
    }
    prepareContentDirective(directive) {
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerContentDirective(slug, directive);
        return slug;
    }
    registerPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerPhpBlock(slug, php);
        }
        else {
            this.removeLines.push(this.close(slug));
            this.blockPhpNodes.set(slug, php);
        }
    }
    registerConditionalPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
            this.dynamicElementPhp.set(php.sourceContent, slug);
            this.parentTransformer.registerConditionalPhpBlock(slug, php);
        }
        else {
            this.dynamicElementPhp.set(php.sourceContent, slug);
            this.dynamicElementPhpNodes.set(slug, php);
        }
    }
    prepareConditionalPhpBlock(php) {
        if (this.dynamicElementPhp.has(php.sourceContent)) {
            return this.dynamicElementPhp.get(php.sourceContent);
        }
        const slug = this.makeSlug(php.sourceContent.length);
        this.registerConditionalPhpBlock(slug, php);
        return slug;
    }
    registerInlinePhpBlock(php) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerInlinePhpBlock(php);
        }
        else {
            const slug = this.makeSlug(php.sourceContent.length);
            this.inlinePhpNodes.set(slug, php);
            return slug;
        }
    }
    prepareInlinePhpBlock(php) {
        return this.registerInlinePhpBlock(php);
    }
    preparePhpBlock(php) {
        if (php.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.prepareConditionalPhpBlock(php);
        }
        if (php.isInline) {
            return this.prepareInlinePhpBlock(php);
        }
        const slug = this.makeSlug(35);
        this.registerPhpBlock(slug, php);
        const open = this.open(slug), close = this.close(slug);
        return "\n" + open + close + "\n";
    }
    transformPhpBlock(content) {
        let value = content;
        this.blockPhpNodes.forEach((php, slug) => {
            const open = this.open(slug), targetIndent = this.indentLevel(open);
            let result = php.sourceContent;
            if (this.phpTagFormatter != null && php.hasValidPhp()) {
                result = this.phpTagFormatter(result);
                result = indentLevel_1.IndentLevel.shiftIndent(result, targetIndent, true);
            }
            value = value.replace(open, result);
        });
        this.dynamicElementPhpNodes.forEach((php, slug) => {
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, this.printInlinePhp(php));
        });
        this.inlinePhpNodes.forEach((php, slug) => {
            value = value.replace(slug, this.printInlinePhp(php));
        });
        return value;
    }
    printInlinePhp(php) {
        let phpContent = php.sourceContent;
        if (this.phpTagFormatter && php.hasValidPhp()) {
            phpContent = this.phpTagFormatter(phpContent);
            phpContent = stringUtilities_1.StringUtilities.replaceAllInString(phpContent, "\n", ' ');
        }
        return phpContent;
    }
    shouldCreateVirutal(directive) {
        const children = directive.getImmediateChildren();
        if (children.length == 0) {
            return true;
        }
        let allEchosInline = true, allLiteralsWhitespace = true, inlineEchos = 0, bladeCount = 0, literalCount = 0, createVirtual = true;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.BladeEchoNode && child.isInlineEcho) {
                allEchosInline = false;
                inlineEchos += 1;
                bladeCount += 1;
            }
            else if (child instanceof nodes_1.LiteralNode) {
                literalCount += 1;
                if (child.content.trim().length > 0) {
                    allLiteralsWhitespace = false;
                }
            }
            else {
                bladeCount += 1;
            }
        }
        if (inlineEchos == 0) {
            createVirtual = true;
        }
        if (bladeCount > 0 && allEchosInline == true) {
            return false;
        }
        if (allLiteralsWhitespace == false && bladeCount == 0) {
            createVirtual = true;
        }
        if (allLiteralsWhitespace == true && bladeCount == 0) {
            createVirtual = true;
        }
        return createVirtual;
    }
    preparePairedDirective(directive) {
        var _a;
        const slug = this.makeSlug(directive.sourceContent.length), directiveName = directive.directiveName.toLowerCase(), innerDoc = (_a = directive.childrenDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
        if (directive.fragmentPosition != nodes_1.FragmentPosition.IsDynamicFragmentName) {
            let virtualSlug = '';
            let result = `${this.open(slug)}\n`;
            if (directiveName == 'php' || directiveName == 'verbatim') {
                virtualSlug = this.makeSlug(15);
                result += this.pair(virtualSlug);
            }
            else {
                if (this.shouldCreateVirutal(directive) && directive.containsChildStructures == false && directive.containsAnyFragments == false) {
                    virtualSlug = this.makeSlug(15);
                    result += this.pair(virtualSlug, innerDoc);
                }
                else {
                    result += innerDoc;
                }
            }
            result += `${this.close(slug)}\n`;
            this.virtualStructureOpens.push(this.open(virtualSlug));
            this.virtualStructureClose.push(this.close(virtualSlug));
            this.virtualStructureClose.push(this.close(slug));
            this.registerPairedDirective(slug, {
                innerDoc: innerDoc,
                slug: slug,
                directive: directive,
                virtualElementSlug: virtualSlug,
                isInline: false
            });
            return result;
        }
        if (this.dynamicInlineDirectives.has(directive.nodeContent)) {
            const existingSlug = this.dynamicInlineDirectives.get(directive.nodeContent);
            return existingSlug + ' ';
        }
        const dynamicSlug = this.makeSlug(directive.nodeContent.length);
        this.registerPairedDirective(slug, {
            innerDoc: innerDoc,
            slug: dynamicSlug,
            directive: directive,
            virtualElementSlug: '',
            isInline: true
        });
        return dynamicSlug + ' ';
    }
    registerForElseWithEmpty(forElse) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerForElseWithEmpty(forElse);
        }
        else {
            this.forElseWithEmpty.push(forElse);
        }
    }
    prepareForElse(forElse) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (forElse.fragmentPosition == nodes_1.FragmentPosition.Unresolved || forElse.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            if (forElse.elseNode != null) {
                const truthSlug = this.makeSlug((_b = (_a = forElse.constructedFrom) === null || _a === void 0 ? void 0 : _a.sourceContent.length) !== null && _b !== void 0 ? _b : 0), elseSlug = this.makeSlug((_d = (_c = forElse.elseNode) === null || _c === void 0 ? void 0 : _c.sourceContent.length) !== null && _d !== void 0 ? _d : 0), truthTransform = (_e = forElse.truthDocument) === null || _e === void 0 ? void 0 : _e.document.transform().setParentTransformer(this).toStructure(), falseTransform = (_f = forElse.falseDocument) === null || _f === void 0 ? void 0 : _f.document.transform().setParentTransformer(this).toStructure();
                const repForElse = {
                    truthDoc: truthTransform,
                    falseDoc: falseTransform,
                    forElse: forElse,
                    truthClose: this.close(truthSlug),
                    emptyOpen: this.open(elseSlug),
                    pairClose: this.close(elseSlug),
                    truthSlug: truthSlug,
                    falseSlug: elseSlug
                };
                let result = this.open(truthSlug);
                result += truthTransform;
                result += repForElse.truthClose;
                result += "\n" + repForElse.emptyOpen + "\n"; // This replacement will be the @empty
                result += falseTransform + "";
                result += repForElse.pairClose;
                this.registerForElseWithEmpty(repForElse);
                return result;
            }
            const construction = forElse.constructedFrom, truthDoc = (_g = forElse.truthDocument) === null || _g === void 0 ? void 0 : _g.document.transform().setParentTransformer(this).toStructure(), openSlug = this.makeSlug(construction.sourceContent.length), closeSlug = this.makeSlug((_j = (_h = construction.isClosedBy) === null || _h === void 0 ? void 0 : _h.sourceContent.length) !== null && _j !== void 0 ? _j : 0);
            const noElseForElse = {
                truthDoc: truthDoc,
                falseDoc: '',
                forElse: forElse,
                truthSlug: openSlug,
                falseSlug: '',
                pairClose: this.close(closeSlug),
                emptyOpen: '',
                truthClose: ''
            };
            this.forElseNoEmpty.push(noElseForElse);
            let result = this.open(openSlug);
            result += truthDoc;
            result += this.close(openSlug);
            return result;
        }
        if (this.dynamicElementForElse.has(forElse.nodeContent)) {
            const existingSlug = this.dynamicElementForElse.get(forElse.nodeContent);
            return existingSlug + ' ';
        }
        const slug = this.makeSlug(forElse.nodeContent.length);
        this.registerDynamicElementForElse(slug, forElse);
        return slug + ' ';
    }
    registerBreak(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerBreak(slug, directive);
        }
        else {
            this.breakDirectives.set(slug, directive);
        }
    }
    registerProps(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerProps(slug, directive);
        }
        else {
            this.propDirectives.set(slug, directive);
        }
    }
    preparePropsDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerProps(virtualSlug, directive);
        return `\n\n${this.pair(virtualSlug)}`;
    }
    prepareBreakDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerBreak(virtualSlug, directive);
        return `\n\n${this.pair(virtualSlug)}`;
    }
    registerEmbeddedDirective(directive) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedDirective(directive);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.embeddedDirectives.set(slug, directive);
        return slug;
    }
    registerEmbeddedDocument(slug, content, isScript) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedDocument(slug, content, isScript);
        }
        this.extractedEmbeddedDocuments.set(slug, {
            slug: slug,
            content: content,
            isScript: isScript
        });
        return slug;
    }
    prepareDirective(directive) {
        if (directive.isEmbedded()) {
            return this.registerEmbeddedDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == 'break') {
            return this.prepareBreakDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == 'props') {
            return this.preparePropsDirective(directive);
        }
        if (directive.isClosedBy != null) {
            return this.preparePairedDirective(directive);
        }
        if (directive.fragmentPosition == nodes_1.FragmentPosition.Unresolved) {
            return this.prepareInlineBlockDirective(directive);
        }
        else if (directive.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.prepareConditionalDirective(directive);
        }
        return this.prepareContentDirective(directive);
    }
    registerVirtualComment(structure) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerVirtualComment(structure);
        }
        else {
            this.blockComments.push(structure);
        }
    }
    prepareComment(comment) {
        if (comment.isMultiline()) {
            const slug = this.makeSlug(10), virtualSlug = this.makeSlug(10);
            const virtualStructure = {
                node: comment,
                pairOpen: this.open(slug),
                pairClose: this.close(slug),
                virtualElement: this.selfClosing(virtualSlug)
            };
            this.registerVirtualComment(virtualStructure);
            return virtualStructure.pairOpen + "\n" + virtualStructure.virtualElement + "\n" + virtualStructure.pairClose;
        }
        const slug = this.makeSlug(comment.sourceContent.length);
        this.registerComment(slug, comment);
        return this.selfClosing(slug);
    }
    registerDynamicFragmentEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerDynamicFragmentEcho(echo);
        }
        else {
            if (!this.echoBlockSlugs.has(echo.sourceContent)) {
                const slug = this.makeSlug(echo.sourceContent.length);
                this.dynamicEchoBlocks.set(slug, echo);
                this.echoBlockSlugs.set(echo.sourceContent, slug);
                return slug;
            }
            else {
                return this.echoBlockSlugs.get(echo.sourceContent);
            }
        }
    }
    registerInlineEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerInlineEcho(echo);
        }
        else {
            const slug = this.makeSlug(echo.sourceContent.length);
            if (echo.isInlineEcho) {
                this.spanEchos.set(slug, echo);
                return slug;
            }
            else {
                this.inlineEchos.set(slug, echo);
                return this.selfClosing(slug);
            }
        }
    }
    prepareComponent(component) {
        var _a, _b;
        if (component.isClosingTag) {
            if (((_a = component.name) === null || _a === void 0 ? void 0 : _a.name) == 'slot') {
                return '</x-slot>';
            }
            return '</x-' + component.getComponentName() + '>';
        }
        let value = '<x-';
        if (((_b = component.name) === null || _b === void 0 ? void 0 : _b.name) == 'slot' && component.isSelfClosing == false) {
            if (component.name.inlineName.trim().length > 0) {
                let slotName = component.name.inlineName;
                if (slotName.startsWith(':')) {
                    slotName = slotName.substring(1);
                }
                value += 'slot name="' + slotName + '"';
            }
            else {
                value += component.getComponentName();
            }
        }
        else {
            value += component.getComponentName();
        }
        if (component.hasParameters) {
            value += ' ';
            component.parameters.forEach((param) => {
                var _a, _b;
                if (param.type == nodes_1.ParameterType.Parameter) {
                    if (param.isExpression) {
                        const expressionSlug = this.makeSlug(param.content.length);
                        this.registerExpressionParameter(expressionSlug, param);
                        value += expressionSlug + ' ';
                    }
                    else {
                        value += param.content + ' ';
                    }
                }
                else if (param.type == nodes_1.ParameterType.Attribute) {
                    value += param.name + ' ';
                }
                else if (param.type == nodes_1.ParameterType.Directive) {
                    const directiveSlug = this.makeSlug((_b = (_a = param.directive) === null || _a === void 0 ? void 0 : _a.sourceContent.length) !== null && _b !== void 0 ? _b : 0);
                    this.registerDirectiveParameter(directiveSlug, param);
                    value += directiveSlug + ' ';
                }
            });
        }
        if (component.isSelfClosing) {
            value += ' />';
        }
        else {
            value += '>';
        }
        return value;
    }
    registerEmbeddedEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedEcho(echo);
        }
        const slug = this.makeSlug(echo.sourceContent.length);
        this.embeddedEchos.set(slug, echo);
        return slug;
    }
    prepareEcho(echo) {
        if (echo.isEmbedded()) {
            return this.registerEmbeddedEcho(echo);
        }
        if (echo.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.registerDynamicFragmentEcho(echo);
        }
        else if (echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragment || echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragmentParameter) {
            return this.registerDynamicFragmentEcho(echo);
        }
        return this.registerInlineEcho(echo);
    }
    prepareSwitch(switchNode) {
        if (switchNode.fragmentPosition == nodes_1.FragmentPosition.Unresolved || switchNode.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            const tCases = [];
            let result = '';
            switchNode.cases.forEach((caseNode, index) => {
                var _a, _b;
                const directive = caseNode.head, innerDoc = (_a = caseNode.childDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
                const openSlug = this.makeSlug(directive.sourceContent.length);
                const virtualOpen = this.makeSlug(5);
                const tCase = {
                    case: caseNode,
                    slug: openSlug,
                    doc: innerDoc,
                    virtualOpen: this.selfClosing(virtualOpen),
                    virtualClose: this.close(virtualOpen),
                    pairOpen: this.open(openSlug),
                    pairClose: this.close(openSlug),
                    isFirst: index == 0,
                    isLast: index == switchNode.cases.length - 1,
                    leadingClose: '',
                    leadingOpen: ''
                };
                if (caseNode.leadingDocument != null) {
                    const leadingSlug = this.makeSlug(25);
                    tCase.leadingOpen = this.open(leadingSlug);
                    tCase.leadingClose = this.close(leadingSlug);
                    result += "\n" + caseNode.leadingDocument.document.transform().setParentTransformer(this).toStructure() + "\n";
                }
                result += tCase.pairOpen;
                if (((_b = caseNode.head) === null || _b === void 0 ? void 0 : _b.directiveName) == 'default') {
                    result += tCase.virtualOpen;
                }
                result += innerDoc;
                result += tCase.pairClose;
                tCases.push(tCase);
            });
            const pairOpen = tCases[0].pairOpen, pairClose = tCases[tCases.length - 1].pairClose;
            const virtualSwitchSlug = this.makeSlug(10), virtualSwitchOpen = this.open(virtualSwitchSlug), virtualSwitchClose = this.close(virtualSwitchSlug);
            const tSwitch = {
                switchNode: switchNode,
                pairOpen: pairOpen,
                pairClose: pairClose,
                structures: tCases,
                virtualSwitchClose: virtualSwitchClose,
                virtualSwitchOpen: virtualSwitchOpen
            };
            const virtualStruct = "\n" + virtualSwitchOpen + "\n" + result + "\n" + virtualSwitchClose;
            this.registerSwitchStatement(tSwitch);
            return virtualStruct;
        }
        if (this.dynamicElementSwitch.has(switchNode.nodeContent)) {
            const existingSlug = this.dynamicElementSwitch.get(switchNode.nodeContent);
            return existingSlug + ' ';
        }
        const slug = this.makeSlug(switchNode.nodeContent.length);
        this.registerDynamicElementSwitch(slug, switchNode);
        return slug + ' ';
    }
    registerDynamicElementSwitch(slug, switchNode) {
        if (this.parentTransformer != null) {
            this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
            this.parentTransformer.registerDynamicElementSwitch(slug, switchNode);
        }
        else {
            this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
            this.dynamicElementSwitchNodes.set(slug, switchNode);
        }
    }
    registerDynamicElementCondition(slug, condition) {
        if (this.parentTransformer != null) {
            this.dynamicElementConditions.set(condition.nodeContent, slug);
            this.parentTransformer.registerDynamicElementCondition(slug, condition);
        }
        else {
            this.dynamicElementConditions.set(condition.nodeContent, slug);
            this.dynamicElementConditionNodes.set(slug, condition);
        }
    }
    registerDynamicElementForElse(slug, forElse) {
        if (this.parentTransformer != null) {
            this.dynamicElementForElse.set(forElse.nodeContent, slug);
            this.parentTransformer.registerDynamicElementForElse(slug, forElse);
        }
        else {
            this.dynamicElementForElse.set(forElse.nodeContent, slug);
            this.dynamicElementForElseNodes.set(slug, forElse);
        }
    }
    prepareConditions(condition) {
        if (condition.fragmentPosition == nodes_1.FragmentPosition.Unresolved || condition.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            if (condition.chain.length == 1 && condition.constructedFrom != null) {
                const construction = condition.constructedFrom.clone();
                construction.childrenDocument = condition.logicBranches[0].childDocument;
                return this.preparePairedDirective(construction);
            }
            const transformedBranches = [];
            let result = '';
            condition.logicBranches.forEach((branch, index) => {
                var _a, _b, _c, _d;
                const directive = branch.head, innerDoc = (_a = branch.childDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
                const openSlug = this.makeSlug(directive.sourceContent.length), virtualSlug = this.makeSlug(10);
                const tBranch = {
                    branch: branch,
                    slug: openSlug,
                    doc: innerDoc,
                    pairOpen: this.open(openSlug),
                    pairClose: this.close(openSlug),
                    virtualOpen: this.open(virtualSlug),
                    virtualClose: this.close(virtualSlug),
                    isFirst: index == 0,
                    isLast: index == condition.logicBranches.length - 1,
                    virtualBreakClose: '',
                    virtualBreakOpen: ''
                };
                if (((_b = branch.head) === null || _b === void 0 ? void 0 : _b.directiveName) == 'else') {
                    result += "\n" + tBranch.pairOpen;
                    const virtualBreakSlug = this.makeSlug(25);
                    if (branch.head.containsChildStructures == false && branch.head.containsAnyFragments == false) {
                        tBranch.virtualBreakOpen = this.open(virtualBreakSlug);
                        tBranch.virtualBreakClose = this.close(virtualBreakSlug);
                        result += "\n" + tBranch.virtualBreakOpen + "\n";
                        result += innerDoc;
                        result += "\n" + tBranch.virtualBreakClose + "\n" + tBranch.pairClose;
                    }
                    else {
                        tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                        result += tBranch.virtualBreakOpen + "\n";
                        result += innerDoc;
                        result += "\n" + tBranch.pairClose;
                    }
                }
                else {
                    if (((_c = branch.head) === null || _c === void 0 ? void 0 : _c.containsAnyFragments) == false && ((_d = branch.head) === null || _d === void 0 ? void 0 : _d.containsChildStructures) == false) {
                        const ifBreakSlug = this.makeSlug(25);
                        tBranch.virtualBreakOpen = this.open(ifBreakSlug);
                        tBranch.virtualBreakClose = this.close(ifBreakSlug);
                        result += tBranch.pairOpen;
                        result += "\n" + tBranch.virtualBreakOpen;
                        result += innerDoc;
                        result += "\n" + tBranch.virtualBreakClose;
                        result += tBranch.pairClose;
                    }
                    else {
                        result += tBranch.pairOpen;
                        result += "\n";
                        result += innerDoc;
                        result += "\n";
                        result += tBranch.pairClose;
                    }
                }
                transformedBranches.push(tBranch);
            });
            const pairOpen = transformedBranches[0].pairOpen, pairClose = transformedBranches[transformedBranches.length - 1].pairClose;
            const tCond = {
                pairOpen: pairOpen,
                pairClose: pairClose,
                structures: transformedBranches,
                condition: condition
            };
            this.registerCondition(tCond);
            return result;
        }
        if (this.dynamicElementConditions.has(condition.nodeContent)) {
            const existingSlug = this.dynamicElementConditions.get(condition.nodeContent);
            return existingSlug + ' ';
        }
        const slug = this.makeSlug(condition.nodeContent.length);
        this.registerDynamicElementCondition(slug, condition);
        return slug + ' ';
    }
    toStructure() {
        let result = '';
        this.doc.getRenderNodes().forEach((node) => {
            if (node instanceof nodes_1.LiteralNode) {
                result += node.content;
            }
            else if (node instanceof nodes_1.SwitchStatementNode) {
                if (node.cases.length > 0) {
                    result += this.prepareSwitch(node);
                }
                else {
                    result += this.preparePairedDirective(node.constructedFrom);
                }
            }
            else if (node instanceof nodes_1.ConditionNode) {
                result += this.prepareConditions(node);
            }
            else if (node instanceof nodes_1.DirectiveNode) {
                result += this.prepareDirective(node);
            }
            else if (node instanceof nodes_1.BladeEchoNode) {
                result += this.prepareEcho(node);
            }
            else if (node instanceof nodes_1.ForElseNode) {
                result += this.prepareForElse(node);
            }
            else if (node instanceof nodes_1.BladeCommentNode) {
                result += this.prepareComment(node);
            }
            else if (node instanceof nodes_1.BladeComponentNode) {
                result += this.prepareComponent(node);
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                result += this.preparePhpBlock(node);
            }
        });
        const structures = this.doc.getParser().getFragmentsContainingStructures();
        if (structures.length > 0) {
            const referenceDocument = bladeDocument_1.BladeDocument.fromText(result);
            structures.forEach((pair) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const ref = this.doc.getParser().getText(((_b = (_a = pair.start.endPosition) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) + 1, (_d = (_c = pair.end.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0), refOpen = referenceDocument.getParser().getFragmentsParser().getEmbeddedFragment(pair.start.embeddedIndex), refClose = referenceDocument.getParser().getFragmentsParser().getClosingFragmentAfter(refOpen), curRef = referenceDocument.getParser().getText(((_f = (_e = refOpen.endPosition) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0) + 1, (_h = (_g = refClose === null || refClose === void 0 ? void 0 : refClose.startPosition) === null || _g === void 0 ? void 0 : _g.offset) !== null && _h !== void 0 ? _h : 0), refSlug = this.makeSlug(16), isScript = pair.start.name.toLowerCase() == 'script';
                let replaceSlug = refSlug;
                if (isScript) {
                    replaceSlug = '//' + refSlug;
                }
                else {
                    replaceSlug = '/*' + refSlug + '*/';
                }
                result = result.replace(curRef, replaceSlug);
                this.registerEmbeddedDocument(refSlug, ref, isScript);
            });
        }
        return result;
    }
    withOptions(options) {
        this.transformOptions = options;
        return this;
    }
    transformInlineDirectives(content) {
        let value = content;
        this.inlineDirectiveBlocks.forEach((directive, slug) => {
            const search = this.selfClosing(slug), replace = this.printDirective(directive);
            value = value.replace(search, replace);
        });
        return value;
    }
    transformContentDirectives(content) {
        let value = content;
        this.contentDirectives.forEach((directive, slug) => {
            value = value.replace(slug, this.printDirective(directive));
        });
        return value;
    }
    transformDynamicEcho(content) {
        let value = content;
        this.dynamicEchoBlocks.forEach((echo, slug) => {
            const echoContent = echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter);
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, echoContent);
        });
        return value;
    }
    transformDynamicDirectives(content) {
        let value = content;
        this.dynamicElementDirectiveNodes.forEach((directive, slug) => {
            const directiveContent = this.printDirective(directive);
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, directiveContent);
        });
        return value;
    }
    transformBlockPhp(content, withNewLine) {
        if (this.blockPhpFormatter == null) {
            return content;
        }
        let value = content.trim();
        if (value.startsWith('<?php') == false) {
            value = '<?php ' + value;
        }
        value = this.blockPhpFormatter(value);
        if (withNewLine) {
            value = "\n" + value + "\n";
        }
        return value;
    }
    transformPairedDirectives(content) {
        let value = content;
        this.pairedDirectives.forEach((directive, slug) => {
            var _a;
            const originalDirective = directive.directive;
            if (directive.virtualElementSlug.length > 0) {
                const open = this.open(directive.virtualElementSlug), close = this.close(directive.virtualElementSlug);
                this.virtualStructureOpens.push(open);
                this.removeLines.push(open);
                this.removeLines.push(close);
            }
            const open = this.open(slug), close = this.close(slug);
            if (originalDirective.directiveName.trim().toLowerCase() == 'php') {
                const virtualOpen = this.open(directive.virtualElementSlug), targetIndent = this.indentLevel(virtualOpen), replacePhp = directive.directive.sourceContent;
                const formattedPhp = indentLevel_1.IndentLevel.shiftIndent(this.transformBlockPhp(originalDirective.innerContent, true), targetIndent, true);
                value = value.replace(open, replacePhp);
                value = value.replace(virtualOpen, formattedPhp);
            }
            else if (originalDirective.directiveName.trim().toLowerCase() == 'verbatim') {
                const replaceVerbatim = directive.directive.sourceContent + "\n" + indentLevel_1.IndentLevel.shiftClean(originalDirective.innerContent, this.transformOptions.tabSize);
                value = value.replace(open, replaceVerbatim);
            }
            else {
                value = value.replace(open, this.printDirective(directive.directive));
            }
            value = value.replace(close, (_a = directive.directive.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent);
        });
        this.inlineDirectives.forEach((directive, slug) => {
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, directive.directive.nodeContent);
        });
        return value;
    }
    transformForElseWithNoEmpty(content) {
        let value = content;
        this.forElseNoEmpty.forEach((forElse) => {
            var _a;
            const construction = forElse.forElse.constructedFrom, open = this.open(forElse.truthSlug), close = this.close(forElse.truthSlug), openContent = this.printDirective(construction), closeContent = (_a = construction.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent;
            value = value.replace(open, openContent);
            value = value.replace(close, closeContent);
        });
        return value;
    }
    transformForElseWithEmpty(content) {
        let value = content;
        this.forElseWithEmpty.forEach((forElse) => {
            var _a, _b;
            const truthOpen = this.open(forElse.truthSlug), construction = forElse.forElse.constructedFrom, constructionContent = this.printDirective(construction);
            value = value.replace(truthOpen, constructionContent);
            value = value.replace(forElse.pairClose, (_a = construction.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent);
            value = value.replace(forElse.emptyOpen, (_b = forElse.forElse.elseNode) === null || _b === void 0 ? void 0 : _b.sourceContent);
            this.removeLines.push(forElse.truthClose);
        });
        return value;
    }
    transformInlineEcho(content) {
        let value = content;
        this.inlineEchos.forEach((echo, slug) => {
            const inline = this.selfClosing(slug);
            value = value.replace(inline, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        this.spanEchos.forEach((echo, slug) => {
            value = value.replace(slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        return value;
    }
    transformConditions(content) {
        let value = content;
        this.conditions.forEach((condition) => {
            condition.structures.forEach((structure) => {
                const structureDirective = structure.branch.head;
                if (structure.virtualBreakOpen.length > 0) {
                    this.removeLines.push(structure.virtualBreakOpen);
                }
                if (structure.virtualBreakClose.length > 0) {
                    value = value.replace(structure.virtualBreakClose, structure.virtualBreakClose + "\n");
                    this.removeLines.push(structure.virtualBreakClose);
                }
                this.virtualStructureOpens.push(structure.virtualOpen);
                this.removeLines.push(structure.virtualOpen);
                this.removeLines.push(structure.virtualClose);
                if (!structure.isLast) {
                    this.removeLines.push(structure.pairClose);
                    value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
                }
                else {
                    value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
                    const closeDirective = structureDirective.isClosedBy;
                    value = value.replace(structure.pairClose, this.printDirective(closeDirective));
                }
            });
        });
        return value;
    }
    transformSwitchStatements(content) {
        let value = content;
        this.switchStatements.forEach((switchStatement) => {
            const open = switchStatement.switchNode.constructedFrom;
            value = value.replace(switchStatement.virtualSwitchOpen, this.printDirective(open));
            const closeDirective = open.isClosedBy;
            value = value.replace(switchStatement.virtualSwitchClose, closeDirective.sourceContent);
            switchStatement.structures.forEach((structure) => {
                const structureDirective = structure.case.head;
                this.removeLines.push(structure.virtualClose);
                this.removeLines.push(structure.virtualOpen);
                if (!structure.isLast) {
                    if (structure.isFirst) {
                        this.removeLines.push(structure.pairClose);
                        value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
                    }
                    else {
                        this.removeLines.push(structure.pairClose);
                        value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
                    }
                }
                else {
                    value = value.replace(structure.pairOpen, this.printDirective(structureDirective));
                    this.removeLines.push(structure.pairClose);
                }
            });
        });
        return value;
    }
    transformProps(content) {
        let value = content;
        this.propDirectives.forEach((directive, slug) => {
            const close = this.close(slug), open = this.open(slug);
            this.removeLines.push(close);
            let content = directive.sourceContent;
            try {
                if (this.transformOptions.formatDirectivePhpParameters && this.phpFormatter != null && directive.hasValidPhp()) {
                    let params = directive.getPhpContent().trim();
                    if (params.startsWith('(') && params.endsWith(')')) {
                        params = params.substring(1);
                        params = params.substring(0, params.length - 1);
                    }
                    let tResult = this.phpFormatter('<?php ' + params);
                    tResult = stringUtilities_1.StringUtilities.replaceAllInString(tResult, "\n", ' ');
                    const arrayParser = new simpleArrayParser_1.SimpleArrayParser(), array = arrayParser.parse(tResult), targetIndent = this.indentLevel(open);
                    if (array != null) {
                        tResult = arrayPrinter_1.ArrayPrinter.print(array, this.transformOptions.tabSize, 1);
                        if (targetIndent > 0) {
                            tResult = stringUtilities_1.StringUtilities.removeEmptyNewLines(indentLevel_1.IndentLevel.shiftIndent(tResult, targetIndent, true));
                        }
                        content = '@props' + ' '.repeat(this.transformOptions.spacesAfterDirective) + '(' + tResult + ')';
                    }
                }
            }
            catch (err) {
                content = directive.sourceContent;
            }
            value = value.replace(open, content);
        });
        return value;
    }
    transformBreaks(content) {
        let value = content;
        this.breakDirectives.forEach((directive, slug) => {
            const close = this.close(slug), open = this.open(slug);
            this.removeLines.push(close);
            value = value.replace(open, directive.sourceContent);
        });
        return value;
    }
    transformComments(content) {
        let value = content;
        this.inlineComments.forEach((comment, slug) => {
            const open = this.selfClosing(slug);
            value = value.replace(open, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, 0));
        });
        return value;
    }
    indentLevel(value) {
        for (let i = 0; i < this.structureLines.length; i++) {
            const thisLine = this.structureLines[i];
            if (thisLine.includes(value)) {
                const trimmed = thisLine.trimLeft();
                return thisLine.length - trimmed.length;
            }
        }
        return 0;
    }
    transformVirtualComments(content) {
        let value = content;
        this.blockComments.forEach((structure) => {
            const comment = structure.node;
            value = value.replace(structure.pairOpen, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, this.indentLevel(structure.pairOpen)));
            this.removeLines.push(structure.pairClose);
            this.removeLines.push(structure.virtualElement);
        });
        return value;
    }
    transformDynamicElementForElse(content) {
        let value = content;
        this.dynamicElementForElseNodes.forEach((forElse, slug) => {
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, forElse.nodeContent);
        });
        return value;
    }
    transformDynamicElementConditions(content) {
        let value = content;
        this.dynamicElementConditionNodes.forEach((condition, slug) => {
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, condition.nodeContent);
        });
        return value;
    }
    transformDynamicElementSwitch(content) {
        let value = content;
        this.dynamicElementSwitchNodes.forEach((switchNode, slug) => {
            value = stringUtilities_1.StringUtilities.replaceAllInString(value, slug, switchNode.nodeContent);
        });
        return value;
    }
    transformDirectiveParameters(content) {
        let value = content;
        this.directiveParameters.forEach((param, slug) => {
            const paramDirective = param.directive;
            value = value.replace(slug, this.printDirective(paramDirective));
        });
        return value;
    }
    transformExpressionParameters(content) {
        let value = content;
        this.expressionParameters.forEach((param, slug) => {
            value = value.replace(slug, param.content);
        });
        return value;
    }
    transformEmbeddedEcho(content) {
        let value = content;
        this.embeddedEchos.forEach((echo, slug) => {
            value = value.replace(slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.phpFormatter));
        });
        return value;
    }
    transformEmbeddedDirectives(content) {
        let value = content;
        this.embeddedDirectives.forEach((directive, slug) => {
            value = value.replace(slug, this.printDirective(directive));
        });
        return value;
    }
    transformExtractedDocuments(content) {
        let value = content;
        this.extractedEmbeddedDocuments.forEach((document, slug) => {
            let target = '', indent = 0;
            if (document.isScript) {
                target = '//' + slug;
            }
            else {
                target = '/*' + slug + '*/';
            }
            indent = this.indentLevel(target);
            if (value.includes(target)) {
                value = value.replace(target, indentLevel_1.IndentLevel.indentRelative(document.content, indent));
            }
        });
        return value;
    }
    removeVirtualStructures(content) {
        let value = content;
        this.removeLines.forEach((line) => {
            value = value.replace(line, '');
        });
        return value;
    }
    shouldCleanAfter(line) {
        for (let i = 0; i < this.removeLines.length; i++) {
            if (line.startsWith(this.removeLines[i])) {
                return true;
            }
        }
        return false;
    }
    shouldCleanLine(line) {
        for (let i = 0; i < this.forceCleanLines.length; i++) {
            if (line.startsWith(this.forceCleanLines[i])) {
                return true;
            }
        }
        return false;
    }
    cleanVirtualStructures(content) {
        const newLines = [], contentLines = stringUtilities_1.StringUtilities.breakByNewLine(content);
        let removeNewLines = false;
        for (let i = 0; i < contentLines.length; i++) {
            const checkLine = contentLines[i].trim();
            if (removeNewLines) {
                if (checkLine.length == 0) {
                    continue;
                }
                else {
                    removeNewLines = false;
                }
            }
            else {
                removeNewLines = this.shouldCleanAfter(checkLine);
            }
            if (this.shouldCleanLine(checkLine)) {
                for (let j = newLines.length - 1; j > 0; j--) {
                    const tLine = newLines[j];
                    if (tLine.trim().length == 0) {
                        newLines.pop();
                    }
                    else {
                        break;
                    }
                }
            }
            if (this.removeLines.includes(checkLine)) {
                continue;
            }
            else {
                let newLine = contentLines[i];
                this.removeLines.forEach((line) => {
                    if (newLine.includes(line)) {
                        newLine = newLine.replace(line, '');
                    }
                });
                newLines.push(newLine);
            }
        }
        return newLines.join("\n");
    }
    reflowSlugs(content) {
        let result = content;
        this.slugs.forEach((slug) => {
            const open = this.open(slug), close = this.close(slug), selfClose = this.selfClosing(slug), openRegex = '/<' + slug + '(.*?)>/gms', closeRegex = '/</' + slug + '(.*?)>/gms', selfCloseRegex = '/<' + slug + '(.*?)/>/gms';
            result = result.replace(openRegex, open);
            result = result.replace(closeRegex, close);
            result = result.replace(selfCloseRegex, selfClose);
        });
        return result;
    }
    fromStructure(content) {
        const reflowedContent = this.reflowSlugs(content);
        this.structureLines = stringUtilities_1.StringUtilities.breakByNewLine(reflowedContent);
        let results = this.transformInlineDirectives(reflowedContent);
        results = this.transformContentDirectives(results);
        results = this.transformDynamicEcho(results);
        results = this.transformPairedDirectives(results);
        results = this.transformForElseWithEmpty(results);
        results = this.transformForElseWithNoEmpty(results);
        results = this.transformDynamicElementForElse(results);
        results = this.transformInlineEcho(results);
        results = this.transformConditions(results);
        results = this.transformDynamicElementConditions(results);
        results = this.transformSwitchStatements(results);
        results = this.transformDynamicElementSwitch(results);
        results = this.transformBreaks(results);
        results = this.transformProps(results);
        results = this.transformComments(results);
        results = this.transformVirtualComments(results);
        results = this.transformDirectiveParameters(results);
        results = this.transformExpressionParameters(results);
        results = this.transformDynamicDirectives(results);
        results = this.cleanVirtualStructures(results);
        results = this.removeVirtualStructures(results);
        results = this.transformEmbeddedEcho(results);
        results = this.transformEmbeddedDirectives(results);
        results = this.transformExtractedDocuments(results);
        results = this.transformPhpBlock(results);
        return results;
    }
}
exports.Transformer = Transformer;
//# sourceMappingURL=transformer.js.map