"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndentLevel = void 0;
const stringUtilities_1 = require("../../utilities/stringUtilities");
class IndentLevel {
    static indentRelative(value, targetIndent) {
        const sourceLines = stringUtilities_1.StringUtilities.breakByNewLine(value);
        let reflowedLines = [];
        // Clean up leading new lines.
        for (let i = 0; i < sourceLines.length; i++) {
            const thisLine = sourceLines[i];
            if (thisLine.trim().length > 0) {
                reflowedLines = sourceLines.slice(i);
                break;
            }
        }
        // Clean up trailing whitespace.
        for (let i = reflowedLines.length - 1; i >= 0; i--) {
            const thisLine = reflowedLines[i];
            if (thisLine.trim().length == 0) {
                reflowedLines.pop();
            }
            else {
                break;
            }
        }
        let leastIndentChange = -1;
        let thatLine = '';
        // Find which line currently has the least amount of left whitespace.
        for (let i = 0; i < reflowedLines.length; i++) {
            const thisLine = reflowedLines[i], checkLine = thisLine.trimLeft(), wsDiff = thisLine.length - checkLine.length;
            if (i == 0) {
                leastIndentChange = wsDiff;
                thatLine = thisLine;
            }
            else {
                if (wsDiff < leastIndentChange) {
                    leastIndentChange = wsDiff;
                    thatLine = thisLine;
                }
            }
        }
        // Remove the discovered leading whitespace and then apply our new (relative) indent level.
        if (leastIndentChange >= 0) {
            const targetWs = ' '.repeat(targetIndent);
            for (let i = 0; i < reflowedLines.length; i++) {
                const thisLine = reflowedLines[i];
                if (thisLine.trim().length == 0) {
                    reflowedLines[i] = '';
                    continue;
                }
                const reflowed = thisLine.substring(leastIndentChange);
                if (i == 0) {
                    reflowedLines[i] = thisLine.trimLeft();
                    continue;
                }
                else {
                    reflowedLines[i] = targetWs + reflowed;
                }
            }
        }
        return reflowedLines.join("\n");
    }
    static shiftIndent(value, targetIndent, skipFirst = false) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value.trim()), reflowedLines = [];
        for (let i = 0; i < lines.length; i++) {
            if (i == 0 && skipFirst) {
                reflowedLines.push(lines[i]);
                continue;
            }
            const line = lines[i];
            reflowedLines.push(' '.repeat(targetIndent) + line);
        }
        return reflowedLines.join("\n");
    }
    static shiftClean(value, indent) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value), reflowedLines = [], pad = ' '.repeat(indent);
        let hasFoundContent = false;
        lines.forEach((line) => {
            if (line.trim().length > 0) {
                hasFoundContent = true;
            }
            if (!hasFoundContent) {
                return;
            }
            reflowedLines.push(pad + line);
        });
        return reflowedLines.join("\n");
    }
    static inferIndentLevel(structureLines, value, defaultIndent) {
        let targetLevel = 0, targetLevelFoundOn = -1;
        for (let i = 0; i < structureLines.length; i++) {
            const thisLine = structureLines[i];
            if (thisLine.includes(value)) {
                const trimmed = thisLine.trimLeft();
                targetLevel = thisLine.length - trimmed.length;
                targetLevelFoundOn = i;
                break;
            }
        }
        if (targetLevelFoundOn > 0) {
            for (let i = targetLevelFoundOn - 1; i >= 0; i--) {
                const thisLine = structureLines[i], trimmed = thisLine.trim(), trimmedLeft = thisLine.trimLeft(), checkLevel = thisLine.length - trimmed.length;
                if (trimmedLeft.length == 0) {
                    continue;
                }
                if (checkLevel != targetLevel && checkLevel < targetLevel) {
                    const inferred = targetLevel - checkLevel;
                    return {
                        targetLevel: targetLevel,
                        referenceLevel: checkLevel,
                        sourceTabSize: inferred
                    };
                }
            }
        }
        return {
            targetLevel: targetLevel,
            referenceLevel: targetLevel,
            sourceTabSize: defaultIndent
        };
    }
    static indent(structureLines, value, defaultIndent) {
        const levels = IndentLevel.inferIndentLevel(structureLines, value, defaultIndent);
        return ' '.repeat(levels.targetLevel);
    }
}
exports.IndentLevel = IndentLevel;
//# sourceMappingURL=indentLevel.js.map